
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Bill
 */

export type Bill = {
  id: string
  createdAt: Date
  closedAt: Date | null
  status: BillStatus
  discount: number | null
  discountReason: string | null
  value: number | null
  valueAfterDiscount: number | null
  wasReopen: boolean | null
  registered: boolean | null
  workDayId: string | null
  tableDataId: string | null
}

/**
 * Model CheckData
 */

export type CheckData = {
  id: string
  checkbookId: string | null
  compensationNumber: number | null
  bankNumber: number | null
}

/**
 * Model Client
 */

export type Client = {
  id: string
  name: string
  address: string
  complement: string | null
  postCode: string
  telephoneNumber: string
  distanceKm: string
  distanceTime: string
  establishmentId: string | null
}

/**
 * Model Employee
 */

export type Employee = {
  id: string
  createdAt: Date
  employeeId: number
  name: string
  role: string
  admissionDate: Date | null
  terminationDate: Date | null
  isActive: boolean
  establishmentId: string | null
}

/**
 * Model Establishment
 */

export type Establishment = {
  id: string
  createdAt: Date
  name: string
  lat: number
  long: number
  restaurantId: string
  valueInCashRegister: number
  maximumInCashRegister: number
  incomeMaxReference: number
  isOpen: boolean
  totalInvoices: number | null
  discountReasons: string[]
}

/**
 * Model Expense
 */

export type Expense = {
  id: string
  createdAt: Date
  NFE: boolean
  NFEReference: string | null
  date: Date
  executionDate: Date
  establishmentId: string | null
}

/**
 * Model ExpenseItem
 */

export type ExpenseItem = {
  id: string
  createdAt: Date
  quantity: number
  value: number
  details: string | null
  productId: string | null
}

/**
 * Model Income
 */

export type Income = {
  id: string
  createdAt: Date
  reference: string
  value: number
  type: string | null
  workDayId: string | null
}

/**
 * Model Item
 */

export type Item = {
  id: string
  itemId: string
  name: string
  price: number
  priceToGo: number | null
  employeePrice: number | null
  category: string
  canTakeToGo: boolean | null
  isActive: boolean
  hasTaxSubstitution: boolean | null
  establishmentId: string | null
  itemNCMId: string | null
}

/**
 * Model NCM
 */

export type NCM = {
  id: string
  identifier: string
  description: string | null
}

/**
 * Model Order
 */

export type Order = {
  id: string
  createdAt: Date
  block: number
  orderId: number
  cancelled: boolean | null
  cancelationJustification: string | null
  wasModified: boolean | null
  isEmployeeOrder: boolean | null
  reuse: boolean | null
  isToGo: boolean | null
  toGoReference: string | null
  workDayId: string | null
  billId: string | null
}

/**
 * Model OrderItem
 */

export type OrderItem = {
  id: string
  quantity: number
  orderId: string | null
  employeeId: string | null
  itemId: string | null
}

/**
 * Model OrderPad
 */

export type OrderPad = {
  id: string
  block: number
  firstOrderId: number
  lastOrderId: number | null
  used: boolean
  workDayId: string | null
  employeeId: string | null
}

/**
 * Model Payment
 */

export type Payment = {
  id: string
  createdAt: Date
  value: number
  paymentType: string
  paymentTypeOption: string | null
  isActive: boolean
  expenseId: string | null
  checkDataId: string | null
  billId: string | null
}

/**
 * Model Permission
 */

export type Permission = {
  id: string
  createdAt: Date
  role: UserRole
  userId: string | null
  establishmentId: string | null
}

/**
 * Model Product
 */

export type Product = {
  id: string
  name: string
  category: string
  supplier: string
  brand: string | null
  unit: string
}

/**
 * Model Table
 */

export type Table = {
  id: string
  tableNumber: number
  establishmentId: string | null
}

/**
 * Model TableData
 */

export type TableData = {
  id: string
  totalOccupations: number
  workDayId: string | null
  tableId: string | null
  waiterId: string | null
}

/**
 * Model User
 */

export type User = {
  id: string
  createdAt: Date
  updatedAt: Date
  email: string | null
  password: string | null
}

/**
 * Model WorkDay
 */

export type WorkDay = {
  id: string
  createdAt: Date
  isCurrent: boolean
  openDate: Date
  closeDate: Date | null
  establishmentId: string | null
  userResponsibleId: string | null
}

/**
 * Model WorkHour
 */

export type WorkHour = {
  id: string
  weekday: WeekDay
  startTime: string | null
  endTime: string | null
  isDayOff: boolean | null
  employeeId: string | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const BillStatus: {
  PAID: 'PAID',
  OPEN: 'OPEN',
  CLOSED: 'CLOSED'
};

export type BillStatus = (typeof BillStatus)[keyof typeof BillStatus]


export const UserRole: {
  EDITOR: 'EDITOR',
  MODERATOR: 'MODERATOR',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const WeekDay: {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY'
};

export type WeekDay = (typeof WeekDay)[keyof typeof WeekDay]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bills
 * const bills = await prisma.bill.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bills
   * const bills = await prisma.bill.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.bill`: Exposes CRUD operations for the **Bill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills
    * const bills = await prisma.bill.findMany()
    * ```
    */
  get bill(): Prisma.BillDelegate<GlobalReject>;

  /**
   * `prisma.checkData`: Exposes CRUD operations for the **CheckData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckData
    * const checkData = await prisma.checkData.findMany()
    * ```
    */
  get checkData(): Prisma.CheckDataDelegate<GlobalReject>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<GlobalReject>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<GlobalReject>;

  /**
   * `prisma.establishment`: Exposes CRUD operations for the **Establishment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Establishments
    * const establishments = await prisma.establishment.findMany()
    * ```
    */
  get establishment(): Prisma.EstablishmentDelegate<GlobalReject>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<GlobalReject>;

  /**
   * `prisma.expenseItem`: Exposes CRUD operations for the **ExpenseItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseItems
    * const expenseItems = await prisma.expenseItem.findMany()
    * ```
    */
  get expenseItem(): Prisma.ExpenseItemDelegate<GlobalReject>;

  /**
   * `prisma.income`: Exposes CRUD operations for the **Income** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incomes
    * const incomes = await prisma.income.findMany()
    * ```
    */
  get income(): Prisma.IncomeDelegate<GlobalReject>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<GlobalReject>;

  /**
   * `prisma.nCM`: Exposes CRUD operations for the **NCM** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NCMS
    * const nCMS = await prisma.nCM.findMany()
    * ```
    */
  get nCM(): Prisma.NCMDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<GlobalReject>;

  /**
   * `prisma.orderPad`: Exposes CRUD operations for the **OrderPad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderPads
    * const orderPads = await prisma.orderPad.findMany()
    * ```
    */
  get orderPad(): Prisma.OrderPadDelegate<GlobalReject>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<GlobalReject>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;

  /**
   * `prisma.table`: Exposes CRUD operations for the **Table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables
    * const tables = await prisma.table.findMany()
    * ```
    */
  get table(): Prisma.TableDelegate<GlobalReject>;

  /**
   * `prisma.tableData`: Exposes CRUD operations for the **TableData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TableData
    * const tableData = await prisma.tableData.findMany()
    * ```
    */
  get tableData(): Prisma.TableDataDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.workDay`: Exposes CRUD operations for the **WorkDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkDays
    * const workDays = await prisma.workDay.findMany()
    * ```
    */
  get workDay(): Prisma.WorkDayDelegate<GlobalReject>;

  /**
   * `prisma.workHour`: Exposes CRUD operations for the **WorkHour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkHours
    * const workHours = await prisma.workHour.findMany()
    * ```
    */
  get workHour(): Prisma.WorkHourDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.23.0
   * Query Engine version: adf5e8cba3daf12d456d911d72b6e9418681b28b
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Bill: 'Bill',
    CheckData: 'CheckData',
    Client: 'Client',
    Employee: 'Employee',
    Establishment: 'Establishment',
    Expense: 'Expense',
    ExpenseItem: 'ExpenseItem',
    Income: 'Income',
    Item: 'Item',
    NCM: 'NCM',
    Order: 'Order',
    OrderItem: 'OrderItem',
    OrderPad: 'OrderPad',
    Payment: 'Payment',
    Permission: 'Permission',
    Product: 'Product',
    Table: 'Table',
    TableData: 'TableData',
    User: 'User',
    WorkDay: 'WorkDay',
    WorkHour: 'WorkHour'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Bill
   */


  export type AggregateBill = {
    _count: BillCountAggregateOutputType | null
    count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
    max: BillMaxAggregateOutputType | null
  }

  export type BillAvgAggregateOutputType = {
    discount: number | null
    value: number | null
    valueAfterDiscount: number | null
  }

  export type BillSumAggregateOutputType = {
    discount: number | null
    value: number | null
    valueAfterDiscount: number | null
  }

  export type BillMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    closedAt: Date | null
    status: BillStatus | null
    discount: number | null
    discountReason: string | null
    value: number | null
    valueAfterDiscount: number | null
    wasReopen: boolean | null
    registered: boolean | null
    workDayId: string | null
    tableDataId: string | null
  }

  export type BillMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    closedAt: Date | null
    status: BillStatus | null
    discount: number | null
    discountReason: string | null
    value: number | null
    valueAfterDiscount: number | null
    wasReopen: boolean | null
    registered: boolean | null
    workDayId: string | null
    tableDataId: string | null
  }

  export type BillCountAggregateOutputType = {
    id: number
    createdAt: number
    closedAt: number
    status: number
    discount: number
    discountReason: number
    value: number
    valueAfterDiscount: number
    wasReopen: number
    registered: number
    workDayId: number
    tableDataId: number
    _all: number
  }


  export type BillAvgAggregateInputType = {
    discount?: true
    value?: true
    valueAfterDiscount?: true
  }

  export type BillSumAggregateInputType = {
    discount?: true
    value?: true
    valueAfterDiscount?: true
  }

  export type BillMinAggregateInputType = {
    id?: true
    createdAt?: true
    closedAt?: true
    status?: true
    discount?: true
    discountReason?: true
    value?: true
    valueAfterDiscount?: true
    wasReopen?: true
    registered?: true
    workDayId?: true
    tableDataId?: true
  }

  export type BillMaxAggregateInputType = {
    id?: true
    createdAt?: true
    closedAt?: true
    status?: true
    discount?: true
    discountReason?: true
    value?: true
    valueAfterDiscount?: true
    wasReopen?: true
    registered?: true
    workDayId?: true
    tableDataId?: true
  }

  export type BillCountAggregateInputType = {
    id?: true
    createdAt?: true
    closedAt?: true
    status?: true
    discount?: true
    discountReason?: true
    value?: true
    valueAfterDiscount?: true
    wasReopen?: true
    registered?: true
    workDayId?: true
    tableDataId?: true
    _all?: true
  }

  export type BillAggregateArgs = {
    /**
     * Filter which Bill to aggregate.
     * 
    **/
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     * 
    **/
    orderBy?: Enumerable<BillOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bills
    **/
    _count?: true | BillCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | BillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: BillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: BillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: BillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: BillMaxAggregateInputType
  }

  export type GetBillAggregateType<T extends BillAggregateArgs> = {
        [P in keyof T & keyof AggregateBill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBill[P]>
      : GetScalarType<T[P], AggregateBill[P]>
  }


    
    
  export type BillGroupByArgs = {
    where?: BillWhereInput
    orderBy?: Enumerable<BillOrderByInput>
    by: Array<BillScalarFieldEnum>
    having?: BillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillCountAggregateInputType | true
    _avg?: BillAvgAggregateInputType
    _sum?: BillSumAggregateInputType
    _min?: BillMinAggregateInputType
    _max?: BillMaxAggregateInputType
  }


  export type BillGroupByOutputType = {
    id: string
    createdAt: Date
    closedAt: Date | null
    status: BillStatus
    discount: number | null
    discountReason: string | null
    value: number | null
    valueAfterDiscount: number | null
    wasReopen: boolean | null
    registered: boolean | null
    workDayId: string | null
    tableDataId: string | null
    _count: BillCountAggregateOutputType | null
    _avg: BillAvgAggregateOutputType | null
    _sum: BillSumAggregateOutputType | null
    _min: BillMinAggregateOutputType | null
    _max: BillMaxAggregateOutputType | null
  }

  type GetBillGroupByPayload<T extends BillGroupByArgs> = Promise<
    Array<
      PickArray<BillGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof BillGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], BillGroupByOutputType[P]> 
            : GetScalarType<T[P], BillGroupByOutputType[P]>
        }
      > 
    >


  export type BillSelect = {
    id?: boolean
    createdAt?: boolean
    closedAt?: boolean
    status?: boolean
    discount?: boolean
    discountReason?: boolean
    value?: boolean
    valueAfterDiscount?: boolean
    wasReopen?: boolean
    registered?: boolean
    workDayId?: boolean
    tableDataId?: boolean
    tableData?: boolean | TableDataArgs
    workDay?: boolean | WorkDayArgs
    orders?: boolean | OrderFindManyArgs
    payments?: boolean | PaymentFindManyArgs
    reopenBillsId?: boolean | BillFindManyArgs
    reopenBills?: boolean | BillFindManyArgs
  }

  export type BillInclude = {
    tableData?: boolean | TableDataArgs
    workDay?: boolean | WorkDayArgs
    orders?: boolean | OrderFindManyArgs
    payments?: boolean | PaymentFindManyArgs
    reopenBillsId?: boolean | BillFindManyArgs
    reopenBills?: boolean | BillFindManyArgs
  }

  export type BillGetPayload<
    S extends boolean | null | undefined | BillArgs,
    U = keyof S
      > = S extends true
        ? Bill
    : S extends undefined
    ? never
    : S extends BillArgs | BillFindManyArgs
    ?'include' extends U
    ? Bill  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'tableData'
        ? TableDataGetPayload<S['include'][P]> | null :
        P extends 'workDay'
        ? WorkDayGetPayload<S['include'][P]> | null :
        P extends 'orders'
        ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends 'payments'
        ? Array < PaymentGetPayload<S['include'][P]>>  :
        P extends 'reopenBillsId'
        ? Array < BillGetPayload<S['include'][P]>>  :
        P extends 'reopenBills'
        ? Array < BillGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Bill ?Bill [P]
  : 
          P extends 'tableData'
        ? TableDataGetPayload<S['select'][P]> | null :
        P extends 'workDay'
        ? WorkDayGetPayload<S['select'][P]> | null :
        P extends 'orders'
        ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends 'payments'
        ? Array < PaymentGetPayload<S['select'][P]>>  :
        P extends 'reopenBillsId'
        ? Array < BillGetPayload<S['select'][P]>>  :
        P extends 'reopenBills'
        ? Array < BillGetPayload<S['select'][P]>>  : never
  } 
    : Bill
  : Bill


  type BillCountArgs = Merge<
    Omit<BillFindManyArgs, 'select' | 'include'> & {
      select?: BillCountAggregateInputType | true
    }
  >

  export interface BillDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Bill that matches the filter.
     * @param {BillFindUniqueArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BillFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BillFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Bill'> extends True ? CheckSelect<T, Prisma__BillClient<Bill>, Prisma__BillClient<BillGetPayload<T>>> : CheckSelect<T, Prisma__BillClient<Bill | null >, Prisma__BillClient<BillGetPayload<T> | null >>

    /**
     * Find the first Bill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindFirstArgs} args - Arguments to find a Bill
     * @example
     * // Get one Bill
     * const bill = await prisma.bill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BillFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BillFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Bill'> extends True ? CheckSelect<T, Prisma__BillClient<Bill>, Prisma__BillClient<BillGetPayload<T>>> : CheckSelect<T, Prisma__BillClient<Bill | null >, Prisma__BillClient<BillGetPayload<T> | null >>

    /**
     * Find zero or more Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills
     * const bills = await prisma.bill.findMany()
     * 
     * // Get first 10 Bills
     * const bills = await prisma.bill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billWithIdOnly = await prisma.bill.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BillFindManyArgs>(
      args?: SelectSubset<T, BillFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Bill>>, PrismaPromise<Array<BillGetPayload<T>>>>

    /**
     * Create a Bill.
     * @param {BillCreateArgs} args - Arguments to create a Bill.
     * @example
     * // Create one Bill
     * const Bill = await prisma.bill.create({
     *   data: {
     *     // ... data to create a Bill
     *   }
     * })
     * 
    **/
    create<T extends BillCreateArgs>(
      args: SelectSubset<T, BillCreateArgs>
    ): CheckSelect<T, Prisma__BillClient<Bill>, Prisma__BillClient<BillGetPayload<T>>>

    /**
     * Create many Bills.
     *     @param {BillCreateManyArgs} args - Arguments to create many Bills.
     *     @example
     *     // Create many Bills
     *     const bill = await prisma.bill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BillCreateManyArgs>(
      args?: SelectSubset<T, BillCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Bill.
     * @param {BillDeleteArgs} args - Arguments to delete one Bill.
     * @example
     * // Delete one Bill
     * const Bill = await prisma.bill.delete({
     *   where: {
     *     // ... filter to delete one Bill
     *   }
     * })
     * 
    **/
    delete<T extends BillDeleteArgs>(
      args: SelectSubset<T, BillDeleteArgs>
    ): CheckSelect<T, Prisma__BillClient<Bill>, Prisma__BillClient<BillGetPayload<T>>>

    /**
     * Update one Bill.
     * @param {BillUpdateArgs} args - Arguments to update one Bill.
     * @example
     * // Update one Bill
     * const bill = await prisma.bill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BillUpdateArgs>(
      args: SelectSubset<T, BillUpdateArgs>
    ): CheckSelect<T, Prisma__BillClient<Bill>, Prisma__BillClient<BillGetPayload<T>>>

    /**
     * Delete zero or more Bills.
     * @param {BillDeleteManyArgs} args - Arguments to filter Bills to delete.
     * @example
     * // Delete a few Bills
     * const { count } = await prisma.bill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BillDeleteManyArgs>(
      args?: SelectSubset<T, BillDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills
     * const bill = await prisma.bill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BillUpdateManyArgs>(
      args: SelectSubset<T, BillUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Bill.
     * @param {BillUpsertArgs} args - Arguments to update or create a Bill.
     * @example
     * // Update or create a Bill
     * const bill = await prisma.bill.upsert({
     *   create: {
     *     // ... data to create a Bill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bill we want to update
     *   }
     * })
    **/
    upsert<T extends BillUpsertArgs>(
      args: SelectSubset<T, BillUpsertArgs>
    ): CheckSelect<T, Prisma__BillClient<Bill>, Prisma__BillClient<BillGetPayload<T>>>

    /**
     * Count the number of Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillCountArgs} args - Arguments to filter Bills to count.
     * @example
     * // Count the number of Bills
     * const count = await prisma.bill.count({
     *   where: {
     *     // ... the filter for the Bills we want to count
     *   }
     * })
    **/
    count<T extends BillCountArgs>(
      args?: Subset<T, BillCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillAggregateArgs>(args: Subset<T, BillAggregateArgs>): PrismaPromise<GetBillAggregateType<T>>

    /**
     * Group by Bill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillGroupByArgs['orderBy'] }
        : { orderBy?: BillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BillClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    tableData<T extends TableDataArgs = {}>(args?: Subset<T, TableDataArgs>): CheckSelect<T, Prisma__TableDataClient<TableData | null >, Prisma__TableDataClient<TableDataGetPayload<T> | null >>;

    workDay<T extends WorkDayArgs = {}>(args?: Subset<T, WorkDayArgs>): CheckSelect<T, Prisma__WorkDayClient<WorkDay | null >, Prisma__WorkDayClient<WorkDayGetPayload<T> | null >>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>;

    payments<T extends PaymentFindManyArgs = {}>(args?: Subset<T, PaymentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Payment>>, PrismaPromise<Array<PaymentGetPayload<T>>>>;

    reopenBillsId<T extends BillFindManyArgs = {}>(args?: Subset<T, BillFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Bill>>, PrismaPromise<Array<BillGetPayload<T>>>>;

    reopenBills<T extends BillFindManyArgs = {}>(args?: Subset<T, BillFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Bill>>, PrismaPromise<Array<BillGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Bill findUnique
   */
  export type BillFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Bill
     * 
    **/
    select?: BillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillInclude | null
    /**
     * Throw an Error if a Bill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Bill to fetch.
     * 
    **/
    where: BillWhereUniqueInput
  }


  /**
   * Bill findFirst
   */
  export type BillFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Bill
     * 
    **/
    select?: BillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillInclude | null
    /**
     * Throw an Error if a Bill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Bill to fetch.
     * 
    **/
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     * 
    **/
    orderBy?: Enumerable<BillOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     * 
    **/
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     * 
    **/
    distinct?: Enumerable<BillScalarFieldEnum>
  }


  /**
   * Bill findMany
   */
  export type BillFindManyArgs = {
    /**
     * Select specific fields to fetch from the Bill
     * 
    **/
    select?: BillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillInclude | null
    /**
     * Filter, which Bills to fetch.
     * 
    **/
    where?: BillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     * 
    **/
    orderBy?: Enumerable<BillOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bills.
     * 
    **/
    cursor?: BillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BillScalarFieldEnum>
  }


  /**
   * Bill create
   */
  export type BillCreateArgs = {
    /**
     * Select specific fields to fetch from the Bill
     * 
    **/
    select?: BillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillInclude | null
    /**
     * The data needed to create a Bill.
     * 
    **/
    data: XOR<BillCreateInput, BillUncheckedCreateInput>
  }


  /**
   * Bill createMany
   */
  export type BillCreateManyArgs = {
    data: Enumerable<BillCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Bill update
   */
  export type BillUpdateArgs = {
    /**
     * Select specific fields to fetch from the Bill
     * 
    **/
    select?: BillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillInclude | null
    /**
     * The data needed to update a Bill.
     * 
    **/
    data: XOR<BillUpdateInput, BillUncheckedUpdateInput>
    /**
     * Choose, which Bill to update.
     * 
    **/
    where: BillWhereUniqueInput
  }


  /**
   * Bill updateMany
   */
  export type BillUpdateManyArgs = {
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyInput>
    where?: BillWhereInput
  }


  /**
   * Bill upsert
   */
  export type BillUpsertArgs = {
    /**
     * Select specific fields to fetch from the Bill
     * 
    **/
    select?: BillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillInclude | null
    /**
     * The filter to search for the Bill to update in case it exists.
     * 
    **/
    where: BillWhereUniqueInput
    /**
     * In case the Bill found by the `where` argument doesn't exist, create a new Bill with this data.
     * 
    **/
    create: XOR<BillCreateInput, BillUncheckedCreateInput>
    /**
     * In case the Bill was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<BillUpdateInput, BillUncheckedUpdateInput>
  }


  /**
   * Bill delete
   */
  export type BillDeleteArgs = {
    /**
     * Select specific fields to fetch from the Bill
     * 
    **/
    select?: BillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillInclude | null
    /**
     * Filter which Bill to delete.
     * 
    **/
    where: BillWhereUniqueInput
  }


  /**
   * Bill deleteMany
   */
  export type BillDeleteManyArgs = {
    where?: BillWhereInput
  }


  /**
   * Bill without action
   */
  export type BillArgs = {
    /**
     * Select specific fields to fetch from the Bill
     * 
    **/
    select?: BillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: BillInclude | null
  }



  /**
   * Model CheckData
   */


  export type AggregateCheckData = {
    _count: CheckDataCountAggregateOutputType | null
    count: CheckDataCountAggregateOutputType | null
    _avg: CheckDataAvgAggregateOutputType | null
    avg: CheckDataAvgAggregateOutputType | null
    _sum: CheckDataSumAggregateOutputType | null
    sum: CheckDataSumAggregateOutputType | null
    _min: CheckDataMinAggregateOutputType | null
    min: CheckDataMinAggregateOutputType | null
    _max: CheckDataMaxAggregateOutputType | null
    max: CheckDataMaxAggregateOutputType | null
  }

  export type CheckDataAvgAggregateOutputType = {
    compensationNumber: number | null
    bankNumber: number | null
  }

  export type CheckDataSumAggregateOutputType = {
    compensationNumber: number | null
    bankNumber: number | null
  }

  export type CheckDataMinAggregateOutputType = {
    id: string | null
    checkbookId: string | null
    compensationNumber: number | null
    bankNumber: number | null
  }

  export type CheckDataMaxAggregateOutputType = {
    id: string | null
    checkbookId: string | null
    compensationNumber: number | null
    bankNumber: number | null
  }

  export type CheckDataCountAggregateOutputType = {
    id: number
    checkbookId: number
    compensationNumber: number
    bankNumber: number
    _all: number
  }


  export type CheckDataAvgAggregateInputType = {
    compensationNumber?: true
    bankNumber?: true
  }

  export type CheckDataSumAggregateInputType = {
    compensationNumber?: true
    bankNumber?: true
  }

  export type CheckDataMinAggregateInputType = {
    id?: true
    checkbookId?: true
    compensationNumber?: true
    bankNumber?: true
  }

  export type CheckDataMaxAggregateInputType = {
    id?: true
    checkbookId?: true
    compensationNumber?: true
    bankNumber?: true
  }

  export type CheckDataCountAggregateInputType = {
    id?: true
    checkbookId?: true
    compensationNumber?: true
    bankNumber?: true
    _all?: true
  }

  export type CheckDataAggregateArgs = {
    /**
     * Filter which CheckData to aggregate.
     * 
    **/
    where?: CheckDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckData to fetch.
     * 
    **/
    orderBy?: Enumerable<CheckDataOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CheckDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckData from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckData.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckData
    **/
    _count?: true | CheckDataCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | CheckDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheckDataAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: CheckDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheckDataSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: CheckDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckDataMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: CheckDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckDataMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: CheckDataMaxAggregateInputType
  }

  export type GetCheckDataAggregateType<T extends CheckDataAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckData[P]>
      : GetScalarType<T[P], AggregateCheckData[P]>
  }


    
    
  export type CheckDataGroupByArgs = {
    where?: CheckDataWhereInput
    orderBy?: Enumerable<CheckDataOrderByInput>
    by: Array<CheckDataScalarFieldEnum>
    having?: CheckDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckDataCountAggregateInputType | true
    _avg?: CheckDataAvgAggregateInputType
    _sum?: CheckDataSumAggregateInputType
    _min?: CheckDataMinAggregateInputType
    _max?: CheckDataMaxAggregateInputType
  }


  export type CheckDataGroupByOutputType = {
    id: string
    checkbookId: string | null
    compensationNumber: number | null
    bankNumber: number | null
    _count: CheckDataCountAggregateOutputType | null
    _avg: CheckDataAvgAggregateOutputType | null
    _sum: CheckDataSumAggregateOutputType | null
    _min: CheckDataMinAggregateOutputType | null
    _max: CheckDataMaxAggregateOutputType | null
  }

  type GetCheckDataGroupByPayload<T extends CheckDataGroupByArgs> = Promise<
    Array<
      PickArray<CheckDataGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof CheckDataGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], CheckDataGroupByOutputType[P]> 
            : GetScalarType<T[P], CheckDataGroupByOutputType[P]>
        }
      > 
    >


  export type CheckDataSelect = {
    id?: boolean
    checkbookId?: boolean
    compensationNumber?: boolean
    bankNumber?: boolean
    payment?: boolean | PaymentArgs
  }

  export type CheckDataInclude = {
    payment?: boolean | PaymentArgs
  }

  export type CheckDataGetPayload<
    S extends boolean | null | undefined | CheckDataArgs,
    U = keyof S
      > = S extends true
        ? CheckData
    : S extends undefined
    ? never
    : S extends CheckDataArgs | CheckDataFindManyArgs
    ?'include' extends U
    ? CheckData  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'payment'
        ? PaymentGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CheckData ?CheckData [P]
  : 
          P extends 'payment'
        ? PaymentGetPayload<S['select'][P]> | null : never
  } 
    : CheckData
  : CheckData


  type CheckDataCountArgs = Merge<
    Omit<CheckDataFindManyArgs, 'select' | 'include'> & {
      select?: CheckDataCountAggregateInputType | true
    }
  >

  export interface CheckDataDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CheckData that matches the filter.
     * @param {CheckDataFindUniqueArgs} args - Arguments to find a CheckData
     * @example
     * // Get one CheckData
     * const checkData = await prisma.checkData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CheckDataFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CheckDataFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CheckData'> extends True ? CheckSelect<T, Prisma__CheckDataClient<CheckData>, Prisma__CheckDataClient<CheckDataGetPayload<T>>> : CheckSelect<T, Prisma__CheckDataClient<CheckData | null >, Prisma__CheckDataClient<CheckDataGetPayload<T> | null >>

    /**
     * Find the first CheckData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDataFindFirstArgs} args - Arguments to find a CheckData
     * @example
     * // Get one CheckData
     * const checkData = await prisma.checkData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CheckDataFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CheckDataFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CheckData'> extends True ? CheckSelect<T, Prisma__CheckDataClient<CheckData>, Prisma__CheckDataClient<CheckDataGetPayload<T>>> : CheckSelect<T, Prisma__CheckDataClient<CheckData | null >, Prisma__CheckDataClient<CheckDataGetPayload<T> | null >>

    /**
     * Find zero or more CheckData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckData
     * const checkData = await prisma.checkData.findMany()
     * 
     * // Get first 10 CheckData
     * const checkData = await prisma.checkData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkDataWithIdOnly = await prisma.checkData.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CheckDataFindManyArgs>(
      args?: SelectSubset<T, CheckDataFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CheckData>>, PrismaPromise<Array<CheckDataGetPayload<T>>>>

    /**
     * Create a CheckData.
     * @param {CheckDataCreateArgs} args - Arguments to create a CheckData.
     * @example
     * // Create one CheckData
     * const CheckData = await prisma.checkData.create({
     *   data: {
     *     // ... data to create a CheckData
     *   }
     * })
     * 
    **/
    create<T extends CheckDataCreateArgs>(
      args: SelectSubset<T, CheckDataCreateArgs>
    ): CheckSelect<T, Prisma__CheckDataClient<CheckData>, Prisma__CheckDataClient<CheckDataGetPayload<T>>>

    /**
     * Create many CheckData.
     *     @param {CheckDataCreateManyArgs} args - Arguments to create many CheckData.
     *     @example
     *     // Create many CheckData
     *     const checkData = await prisma.checkData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CheckDataCreateManyArgs>(
      args?: SelectSubset<T, CheckDataCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CheckData.
     * @param {CheckDataDeleteArgs} args - Arguments to delete one CheckData.
     * @example
     * // Delete one CheckData
     * const CheckData = await prisma.checkData.delete({
     *   where: {
     *     // ... filter to delete one CheckData
     *   }
     * })
     * 
    **/
    delete<T extends CheckDataDeleteArgs>(
      args: SelectSubset<T, CheckDataDeleteArgs>
    ): CheckSelect<T, Prisma__CheckDataClient<CheckData>, Prisma__CheckDataClient<CheckDataGetPayload<T>>>

    /**
     * Update one CheckData.
     * @param {CheckDataUpdateArgs} args - Arguments to update one CheckData.
     * @example
     * // Update one CheckData
     * const checkData = await prisma.checkData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CheckDataUpdateArgs>(
      args: SelectSubset<T, CheckDataUpdateArgs>
    ): CheckSelect<T, Prisma__CheckDataClient<CheckData>, Prisma__CheckDataClient<CheckDataGetPayload<T>>>

    /**
     * Delete zero or more CheckData.
     * @param {CheckDataDeleteManyArgs} args - Arguments to filter CheckData to delete.
     * @example
     * // Delete a few CheckData
     * const { count } = await prisma.checkData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CheckDataDeleteManyArgs>(
      args?: SelectSubset<T, CheckDataDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckData
     * const checkData = await prisma.checkData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CheckDataUpdateManyArgs>(
      args: SelectSubset<T, CheckDataUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CheckData.
     * @param {CheckDataUpsertArgs} args - Arguments to update or create a CheckData.
     * @example
     * // Update or create a CheckData
     * const checkData = await prisma.checkData.upsert({
     *   create: {
     *     // ... data to create a CheckData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckData we want to update
     *   }
     * })
    **/
    upsert<T extends CheckDataUpsertArgs>(
      args: SelectSubset<T, CheckDataUpsertArgs>
    ): CheckSelect<T, Prisma__CheckDataClient<CheckData>, Prisma__CheckDataClient<CheckDataGetPayload<T>>>

    /**
     * Count the number of CheckData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDataCountArgs} args - Arguments to filter CheckData to count.
     * @example
     * // Count the number of CheckData
     * const count = await prisma.checkData.count({
     *   where: {
     *     // ... the filter for the CheckData we want to count
     *   }
     * })
    **/
    count<T extends CheckDataCountArgs>(
      args?: Subset<T, CheckDataCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckDataAggregateArgs>(args: Subset<T, CheckDataAggregateArgs>): PrismaPromise<GetCheckDataAggregateType<T>>

    /**
     * Group by CheckData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckDataGroupByArgs['orderBy'] }
        : { orderBy?: CheckDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckDataGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CheckDataClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    payment<T extends PaymentArgs = {}>(args?: Subset<T, PaymentArgs>): CheckSelect<T, Prisma__PaymentClient<Payment | null >, Prisma__PaymentClient<PaymentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CheckData findUnique
   */
  export type CheckDataFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CheckData
     * 
    **/
    select?: CheckDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CheckDataInclude | null
    /**
     * Throw an Error if a CheckData can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CheckData to fetch.
     * 
    **/
    where: CheckDataWhereUniqueInput
  }


  /**
   * CheckData findFirst
   */
  export type CheckDataFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CheckData
     * 
    **/
    select?: CheckDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CheckDataInclude | null
    /**
     * Throw an Error if a CheckData can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CheckData to fetch.
     * 
    **/
    where?: CheckDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckData to fetch.
     * 
    **/
    orderBy?: Enumerable<CheckDataOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckData.
     * 
    **/
    cursor?: CheckDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckData from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckData.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckData.
     * 
    **/
    distinct?: Enumerable<CheckDataScalarFieldEnum>
  }


  /**
   * CheckData findMany
   */
  export type CheckDataFindManyArgs = {
    /**
     * Select specific fields to fetch from the CheckData
     * 
    **/
    select?: CheckDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CheckDataInclude | null
    /**
     * Filter, which CheckData to fetch.
     * 
    **/
    where?: CheckDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckData to fetch.
     * 
    **/
    orderBy?: Enumerable<CheckDataOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckData.
     * 
    **/
    cursor?: CheckDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckData from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckData.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CheckDataScalarFieldEnum>
  }


  /**
   * CheckData create
   */
  export type CheckDataCreateArgs = {
    /**
     * Select specific fields to fetch from the CheckData
     * 
    **/
    select?: CheckDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CheckDataInclude | null
    /**
     * The data needed to create a CheckData.
     * 
    **/
    data: XOR<CheckDataCreateInput, CheckDataUncheckedCreateInput>
  }


  /**
   * CheckData createMany
   */
  export type CheckDataCreateManyArgs = {
    data: Enumerable<CheckDataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CheckData update
   */
  export type CheckDataUpdateArgs = {
    /**
     * Select specific fields to fetch from the CheckData
     * 
    **/
    select?: CheckDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CheckDataInclude | null
    /**
     * The data needed to update a CheckData.
     * 
    **/
    data: XOR<CheckDataUpdateInput, CheckDataUncheckedUpdateInput>
    /**
     * Choose, which CheckData to update.
     * 
    **/
    where: CheckDataWhereUniqueInput
  }


  /**
   * CheckData updateMany
   */
  export type CheckDataUpdateManyArgs = {
    data: XOR<CheckDataUpdateManyMutationInput, CheckDataUncheckedUpdateManyInput>
    where?: CheckDataWhereInput
  }


  /**
   * CheckData upsert
   */
  export type CheckDataUpsertArgs = {
    /**
     * Select specific fields to fetch from the CheckData
     * 
    **/
    select?: CheckDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CheckDataInclude | null
    /**
     * The filter to search for the CheckData to update in case it exists.
     * 
    **/
    where: CheckDataWhereUniqueInput
    /**
     * In case the CheckData found by the `where` argument doesn't exist, create a new CheckData with this data.
     * 
    **/
    create: XOR<CheckDataCreateInput, CheckDataUncheckedCreateInput>
    /**
     * In case the CheckData was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CheckDataUpdateInput, CheckDataUncheckedUpdateInput>
  }


  /**
   * CheckData delete
   */
  export type CheckDataDeleteArgs = {
    /**
     * Select specific fields to fetch from the CheckData
     * 
    **/
    select?: CheckDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CheckDataInclude | null
    /**
     * Filter which CheckData to delete.
     * 
    **/
    where: CheckDataWhereUniqueInput
  }


  /**
   * CheckData deleteMany
   */
  export type CheckDataDeleteManyArgs = {
    where?: CheckDataWhereInput
  }


  /**
   * CheckData without action
   */
  export type CheckDataArgs = {
    /**
     * Select specific fields to fetch from the CheckData
     * 
    **/
    select?: CheckDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CheckDataInclude | null
  }



  /**
   * Model Client
   */


  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
    max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    complement: string | null
    postCode: string | null
    telephoneNumber: string | null
    distanceKm: string | null
    distanceTime: string | null
    establishmentId: string | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    complement: string | null
    postCode: string | null
    telephoneNumber: string | null
    distanceKm: string | null
    distanceTime: string | null
    establishmentId: string | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    address: number
    complement: number
    postCode: number
    telephoneNumber: number
    distanceKm: number
    distanceTime: number
    establishmentId: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    complement?: true
    postCode?: true
    telephoneNumber?: true
    distanceKm?: true
    distanceTime?: true
    establishmentId?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    complement?: true
    postCode?: true
    telephoneNumber?: true
    distanceKm?: true
    distanceTime?: true
    establishmentId?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    complement?: true
    postCode?: true
    telephoneNumber?: true
    distanceKm?: true
    distanceTime?: true
    establishmentId?: true
    _all?: true
  }

  export type ClientAggregateArgs = {
    /**
     * Filter which Client to aggregate.
     * 
    **/
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }


    
    
  export type ClientGroupByArgs = {
    where?: ClientWhereInput
    orderBy?: Enumerable<ClientOrderByInput>
    by: Array<ClientScalarFieldEnum>
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }


  export type ClientGroupByOutputType = {
    id: string
    name: string
    address: string
    complement: string | null
    postCode: string
    telephoneNumber: string
    distanceKm: string
    distanceTime: string
    establishmentId: string | null
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Promise<
    Array<
      PickArray<ClientGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ClientGroupByOutputType[P]> 
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      > 
    >


  export type ClientSelect = {
    id?: boolean
    name?: boolean
    address?: boolean
    complement?: boolean
    postCode?: boolean
    telephoneNumber?: boolean
    distanceKm?: boolean
    distanceTime?: boolean
    establishmentId?: boolean
    establishment?: boolean | EstablishmentArgs
  }

  export type ClientInclude = {
    establishment?: boolean | EstablishmentArgs
  }

  export type ClientGetPayload<
    S extends boolean | null | undefined | ClientArgs,
    U = keyof S
      > = S extends true
        ? Client
    : S extends undefined
    ? never
    : S extends ClientArgs | ClientFindManyArgs
    ?'include' extends U
    ? Client  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Client ?Client [P]
  : 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['select'][P]> | null : never
  } 
    : Client
  : Client


  type ClientCountArgs = Merge<
    Omit<ClientFindManyArgs, 'select' | 'include'> & {
      select?: ClientCountAggregateInputType | true
    }
  >

  export interface ClientDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClientFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Client'> extends True ? CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>> : CheckSelect<T, Prisma__ClientClient<Client | null >, Prisma__ClientClient<ClientGetPayload<T> | null >>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClientFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Client'> extends True ? CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>> : CheckSelect<T, Prisma__ClientClient<Client | null >, Prisma__ClientClient<ClientGetPayload<T> | null >>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientFindManyArgs>(
      args?: SelectSubset<T, ClientFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Client>>, PrismaPromise<Array<ClientGetPayload<T>>>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends ClientCreateArgs>(
      args: SelectSubset<T, ClientCreateArgs>
    ): CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>>

    /**
     * Create many Clients.
     *     @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     *     @example
     *     // Create many Clients
     *     const client = await prisma.client.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClientCreateManyArgs>(
      args?: SelectSubset<T, ClientCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends ClientDeleteArgs>(
      args: SelectSubset<T, ClientDeleteArgs>
    ): CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientUpdateArgs>(
      args: SelectSubset<T, ClientUpdateArgs>
    ): CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientDeleteManyArgs>(
      args?: SelectSubset<T, ClientDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientUpdateManyArgs>(
      args: SelectSubset<T, ClientUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends ClientUpsertArgs>(
      args: SelectSubset<T, ClientUpsertArgs>
    ): CheckSelect<T, Prisma__ClientClient<Client>, Prisma__ClientClient<ClientGetPayload<T>>>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClientClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    establishment<T extends EstablishmentArgs = {}>(args?: Subset<T, EstablishmentArgs>): CheckSelect<T, Prisma__EstablishmentClient<Establishment | null >, Prisma__EstablishmentClient<EstablishmentGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * Throw an Error if a Client can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Client to fetch.
     * 
    **/
    where: ClientWhereUniqueInput
  }


  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * Throw an Error if a Client can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Client to fetch.
     * 
    **/
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     * 
    **/
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     * 
    **/
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * Client findMany
   */
  export type ClientFindManyArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * Filter, which Clients to fetch.
     * 
    **/
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     * 
    **/
    orderBy?: Enumerable<ClientOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     * 
    **/
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClientScalarFieldEnum>
  }


  /**
   * Client create
   */
  export type ClientCreateArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * The data needed to create a Client.
     * 
    **/
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }


  /**
   * Client createMany
   */
  export type ClientCreateManyArgs = {
    data: Enumerable<ClientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Client update
   */
  export type ClientUpdateArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * The data needed to update a Client.
     * 
    **/
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     * 
    **/
    where: ClientWhereUniqueInput
  }


  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs = {
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    where?: ClientWhereInput
  }


  /**
   * Client upsert
   */
  export type ClientUpsertArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * The filter to search for the Client to update in case it exists.
     * 
    **/
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     * 
    **/
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }


  /**
   * Client delete
   */
  export type ClientDeleteArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
    /**
     * Filter which Client to delete.
     * 
    **/
    where: ClientWhereUniqueInput
  }


  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs = {
    where?: ClientWhereInput
  }


  /**
   * Client without action
   */
  export type ClientArgs = {
    /**
     * Select specific fields to fetch from the Client
     * 
    **/
    select?: ClientSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ClientInclude | null
  }



  /**
   * Model Employee
   */


  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
    max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    employeeId: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    employeeId: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    employeeId: number | null
    name: string | null
    role: string | null
    admissionDate: Date | null
    terminationDate: Date | null
    isActive: boolean | null
    establishmentId: string | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    employeeId: number | null
    name: string | null
    role: string | null
    admissionDate: Date | null
    terminationDate: Date | null
    isActive: boolean | null
    establishmentId: string | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    createdAt: number
    employeeId: number
    name: number
    role: number
    admissionDate: number
    terminationDate: number
    isActive: number
    establishmentId: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    employeeId?: true
  }

  export type EmployeeSumAggregateInputType = {
    employeeId?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    createdAt?: true
    employeeId?: true
    name?: true
    role?: true
    admissionDate?: true
    terminationDate?: true
    isActive?: true
    establishmentId?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    employeeId?: true
    name?: true
    role?: true
    admissionDate?: true
    terminationDate?: true
    isActive?: true
    establishmentId?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    createdAt?: true
    employeeId?: true
    name?: true
    role?: true
    admissionDate?: true
    terminationDate?: true
    isActive?: true
    establishmentId?: true
    _all?: true
  }

  export type EmployeeAggregateArgs = {
    /**
     * Filter which Employee to aggregate.
     * 
    **/
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     * 
    **/
    orderBy?: Enumerable<EmployeeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }


    
    
  export type EmployeeGroupByArgs = {
    where?: EmployeeWhereInput
    orderBy?: Enumerable<EmployeeOrderByInput>
    by: Array<EmployeeScalarFieldEnum>
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }


  export type EmployeeGroupByOutputType = {
    id: string
    createdAt: Date
    employeeId: number
    name: string
    role: string
    admissionDate: Date | null
    terminationDate: Date | null
    isActive: boolean
    establishmentId: string | null
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Promise<
    Array<
      PickArray<EmployeeGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]> 
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      > 
    >


  export type EmployeeSelect = {
    id?: boolean
    createdAt?: boolean
    employeeId?: boolean
    name?: boolean
    role?: boolean
    admissionDate?: boolean
    terminationDate?: boolean
    isActive?: boolean
    establishmentId?: boolean
    establishment?: boolean | EstablishmentArgs
    itemsOrdered?: boolean | OrderItemFindManyArgs
    orderPads?: boolean | OrderPadFindManyArgs
    tables?: boolean | TableDataFindManyArgs
    workHours?: boolean | WorkHourFindManyArgs
  }

  export type EmployeeInclude = {
    establishment?: boolean | EstablishmentArgs
    itemsOrdered?: boolean | OrderItemFindManyArgs
    orderPads?: boolean | OrderPadFindManyArgs
    tables?: boolean | TableDataFindManyArgs
    workHours?: boolean | WorkHourFindManyArgs
  }

  export type EmployeeGetPayload<
    S extends boolean | null | undefined | EmployeeArgs,
    U = keyof S
      > = S extends true
        ? Employee
    : S extends undefined
    ? never
    : S extends EmployeeArgs | EmployeeFindManyArgs
    ?'include' extends U
    ? Employee  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['include'][P]> | null :
        P extends 'itemsOrdered'
        ? Array < OrderItemGetPayload<S['include'][P]>>  :
        P extends 'orderPads'
        ? Array < OrderPadGetPayload<S['include'][P]>>  :
        P extends 'tables'
        ? Array < TableDataGetPayload<S['include'][P]>>  :
        P extends 'workHours'
        ? Array < WorkHourGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Employee ?Employee [P]
  : 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['select'][P]> | null :
        P extends 'itemsOrdered'
        ? Array < OrderItemGetPayload<S['select'][P]>>  :
        P extends 'orderPads'
        ? Array < OrderPadGetPayload<S['select'][P]>>  :
        P extends 'tables'
        ? Array < TableDataGetPayload<S['select'][P]>>  :
        P extends 'workHours'
        ? Array < WorkHourGetPayload<S['select'][P]>>  : never
  } 
    : Employee
  : Employee


  type EmployeeCountArgs = Merge<
    Omit<EmployeeFindManyArgs, 'select' | 'include'> & {
      select?: EmployeeCountAggregateInputType | true
    }
  >

  export interface EmployeeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmployeeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EmployeeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Employee'> extends True ? CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>> : CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmployeeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EmployeeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Employee'> extends True ? CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>> : CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmployeeFindManyArgs>(
      args?: SelectSubset<T, EmployeeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Employee>>, PrismaPromise<Array<EmployeeGetPayload<T>>>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
    **/
    create<T extends EmployeeCreateArgs>(
      args: SelectSubset<T, EmployeeCreateArgs>
    ): CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>>

    /**
     * Create many Employees.
     *     @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     *     @example
     *     // Create many Employees
     *     const employee = await prisma.employee.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmployeeCreateManyArgs>(
      args?: SelectSubset<T, EmployeeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
    **/
    delete<T extends EmployeeDeleteArgs>(
      args: SelectSubset<T, EmployeeDeleteArgs>
    ): CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmployeeUpdateArgs>(
      args: SelectSubset<T, EmployeeUpdateArgs>
    ): CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmployeeDeleteManyArgs>(
      args?: SelectSubset<T, EmployeeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmployeeUpdateManyArgs>(
      args: SelectSubset<T, EmployeeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
    **/
    upsert<T extends EmployeeUpsertArgs>(
      args: SelectSubset<T, EmployeeUpsertArgs>
    ): CheckSelect<T, Prisma__EmployeeClient<Employee>, Prisma__EmployeeClient<EmployeeGetPayload<T>>>

    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmployeeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    establishment<T extends EstablishmentArgs = {}>(args?: Subset<T, EstablishmentArgs>): CheckSelect<T, Prisma__EstablishmentClient<Establishment | null >, Prisma__EstablishmentClient<EstablishmentGetPayload<T> | null >>;

    itemsOrdered<T extends OrderItemFindManyArgs = {}>(args?: Subset<T, OrderItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderItem>>, PrismaPromise<Array<OrderItemGetPayload<T>>>>;

    orderPads<T extends OrderPadFindManyArgs = {}>(args?: Subset<T, OrderPadFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderPad>>, PrismaPromise<Array<OrderPadGetPayload<T>>>>;

    tables<T extends TableDataFindManyArgs = {}>(args?: Subset<T, TableDataFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TableData>>, PrismaPromise<Array<TableDataGetPayload<T>>>>;

    workHours<T extends WorkHourFindManyArgs = {}>(args?: Subset<T, WorkHourFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkHour>>, PrismaPromise<Array<WorkHourGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * Throw an Error if a Employee can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Employee to fetch.
     * 
    **/
    where: EmployeeWhereUniqueInput
  }


  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * Throw an Error if a Employee can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Employee to fetch.
     * 
    **/
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     * 
    **/
    orderBy?: Enumerable<EmployeeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     * 
    **/
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     * 
    **/
    distinct?: Enumerable<EmployeeScalarFieldEnum>
  }


  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * Filter, which Employees to fetch.
     * 
    **/
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     * 
    **/
    orderBy?: Enumerable<EmployeeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     * 
    **/
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EmployeeScalarFieldEnum>
  }


  /**
   * Employee create
   */
  export type EmployeeCreateArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * The data needed to create a Employee.
     * 
    **/
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }


  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs = {
    data: Enumerable<EmployeeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Employee update
   */
  export type EmployeeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * The data needed to update a Employee.
     * 
    **/
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     * 
    **/
    where: EmployeeWhereUniqueInput
  }


  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs = {
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    where?: EmployeeWhereInput
  }


  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * The filter to search for the Employee to update in case it exists.
     * 
    **/
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     * 
    **/
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }


  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
    /**
     * Filter which Employee to delete.
     * 
    **/
    where: EmployeeWhereUniqueInput
  }


  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs = {
    where?: EmployeeWhereInput
  }


  /**
   * Employee without action
   */
  export type EmployeeArgs = {
    /**
     * Select specific fields to fetch from the Employee
     * 
    **/
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EmployeeInclude | null
  }



  /**
   * Model Establishment
   */


  export type AggregateEstablishment = {
    _count: EstablishmentCountAggregateOutputType | null
    count: EstablishmentCountAggregateOutputType | null
    _avg: EstablishmentAvgAggregateOutputType | null
    avg: EstablishmentAvgAggregateOutputType | null
    _sum: EstablishmentSumAggregateOutputType | null
    sum: EstablishmentSumAggregateOutputType | null
    _min: EstablishmentMinAggregateOutputType | null
    min: EstablishmentMinAggregateOutputType | null
    _max: EstablishmentMaxAggregateOutputType | null
    max: EstablishmentMaxAggregateOutputType | null
  }

  export type EstablishmentAvgAggregateOutputType = {
    lat: number | null
    long: number | null
    valueInCashRegister: number | null
    maximumInCashRegister: number | null
    incomeMaxReference: number | null
    totalInvoices: number | null
  }

  export type EstablishmentSumAggregateOutputType = {
    lat: number | null
    long: number | null
    valueInCashRegister: number | null
    maximumInCashRegister: number | null
    incomeMaxReference: number | null
    totalInvoices: number | null
  }

  export type EstablishmentMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    name: string | null
    lat: number | null
    long: number | null
    restaurantId: string | null
    valueInCashRegister: number | null
    maximumInCashRegister: number | null
    incomeMaxReference: number | null
    isOpen: boolean | null
    totalInvoices: number | null
  }

  export type EstablishmentMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    name: string | null
    lat: number | null
    long: number | null
    restaurantId: string | null
    valueInCashRegister: number | null
    maximumInCashRegister: number | null
    incomeMaxReference: number | null
    isOpen: boolean | null
    totalInvoices: number | null
  }

  export type EstablishmentCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    lat: number
    long: number
    restaurantId: number
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: number
    totalInvoices: number
    discountReasons: number
    _all: number
  }


  export type EstablishmentAvgAggregateInputType = {
    lat?: true
    long?: true
    valueInCashRegister?: true
    maximumInCashRegister?: true
    incomeMaxReference?: true
    totalInvoices?: true
  }

  export type EstablishmentSumAggregateInputType = {
    lat?: true
    long?: true
    valueInCashRegister?: true
    maximumInCashRegister?: true
    incomeMaxReference?: true
    totalInvoices?: true
  }

  export type EstablishmentMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    lat?: true
    long?: true
    restaurantId?: true
    valueInCashRegister?: true
    maximumInCashRegister?: true
    incomeMaxReference?: true
    isOpen?: true
    totalInvoices?: true
  }

  export type EstablishmentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    lat?: true
    long?: true
    restaurantId?: true
    valueInCashRegister?: true
    maximumInCashRegister?: true
    incomeMaxReference?: true
    isOpen?: true
    totalInvoices?: true
  }

  export type EstablishmentCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    lat?: true
    long?: true
    restaurantId?: true
    valueInCashRegister?: true
    maximumInCashRegister?: true
    incomeMaxReference?: true
    isOpen?: true
    totalInvoices?: true
    discountReasons?: true
    _all?: true
  }

  export type EstablishmentAggregateArgs = {
    /**
     * Filter which Establishment to aggregate.
     * 
    **/
    where?: EstablishmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Establishments to fetch.
     * 
    **/
    orderBy?: Enumerable<EstablishmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EstablishmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Establishments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Establishments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Establishments
    **/
    _count?: true | EstablishmentCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | EstablishmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstablishmentAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: EstablishmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstablishmentSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: EstablishmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstablishmentMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: EstablishmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstablishmentMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: EstablishmentMaxAggregateInputType
  }

  export type GetEstablishmentAggregateType<T extends EstablishmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEstablishment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstablishment[P]>
      : GetScalarType<T[P], AggregateEstablishment[P]>
  }


    
    
  export type EstablishmentGroupByArgs = {
    where?: EstablishmentWhereInput
    orderBy?: Enumerable<EstablishmentOrderByInput>
    by: Array<EstablishmentScalarFieldEnum>
    having?: EstablishmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstablishmentCountAggregateInputType | true
    _avg?: EstablishmentAvgAggregateInputType
    _sum?: EstablishmentSumAggregateInputType
    _min?: EstablishmentMinAggregateInputType
    _max?: EstablishmentMaxAggregateInputType
  }


  export type EstablishmentGroupByOutputType = {
    id: string
    createdAt: Date
    name: string
    lat: number
    long: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices: number | null
    discountReasons: string[]
    _count: EstablishmentCountAggregateOutputType | null
    _avg: EstablishmentAvgAggregateOutputType | null
    _sum: EstablishmentSumAggregateOutputType | null
    _min: EstablishmentMinAggregateOutputType | null
    _max: EstablishmentMaxAggregateOutputType | null
  }

  type GetEstablishmentGroupByPayload<T extends EstablishmentGroupByArgs> = Promise<
    Array<
      PickArray<EstablishmentGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof EstablishmentGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], EstablishmentGroupByOutputType[P]> 
            : GetScalarType<T[P], EstablishmentGroupByOutputType[P]>
        }
      > 
    >


  export type EstablishmentSelect = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    lat?: boolean
    long?: boolean
    restaurantId?: boolean
    valueInCashRegister?: boolean
    maximumInCashRegister?: boolean
    incomeMaxReference?: boolean
    isOpen?: boolean
    totalInvoices?: boolean
    discountReasons?: boolean
    clients?: boolean | ClientFindManyArgs
    employees?: boolean | EmployeeFindManyArgs
    expenses?: boolean | ExpenseFindManyArgs
    items?: boolean | ItemFindManyArgs
    permissions?: boolean | PermissionFindManyArgs
    tables?: boolean | TableFindManyArgs
    workingDays?: boolean | WorkDayFindManyArgs
  }

  export type EstablishmentInclude = {
    clients?: boolean | ClientFindManyArgs
    employees?: boolean | EmployeeFindManyArgs
    expenses?: boolean | ExpenseFindManyArgs
    items?: boolean | ItemFindManyArgs
    permissions?: boolean | PermissionFindManyArgs
    tables?: boolean | TableFindManyArgs
    workingDays?: boolean | WorkDayFindManyArgs
  }

  export type EstablishmentGetPayload<
    S extends boolean | null | undefined | EstablishmentArgs,
    U = keyof S
      > = S extends true
        ? Establishment
    : S extends undefined
    ? never
    : S extends EstablishmentArgs | EstablishmentFindManyArgs
    ?'include' extends U
    ? Establishment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'clients'
        ? Array < ClientGetPayload<S['include'][P]>>  :
        P extends 'employees'
        ? Array < EmployeeGetPayload<S['include'][P]>>  :
        P extends 'expenses'
        ? Array < ExpenseGetPayload<S['include'][P]>>  :
        P extends 'items'
        ? Array < ItemGetPayload<S['include'][P]>>  :
        P extends 'permissions'
        ? Array < PermissionGetPayload<S['include'][P]>>  :
        P extends 'tables'
        ? Array < TableGetPayload<S['include'][P]>>  :
        P extends 'workingDays'
        ? Array < WorkDayGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Establishment ?Establishment [P]
  : 
          P extends 'clients'
        ? Array < ClientGetPayload<S['select'][P]>>  :
        P extends 'employees'
        ? Array < EmployeeGetPayload<S['select'][P]>>  :
        P extends 'expenses'
        ? Array < ExpenseGetPayload<S['select'][P]>>  :
        P extends 'items'
        ? Array < ItemGetPayload<S['select'][P]>>  :
        P extends 'permissions'
        ? Array < PermissionGetPayload<S['select'][P]>>  :
        P extends 'tables'
        ? Array < TableGetPayload<S['select'][P]>>  :
        P extends 'workingDays'
        ? Array < WorkDayGetPayload<S['select'][P]>>  : never
  } 
    : Establishment
  : Establishment


  type EstablishmentCountArgs = Merge<
    Omit<EstablishmentFindManyArgs, 'select' | 'include'> & {
      select?: EstablishmentCountAggregateInputType | true
    }
  >

  export interface EstablishmentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Establishment that matches the filter.
     * @param {EstablishmentFindUniqueArgs} args - Arguments to find a Establishment
     * @example
     * // Get one Establishment
     * const establishment = await prisma.establishment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EstablishmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EstablishmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Establishment'> extends True ? CheckSelect<T, Prisma__EstablishmentClient<Establishment>, Prisma__EstablishmentClient<EstablishmentGetPayload<T>>> : CheckSelect<T, Prisma__EstablishmentClient<Establishment | null >, Prisma__EstablishmentClient<EstablishmentGetPayload<T> | null >>

    /**
     * Find the first Establishment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstablishmentFindFirstArgs} args - Arguments to find a Establishment
     * @example
     * // Get one Establishment
     * const establishment = await prisma.establishment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EstablishmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EstablishmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Establishment'> extends True ? CheckSelect<T, Prisma__EstablishmentClient<Establishment>, Prisma__EstablishmentClient<EstablishmentGetPayload<T>>> : CheckSelect<T, Prisma__EstablishmentClient<Establishment | null >, Prisma__EstablishmentClient<EstablishmentGetPayload<T> | null >>

    /**
     * Find zero or more Establishments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstablishmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Establishments
     * const establishments = await prisma.establishment.findMany()
     * 
     * // Get first 10 Establishments
     * const establishments = await prisma.establishment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const establishmentWithIdOnly = await prisma.establishment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EstablishmentFindManyArgs>(
      args?: SelectSubset<T, EstablishmentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Establishment>>, PrismaPromise<Array<EstablishmentGetPayload<T>>>>

    /**
     * Create a Establishment.
     * @param {EstablishmentCreateArgs} args - Arguments to create a Establishment.
     * @example
     * // Create one Establishment
     * const Establishment = await prisma.establishment.create({
     *   data: {
     *     // ... data to create a Establishment
     *   }
     * })
     * 
    **/
    create<T extends EstablishmentCreateArgs>(
      args: SelectSubset<T, EstablishmentCreateArgs>
    ): CheckSelect<T, Prisma__EstablishmentClient<Establishment>, Prisma__EstablishmentClient<EstablishmentGetPayload<T>>>

    /**
     * Create many Establishments.
     *     @param {EstablishmentCreateManyArgs} args - Arguments to create many Establishments.
     *     @example
     *     // Create many Establishments
     *     const establishment = await prisma.establishment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EstablishmentCreateManyArgs>(
      args?: SelectSubset<T, EstablishmentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Establishment.
     * @param {EstablishmentDeleteArgs} args - Arguments to delete one Establishment.
     * @example
     * // Delete one Establishment
     * const Establishment = await prisma.establishment.delete({
     *   where: {
     *     // ... filter to delete one Establishment
     *   }
     * })
     * 
    **/
    delete<T extends EstablishmentDeleteArgs>(
      args: SelectSubset<T, EstablishmentDeleteArgs>
    ): CheckSelect<T, Prisma__EstablishmentClient<Establishment>, Prisma__EstablishmentClient<EstablishmentGetPayload<T>>>

    /**
     * Update one Establishment.
     * @param {EstablishmentUpdateArgs} args - Arguments to update one Establishment.
     * @example
     * // Update one Establishment
     * const establishment = await prisma.establishment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EstablishmentUpdateArgs>(
      args: SelectSubset<T, EstablishmentUpdateArgs>
    ): CheckSelect<T, Prisma__EstablishmentClient<Establishment>, Prisma__EstablishmentClient<EstablishmentGetPayload<T>>>

    /**
     * Delete zero or more Establishments.
     * @param {EstablishmentDeleteManyArgs} args - Arguments to filter Establishments to delete.
     * @example
     * // Delete a few Establishments
     * const { count } = await prisma.establishment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EstablishmentDeleteManyArgs>(
      args?: SelectSubset<T, EstablishmentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Establishments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstablishmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Establishments
     * const establishment = await prisma.establishment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EstablishmentUpdateManyArgs>(
      args: SelectSubset<T, EstablishmentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Establishment.
     * @param {EstablishmentUpsertArgs} args - Arguments to update or create a Establishment.
     * @example
     * // Update or create a Establishment
     * const establishment = await prisma.establishment.upsert({
     *   create: {
     *     // ... data to create a Establishment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Establishment we want to update
     *   }
     * })
    **/
    upsert<T extends EstablishmentUpsertArgs>(
      args: SelectSubset<T, EstablishmentUpsertArgs>
    ): CheckSelect<T, Prisma__EstablishmentClient<Establishment>, Prisma__EstablishmentClient<EstablishmentGetPayload<T>>>

    /**
     * Count the number of Establishments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstablishmentCountArgs} args - Arguments to filter Establishments to count.
     * @example
     * // Count the number of Establishments
     * const count = await prisma.establishment.count({
     *   where: {
     *     // ... the filter for the Establishments we want to count
     *   }
     * })
    **/
    count<T extends EstablishmentCountArgs>(
      args?: Subset<T, EstablishmentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstablishmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Establishment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstablishmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstablishmentAggregateArgs>(args: Subset<T, EstablishmentAggregateArgs>): PrismaPromise<GetEstablishmentAggregateType<T>>

    /**
     * Group by Establishment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstablishmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EstablishmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EstablishmentGroupByArgs['orderBy'] }
        : { orderBy?: EstablishmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EstablishmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstablishmentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Establishment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EstablishmentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    clients<T extends ClientFindManyArgs = {}>(args?: Subset<T, ClientFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Client>>, PrismaPromise<Array<ClientGetPayload<T>>>>;

    employees<T extends EmployeeFindManyArgs = {}>(args?: Subset<T, EmployeeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Employee>>, PrismaPromise<Array<EmployeeGetPayload<T>>>>;

    expenses<T extends ExpenseFindManyArgs = {}>(args?: Subset<T, ExpenseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Expense>>, PrismaPromise<Array<ExpenseGetPayload<T>>>>;

    items<T extends ItemFindManyArgs = {}>(args?: Subset<T, ItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Item>>, PrismaPromise<Array<ItemGetPayload<T>>>>;

    permissions<T extends PermissionFindManyArgs = {}>(args?: Subset<T, PermissionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Permission>>, PrismaPromise<Array<PermissionGetPayload<T>>>>;

    tables<T extends TableFindManyArgs = {}>(args?: Subset<T, TableFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Table>>, PrismaPromise<Array<TableGetPayload<T>>>>;

    workingDays<T extends WorkDayFindManyArgs = {}>(args?: Subset<T, WorkDayFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkDay>>, PrismaPromise<Array<WorkDayGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Establishment findUnique
   */
  export type EstablishmentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Establishment
     * 
    **/
    select?: EstablishmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstablishmentInclude | null
    /**
     * Throw an Error if a Establishment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Establishment to fetch.
     * 
    **/
    where: EstablishmentWhereUniqueInput
  }


  /**
   * Establishment findFirst
   */
  export type EstablishmentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Establishment
     * 
    **/
    select?: EstablishmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstablishmentInclude | null
    /**
     * Throw an Error if a Establishment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Establishment to fetch.
     * 
    **/
    where?: EstablishmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Establishments to fetch.
     * 
    **/
    orderBy?: Enumerable<EstablishmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Establishments.
     * 
    **/
    cursor?: EstablishmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Establishments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Establishments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Establishments.
     * 
    **/
    distinct?: Enumerable<EstablishmentScalarFieldEnum>
  }


  /**
   * Establishment findMany
   */
  export type EstablishmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Establishment
     * 
    **/
    select?: EstablishmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstablishmentInclude | null
    /**
     * Filter, which Establishments to fetch.
     * 
    **/
    where?: EstablishmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Establishments to fetch.
     * 
    **/
    orderBy?: Enumerable<EstablishmentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Establishments.
     * 
    **/
    cursor?: EstablishmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Establishments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Establishments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EstablishmentScalarFieldEnum>
  }


  /**
   * Establishment create
   */
  export type EstablishmentCreateArgs = {
    /**
     * Select specific fields to fetch from the Establishment
     * 
    **/
    select?: EstablishmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstablishmentInclude | null
    /**
     * The data needed to create a Establishment.
     * 
    **/
    data: XOR<EstablishmentCreateInput, EstablishmentUncheckedCreateInput>
  }


  /**
   * Establishment createMany
   */
  export type EstablishmentCreateManyArgs = {
    data: Enumerable<EstablishmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Establishment update
   */
  export type EstablishmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Establishment
     * 
    **/
    select?: EstablishmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstablishmentInclude | null
    /**
     * The data needed to update a Establishment.
     * 
    **/
    data: XOR<EstablishmentUpdateInput, EstablishmentUncheckedUpdateInput>
    /**
     * Choose, which Establishment to update.
     * 
    **/
    where: EstablishmentWhereUniqueInput
  }


  /**
   * Establishment updateMany
   */
  export type EstablishmentUpdateManyArgs = {
    data: XOR<EstablishmentUpdateManyMutationInput, EstablishmentUncheckedUpdateManyInput>
    where?: EstablishmentWhereInput
  }


  /**
   * Establishment upsert
   */
  export type EstablishmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Establishment
     * 
    **/
    select?: EstablishmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstablishmentInclude | null
    /**
     * The filter to search for the Establishment to update in case it exists.
     * 
    **/
    where: EstablishmentWhereUniqueInput
    /**
     * In case the Establishment found by the `where` argument doesn't exist, create a new Establishment with this data.
     * 
    **/
    create: XOR<EstablishmentCreateInput, EstablishmentUncheckedCreateInput>
    /**
     * In case the Establishment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EstablishmentUpdateInput, EstablishmentUncheckedUpdateInput>
  }


  /**
   * Establishment delete
   */
  export type EstablishmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Establishment
     * 
    **/
    select?: EstablishmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstablishmentInclude | null
    /**
     * Filter which Establishment to delete.
     * 
    **/
    where: EstablishmentWhereUniqueInput
  }


  /**
   * Establishment deleteMany
   */
  export type EstablishmentDeleteManyArgs = {
    where?: EstablishmentWhereInput
  }


  /**
   * Establishment without action
   */
  export type EstablishmentArgs = {
    /**
     * Select specific fields to fetch from the Establishment
     * 
    **/
    select?: EstablishmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EstablishmentInclude | null
  }



  /**
   * Model Expense
   */


  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    count: ExpenseCountAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
    max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    NFE: boolean | null
    NFEReference: string | null
    date: Date | null
    executionDate: Date | null
    establishmentId: string | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    NFE: boolean | null
    NFEReference: string | null
    date: Date | null
    executionDate: Date | null
    establishmentId: string | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    createdAt: number
    NFE: number
    NFEReference: number
    date: number
    executionDate: number
    establishmentId: number
    _all: number
  }


  export type ExpenseMinAggregateInputType = {
    id?: true
    createdAt?: true
    NFE?: true
    NFEReference?: true
    date?: true
    executionDate?: true
    establishmentId?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    createdAt?: true
    NFE?: true
    NFEReference?: true
    date?: true
    executionDate?: true
    establishmentId?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    createdAt?: true
    NFE?: true
    NFEReference?: true
    date?: true
    executionDate?: true
    establishmentId?: true
    _all?: true
  }

  export type ExpenseAggregateArgs = {
    /**
     * Filter which Expense to aggregate.
     * 
    **/
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     * 
    **/
    orderBy?: Enumerable<ExpenseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }


    
    
  export type ExpenseGroupByArgs = {
    where?: ExpenseWhereInput
    orderBy?: Enumerable<ExpenseOrderByInput>
    by: Array<ExpenseScalarFieldEnum>
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }


  export type ExpenseGroupByOutputType = {
    id: string
    createdAt: Date
    NFE: boolean
    NFEReference: string | null
    date: Date
    executionDate: Date
    establishmentId: string | null
    _count: ExpenseCountAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Promise<
    Array<
      PickArray<ExpenseGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]> 
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      > 
    >


  export type ExpenseSelect = {
    id?: boolean
    createdAt?: boolean
    NFE?: boolean
    NFEReference?: boolean
    date?: boolean
    executionDate?: boolean
    establishmentId?: boolean
    establishment?: boolean | EstablishmentArgs
    payment?: boolean | PaymentArgs
    expenseItems?: boolean | ExpenseItemFindManyArgs
  }

  export type ExpenseInclude = {
    establishment?: boolean | EstablishmentArgs
    payment?: boolean | PaymentArgs
    expenseItems?: boolean | ExpenseItemFindManyArgs
  }

  export type ExpenseGetPayload<
    S extends boolean | null | undefined | ExpenseArgs,
    U = keyof S
      > = S extends true
        ? Expense
    : S extends undefined
    ? never
    : S extends ExpenseArgs | ExpenseFindManyArgs
    ?'include' extends U
    ? Expense  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['include'][P]> | null :
        P extends 'payment'
        ? PaymentGetPayload<S['include'][P]> | null :
        P extends 'expenseItems'
        ? Array < ExpenseItemGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Expense ?Expense [P]
  : 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['select'][P]> | null :
        P extends 'payment'
        ? PaymentGetPayload<S['select'][P]> | null :
        P extends 'expenseItems'
        ? Array < ExpenseItemGetPayload<S['select'][P]>>  : never
  } 
    : Expense
  : Expense


  type ExpenseCountArgs = Merge<
    Omit<ExpenseFindManyArgs, 'select' | 'include'> & {
      select?: ExpenseCountAggregateInputType | true
    }
  >

  export interface ExpenseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExpenseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExpenseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Expense'> extends True ? CheckSelect<T, Prisma__ExpenseClient<Expense>, Prisma__ExpenseClient<ExpenseGetPayload<T>>> : CheckSelect<T, Prisma__ExpenseClient<Expense | null >, Prisma__ExpenseClient<ExpenseGetPayload<T> | null >>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExpenseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExpenseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Expense'> extends True ? CheckSelect<T, Prisma__ExpenseClient<Expense>, Prisma__ExpenseClient<ExpenseGetPayload<T>>> : CheckSelect<T, Prisma__ExpenseClient<Expense | null >, Prisma__ExpenseClient<ExpenseGetPayload<T> | null >>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExpenseFindManyArgs>(
      args?: SelectSubset<T, ExpenseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Expense>>, PrismaPromise<Array<ExpenseGetPayload<T>>>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
    **/
    create<T extends ExpenseCreateArgs>(
      args: SelectSubset<T, ExpenseCreateArgs>
    ): CheckSelect<T, Prisma__ExpenseClient<Expense>, Prisma__ExpenseClient<ExpenseGetPayload<T>>>

    /**
     * Create many Expenses.
     *     @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     *     @example
     *     // Create many Expenses
     *     const expense = await prisma.expense.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExpenseCreateManyArgs>(
      args?: SelectSubset<T, ExpenseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
    **/
    delete<T extends ExpenseDeleteArgs>(
      args: SelectSubset<T, ExpenseDeleteArgs>
    ): CheckSelect<T, Prisma__ExpenseClient<Expense>, Prisma__ExpenseClient<ExpenseGetPayload<T>>>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExpenseUpdateArgs>(
      args: SelectSubset<T, ExpenseUpdateArgs>
    ): CheckSelect<T, Prisma__ExpenseClient<Expense>, Prisma__ExpenseClient<ExpenseGetPayload<T>>>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExpenseDeleteManyArgs>(
      args?: SelectSubset<T, ExpenseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExpenseUpdateManyArgs>(
      args: SelectSubset<T, ExpenseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
    **/
    upsert<T extends ExpenseUpsertArgs>(
      args: SelectSubset<T, ExpenseUpsertArgs>
    ): CheckSelect<T, Prisma__ExpenseClient<Expense>, Prisma__ExpenseClient<ExpenseGetPayload<T>>>

    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExpenseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    establishment<T extends EstablishmentArgs = {}>(args?: Subset<T, EstablishmentArgs>): CheckSelect<T, Prisma__EstablishmentClient<Establishment | null >, Prisma__EstablishmentClient<EstablishmentGetPayload<T> | null >>;

    payment<T extends PaymentArgs = {}>(args?: Subset<T, PaymentArgs>): CheckSelect<T, Prisma__PaymentClient<Payment | null >, Prisma__PaymentClient<PaymentGetPayload<T> | null >>;

    expenseItems<T extends ExpenseItemFindManyArgs = {}>(args?: Subset<T, ExpenseItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ExpenseItem>>, PrismaPromise<Array<ExpenseItemGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Expense
     * 
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseInclude | null
    /**
     * Throw an Error if a Expense can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Expense to fetch.
     * 
    **/
    where: ExpenseWhereUniqueInput
  }


  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Expense
     * 
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseInclude | null
    /**
     * Throw an Error if a Expense can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Expense to fetch.
     * 
    **/
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     * 
    **/
    orderBy?: Enumerable<ExpenseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     * 
    **/
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     * 
    **/
    distinct?: Enumerable<ExpenseScalarFieldEnum>
  }


  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs = {
    /**
     * Select specific fields to fetch from the Expense
     * 
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseInclude | null
    /**
     * Filter, which Expenses to fetch.
     * 
    **/
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     * 
    **/
    orderBy?: Enumerable<ExpenseOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     * 
    **/
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExpenseScalarFieldEnum>
  }


  /**
   * Expense create
   */
  export type ExpenseCreateArgs = {
    /**
     * Select specific fields to fetch from the Expense
     * 
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseInclude | null
    /**
     * The data needed to create a Expense.
     * 
    **/
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }


  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs = {
    data: Enumerable<ExpenseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Expense update
   */
  export type ExpenseUpdateArgs = {
    /**
     * Select specific fields to fetch from the Expense
     * 
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseInclude | null
    /**
     * The data needed to update a Expense.
     * 
    **/
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     * 
    **/
    where: ExpenseWhereUniqueInput
  }


  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs = {
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    where?: ExpenseWhereInput
  }


  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs = {
    /**
     * Select specific fields to fetch from the Expense
     * 
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseInclude | null
    /**
     * The filter to search for the Expense to update in case it exists.
     * 
    **/
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     * 
    **/
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }


  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs = {
    /**
     * Select specific fields to fetch from the Expense
     * 
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseInclude | null
    /**
     * Filter which Expense to delete.
     * 
    **/
    where: ExpenseWhereUniqueInput
  }


  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs = {
    where?: ExpenseWhereInput
  }


  /**
   * Expense without action
   */
  export type ExpenseArgs = {
    /**
     * Select specific fields to fetch from the Expense
     * 
    **/
    select?: ExpenseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseInclude | null
  }



  /**
   * Model ExpenseItem
   */


  export type AggregateExpenseItem = {
    _count: ExpenseItemCountAggregateOutputType | null
    count: ExpenseItemCountAggregateOutputType | null
    _avg: ExpenseItemAvgAggregateOutputType | null
    avg: ExpenseItemAvgAggregateOutputType | null
    _sum: ExpenseItemSumAggregateOutputType | null
    sum: ExpenseItemSumAggregateOutputType | null
    _min: ExpenseItemMinAggregateOutputType | null
    min: ExpenseItemMinAggregateOutputType | null
    _max: ExpenseItemMaxAggregateOutputType | null
    max: ExpenseItemMaxAggregateOutputType | null
  }

  export type ExpenseItemAvgAggregateOutputType = {
    quantity: number | null
    value: number | null
  }

  export type ExpenseItemSumAggregateOutputType = {
    quantity: number | null
    value: number | null
  }

  export type ExpenseItemMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    quantity: number | null
    value: number | null
    details: string | null
    productId: string | null
  }

  export type ExpenseItemMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    quantity: number | null
    value: number | null
    details: string | null
    productId: string | null
  }

  export type ExpenseItemCountAggregateOutputType = {
    id: number
    createdAt: number
    quantity: number
    value: number
    details: number
    productId: number
    _all: number
  }


  export type ExpenseItemAvgAggregateInputType = {
    quantity?: true
    value?: true
  }

  export type ExpenseItemSumAggregateInputType = {
    quantity?: true
    value?: true
  }

  export type ExpenseItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    quantity?: true
    value?: true
    details?: true
    productId?: true
  }

  export type ExpenseItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    quantity?: true
    value?: true
    details?: true
    productId?: true
  }

  export type ExpenseItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    quantity?: true
    value?: true
    details?: true
    productId?: true
    _all?: true
  }

  export type ExpenseItemAggregateArgs = {
    /**
     * Filter which ExpenseItem to aggregate.
     * 
    **/
    where?: ExpenseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseItems to fetch.
     * 
    **/
    orderBy?: Enumerable<ExpenseItemOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ExpenseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseItems
    **/
    _count?: true | ExpenseItemCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ExpenseItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseItemAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ExpenseItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseItemSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ExpenseItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseItemMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ExpenseItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseItemMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ExpenseItemMaxAggregateInputType
  }

  export type GetExpenseItemAggregateType<T extends ExpenseItemAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseItem[P]>
      : GetScalarType<T[P], AggregateExpenseItem[P]>
  }


    
    
  export type ExpenseItemGroupByArgs = {
    where?: ExpenseItemWhereInput
    orderBy?: Enumerable<ExpenseItemOrderByInput>
    by: Array<ExpenseItemScalarFieldEnum>
    having?: ExpenseItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseItemCountAggregateInputType | true
    _avg?: ExpenseItemAvgAggregateInputType
    _sum?: ExpenseItemSumAggregateInputType
    _min?: ExpenseItemMinAggregateInputType
    _max?: ExpenseItemMaxAggregateInputType
  }


  export type ExpenseItemGroupByOutputType = {
    id: string
    createdAt: Date
    quantity: number
    value: number
    details: string | null
    productId: string | null
    _count: ExpenseItemCountAggregateOutputType | null
    _avg: ExpenseItemAvgAggregateOutputType | null
    _sum: ExpenseItemSumAggregateOutputType | null
    _min: ExpenseItemMinAggregateOutputType | null
    _max: ExpenseItemMaxAggregateOutputType | null
  }

  type GetExpenseItemGroupByPayload<T extends ExpenseItemGroupByArgs> = Promise<
    Array<
      PickArray<ExpenseItemGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ExpenseItemGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ExpenseItemGroupByOutputType[P]> 
            : GetScalarType<T[P], ExpenseItemGroupByOutputType[P]>
        }
      > 
    >


  export type ExpenseItemSelect = {
    id?: boolean
    createdAt?: boolean
    quantity?: boolean
    value?: boolean
    details?: boolean
    productId?: boolean
    product?: boolean | ProductArgs
    Expense?: boolean | ExpenseFindManyArgs
  }

  export type ExpenseItemInclude = {
    product?: boolean | ProductArgs
    Expense?: boolean | ExpenseFindManyArgs
  }

  export type ExpenseItemGetPayload<
    S extends boolean | null | undefined | ExpenseItemArgs,
    U = keyof S
      > = S extends true
        ? ExpenseItem
    : S extends undefined
    ? never
    : S extends ExpenseItemArgs | ExpenseItemFindManyArgs
    ?'include' extends U
    ? ExpenseItem  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'product'
        ? ProductGetPayload<S['include'][P]> | null :
        P extends 'Expense'
        ? Array < ExpenseGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ExpenseItem ?ExpenseItem [P]
  : 
          P extends 'product'
        ? ProductGetPayload<S['select'][P]> | null :
        P extends 'Expense'
        ? Array < ExpenseGetPayload<S['select'][P]>>  : never
  } 
    : ExpenseItem
  : ExpenseItem


  type ExpenseItemCountArgs = Merge<
    Omit<ExpenseItemFindManyArgs, 'select' | 'include'> & {
      select?: ExpenseItemCountAggregateInputType | true
    }
  >

  export interface ExpenseItemDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ExpenseItem that matches the filter.
     * @param {ExpenseItemFindUniqueArgs} args - Arguments to find a ExpenseItem
     * @example
     * // Get one ExpenseItem
     * const expenseItem = await prisma.expenseItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExpenseItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExpenseItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ExpenseItem'> extends True ? CheckSelect<T, Prisma__ExpenseItemClient<ExpenseItem>, Prisma__ExpenseItemClient<ExpenseItemGetPayload<T>>> : CheckSelect<T, Prisma__ExpenseItemClient<ExpenseItem | null >, Prisma__ExpenseItemClient<ExpenseItemGetPayload<T> | null >>

    /**
     * Find the first ExpenseItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseItemFindFirstArgs} args - Arguments to find a ExpenseItem
     * @example
     * // Get one ExpenseItem
     * const expenseItem = await prisma.expenseItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExpenseItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExpenseItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ExpenseItem'> extends True ? CheckSelect<T, Prisma__ExpenseItemClient<ExpenseItem>, Prisma__ExpenseItemClient<ExpenseItemGetPayload<T>>> : CheckSelect<T, Prisma__ExpenseItemClient<ExpenseItem | null >, Prisma__ExpenseItemClient<ExpenseItemGetPayload<T> | null >>

    /**
     * Find zero or more ExpenseItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseItems
     * const expenseItems = await prisma.expenseItem.findMany()
     * 
     * // Get first 10 ExpenseItems
     * const expenseItems = await prisma.expenseItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseItemWithIdOnly = await prisma.expenseItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExpenseItemFindManyArgs>(
      args?: SelectSubset<T, ExpenseItemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ExpenseItem>>, PrismaPromise<Array<ExpenseItemGetPayload<T>>>>

    /**
     * Create a ExpenseItem.
     * @param {ExpenseItemCreateArgs} args - Arguments to create a ExpenseItem.
     * @example
     * // Create one ExpenseItem
     * const ExpenseItem = await prisma.expenseItem.create({
     *   data: {
     *     // ... data to create a ExpenseItem
     *   }
     * })
     * 
    **/
    create<T extends ExpenseItemCreateArgs>(
      args: SelectSubset<T, ExpenseItemCreateArgs>
    ): CheckSelect<T, Prisma__ExpenseItemClient<ExpenseItem>, Prisma__ExpenseItemClient<ExpenseItemGetPayload<T>>>

    /**
     * Create many ExpenseItems.
     *     @param {ExpenseItemCreateManyArgs} args - Arguments to create many ExpenseItems.
     *     @example
     *     // Create many ExpenseItems
     *     const expenseItem = await prisma.expenseItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExpenseItemCreateManyArgs>(
      args?: SelectSubset<T, ExpenseItemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ExpenseItem.
     * @param {ExpenseItemDeleteArgs} args - Arguments to delete one ExpenseItem.
     * @example
     * // Delete one ExpenseItem
     * const ExpenseItem = await prisma.expenseItem.delete({
     *   where: {
     *     // ... filter to delete one ExpenseItem
     *   }
     * })
     * 
    **/
    delete<T extends ExpenseItemDeleteArgs>(
      args: SelectSubset<T, ExpenseItemDeleteArgs>
    ): CheckSelect<T, Prisma__ExpenseItemClient<ExpenseItem>, Prisma__ExpenseItemClient<ExpenseItemGetPayload<T>>>

    /**
     * Update one ExpenseItem.
     * @param {ExpenseItemUpdateArgs} args - Arguments to update one ExpenseItem.
     * @example
     * // Update one ExpenseItem
     * const expenseItem = await prisma.expenseItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExpenseItemUpdateArgs>(
      args: SelectSubset<T, ExpenseItemUpdateArgs>
    ): CheckSelect<T, Prisma__ExpenseItemClient<ExpenseItem>, Prisma__ExpenseItemClient<ExpenseItemGetPayload<T>>>

    /**
     * Delete zero or more ExpenseItems.
     * @param {ExpenseItemDeleteManyArgs} args - Arguments to filter ExpenseItems to delete.
     * @example
     * // Delete a few ExpenseItems
     * const { count } = await prisma.expenseItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExpenseItemDeleteManyArgs>(
      args?: SelectSubset<T, ExpenseItemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseItems
     * const expenseItem = await prisma.expenseItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExpenseItemUpdateManyArgs>(
      args: SelectSubset<T, ExpenseItemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ExpenseItem.
     * @param {ExpenseItemUpsertArgs} args - Arguments to update or create a ExpenseItem.
     * @example
     * // Update or create a ExpenseItem
     * const expenseItem = await prisma.expenseItem.upsert({
     *   create: {
     *     // ... data to create a ExpenseItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseItem we want to update
     *   }
     * })
    **/
    upsert<T extends ExpenseItemUpsertArgs>(
      args: SelectSubset<T, ExpenseItemUpsertArgs>
    ): CheckSelect<T, Prisma__ExpenseItemClient<ExpenseItem>, Prisma__ExpenseItemClient<ExpenseItemGetPayload<T>>>

    /**
     * Count the number of ExpenseItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseItemCountArgs} args - Arguments to filter ExpenseItems to count.
     * @example
     * // Count the number of ExpenseItems
     * const count = await prisma.expenseItem.count({
     *   where: {
     *     // ... the filter for the ExpenseItems we want to count
     *   }
     * })
    **/
    count<T extends ExpenseItemCountArgs>(
      args?: Subset<T, ExpenseItemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseItemAggregateArgs>(args: Subset<T, ExpenseItemAggregateArgs>): PrismaPromise<GetExpenseItemAggregateType<T>>

    /**
     * Group by ExpenseItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseItemGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseItemGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExpenseItemClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    Expense<T extends ExpenseFindManyArgs = {}>(args?: Subset<T, ExpenseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Expense>>, PrismaPromise<Array<ExpenseGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ExpenseItem findUnique
   */
  export type ExpenseItemFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ExpenseItem
     * 
    **/
    select?: ExpenseItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseItemInclude | null
    /**
     * Throw an Error if a ExpenseItem can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ExpenseItem to fetch.
     * 
    **/
    where: ExpenseItemWhereUniqueInput
  }


  /**
   * ExpenseItem findFirst
   */
  export type ExpenseItemFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ExpenseItem
     * 
    **/
    select?: ExpenseItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseItemInclude | null
    /**
     * Throw an Error if a ExpenseItem can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ExpenseItem to fetch.
     * 
    **/
    where?: ExpenseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseItems to fetch.
     * 
    **/
    orderBy?: Enumerable<ExpenseItemOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseItems.
     * 
    **/
    cursor?: ExpenseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseItems.
     * 
    **/
    distinct?: Enumerable<ExpenseItemScalarFieldEnum>
  }


  /**
   * ExpenseItem findMany
   */
  export type ExpenseItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the ExpenseItem
     * 
    **/
    select?: ExpenseItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseItemInclude | null
    /**
     * Filter, which ExpenseItems to fetch.
     * 
    **/
    where?: ExpenseItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseItems to fetch.
     * 
    **/
    orderBy?: Enumerable<ExpenseItemOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseItems.
     * 
    **/
    cursor?: ExpenseItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ExpenseItemScalarFieldEnum>
  }


  /**
   * ExpenseItem create
   */
  export type ExpenseItemCreateArgs = {
    /**
     * Select specific fields to fetch from the ExpenseItem
     * 
    **/
    select?: ExpenseItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseItemInclude | null
    /**
     * The data needed to create a ExpenseItem.
     * 
    **/
    data: XOR<ExpenseItemCreateInput, ExpenseItemUncheckedCreateInput>
  }


  /**
   * ExpenseItem createMany
   */
  export type ExpenseItemCreateManyArgs = {
    data: Enumerable<ExpenseItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ExpenseItem update
   */
  export type ExpenseItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the ExpenseItem
     * 
    **/
    select?: ExpenseItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseItemInclude | null
    /**
     * The data needed to update a ExpenseItem.
     * 
    **/
    data: XOR<ExpenseItemUpdateInput, ExpenseItemUncheckedUpdateInput>
    /**
     * Choose, which ExpenseItem to update.
     * 
    **/
    where: ExpenseItemWhereUniqueInput
  }


  /**
   * ExpenseItem updateMany
   */
  export type ExpenseItemUpdateManyArgs = {
    data: XOR<ExpenseItemUpdateManyMutationInput, ExpenseItemUncheckedUpdateManyInput>
    where?: ExpenseItemWhereInput
  }


  /**
   * ExpenseItem upsert
   */
  export type ExpenseItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the ExpenseItem
     * 
    **/
    select?: ExpenseItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseItemInclude | null
    /**
     * The filter to search for the ExpenseItem to update in case it exists.
     * 
    **/
    where: ExpenseItemWhereUniqueInput
    /**
     * In case the ExpenseItem found by the `where` argument doesn't exist, create a new ExpenseItem with this data.
     * 
    **/
    create: XOR<ExpenseItemCreateInput, ExpenseItemUncheckedCreateInput>
    /**
     * In case the ExpenseItem was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ExpenseItemUpdateInput, ExpenseItemUncheckedUpdateInput>
  }


  /**
   * ExpenseItem delete
   */
  export type ExpenseItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the ExpenseItem
     * 
    **/
    select?: ExpenseItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseItemInclude | null
    /**
     * Filter which ExpenseItem to delete.
     * 
    **/
    where: ExpenseItemWhereUniqueInput
  }


  /**
   * ExpenseItem deleteMany
   */
  export type ExpenseItemDeleteManyArgs = {
    where?: ExpenseItemWhereInput
  }


  /**
   * ExpenseItem without action
   */
  export type ExpenseItemArgs = {
    /**
     * Select specific fields to fetch from the ExpenseItem
     * 
    **/
    select?: ExpenseItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ExpenseItemInclude | null
  }



  /**
   * Model Income
   */


  export type AggregateIncome = {
    _count: IncomeCountAggregateOutputType | null
    count: IncomeCountAggregateOutputType | null
    _avg: IncomeAvgAggregateOutputType | null
    avg: IncomeAvgAggregateOutputType | null
    _sum: IncomeSumAggregateOutputType | null
    sum: IncomeSumAggregateOutputType | null
    _min: IncomeMinAggregateOutputType | null
    min: IncomeMinAggregateOutputType | null
    _max: IncomeMaxAggregateOutputType | null
    max: IncomeMaxAggregateOutputType | null
  }

  export type IncomeAvgAggregateOutputType = {
    value: number | null
  }

  export type IncomeSumAggregateOutputType = {
    value: number | null
  }

  export type IncomeMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    reference: string | null
    value: number | null
    type: string | null
    workDayId: string | null
  }

  export type IncomeMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    reference: string | null
    value: number | null
    type: string | null
    workDayId: string | null
  }

  export type IncomeCountAggregateOutputType = {
    id: number
    createdAt: number
    reference: number
    value: number
    type: number
    workDayId: number
    _all: number
  }


  export type IncomeAvgAggregateInputType = {
    value?: true
  }

  export type IncomeSumAggregateInputType = {
    value?: true
  }

  export type IncomeMinAggregateInputType = {
    id?: true
    createdAt?: true
    reference?: true
    value?: true
    type?: true
    workDayId?: true
  }

  export type IncomeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    reference?: true
    value?: true
    type?: true
    workDayId?: true
  }

  export type IncomeCountAggregateInputType = {
    id?: true
    createdAt?: true
    reference?: true
    value?: true
    type?: true
    workDayId?: true
    _all?: true
  }

  export type IncomeAggregateArgs = {
    /**
     * Filter which Income to aggregate.
     * 
    **/
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     * 
    **/
    orderBy?: Enumerable<IncomeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incomes
    **/
    _count?: true | IncomeCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | IncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncomeAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: IncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncomeSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: IncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomeMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: IncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomeMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: IncomeMaxAggregateInputType
  }

  export type GetIncomeAggregateType<T extends IncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncome[P]>
      : GetScalarType<T[P], AggregateIncome[P]>
  }


    
    
  export type IncomeGroupByArgs = {
    where?: IncomeWhereInput
    orderBy?: Enumerable<IncomeOrderByInput>
    by: Array<IncomeScalarFieldEnum>
    having?: IncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomeCountAggregateInputType | true
    _avg?: IncomeAvgAggregateInputType
    _sum?: IncomeSumAggregateInputType
    _min?: IncomeMinAggregateInputType
    _max?: IncomeMaxAggregateInputType
  }


  export type IncomeGroupByOutputType = {
    id: string
    createdAt: Date
    reference: string
    value: number
    type: string | null
    workDayId: string | null
    _count: IncomeCountAggregateOutputType | null
    _avg: IncomeAvgAggregateOutputType | null
    _sum: IncomeSumAggregateOutputType | null
    _min: IncomeMinAggregateOutputType | null
    _max: IncomeMaxAggregateOutputType | null
  }

  type GetIncomeGroupByPayload<T extends IncomeGroupByArgs> = Promise<
    Array<
      PickArray<IncomeGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof IncomeGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], IncomeGroupByOutputType[P]> 
            : GetScalarType<T[P], IncomeGroupByOutputType[P]>
        }
      > 
    >


  export type IncomeSelect = {
    id?: boolean
    createdAt?: boolean
    reference?: boolean
    value?: boolean
    type?: boolean
    workDayId?: boolean
    workDay?: boolean | WorkDayArgs
  }

  export type IncomeInclude = {
    workDay?: boolean | WorkDayArgs
  }

  export type IncomeGetPayload<
    S extends boolean | null | undefined | IncomeArgs,
    U = keyof S
      > = S extends true
        ? Income
    : S extends undefined
    ? never
    : S extends IncomeArgs | IncomeFindManyArgs
    ?'include' extends U
    ? Income  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'workDay'
        ? WorkDayGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Income ?Income [P]
  : 
          P extends 'workDay'
        ? WorkDayGetPayload<S['select'][P]> | null : never
  } 
    : Income
  : Income


  type IncomeCountArgs = Merge<
    Omit<IncomeFindManyArgs, 'select' | 'include'> & {
      select?: IncomeCountAggregateInputType | true
    }
  >

  export interface IncomeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Income that matches the filter.
     * @param {IncomeFindUniqueArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IncomeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IncomeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Income'> extends True ? CheckSelect<T, Prisma__IncomeClient<Income>, Prisma__IncomeClient<IncomeGetPayload<T>>> : CheckSelect<T, Prisma__IncomeClient<Income | null >, Prisma__IncomeClient<IncomeGetPayload<T> | null >>

    /**
     * Find the first Income that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeFindFirstArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IncomeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IncomeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Income'> extends True ? CheckSelect<T, Prisma__IncomeClient<Income>, Prisma__IncomeClient<IncomeGetPayload<T>>> : CheckSelect<T, Prisma__IncomeClient<Income | null >, Prisma__IncomeClient<IncomeGetPayload<T> | null >>

    /**
     * Find zero or more Incomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incomes
     * const incomes = await prisma.income.findMany()
     * 
     * // Get first 10 Incomes
     * const incomes = await prisma.income.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomeWithIdOnly = await prisma.income.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IncomeFindManyArgs>(
      args?: SelectSubset<T, IncomeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Income>>, PrismaPromise<Array<IncomeGetPayload<T>>>>

    /**
     * Create a Income.
     * @param {IncomeCreateArgs} args - Arguments to create a Income.
     * @example
     * // Create one Income
     * const Income = await prisma.income.create({
     *   data: {
     *     // ... data to create a Income
     *   }
     * })
     * 
    **/
    create<T extends IncomeCreateArgs>(
      args: SelectSubset<T, IncomeCreateArgs>
    ): CheckSelect<T, Prisma__IncomeClient<Income>, Prisma__IncomeClient<IncomeGetPayload<T>>>

    /**
     * Create many Incomes.
     *     @param {IncomeCreateManyArgs} args - Arguments to create many Incomes.
     *     @example
     *     // Create many Incomes
     *     const income = await prisma.income.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IncomeCreateManyArgs>(
      args?: SelectSubset<T, IncomeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Income.
     * @param {IncomeDeleteArgs} args - Arguments to delete one Income.
     * @example
     * // Delete one Income
     * const Income = await prisma.income.delete({
     *   where: {
     *     // ... filter to delete one Income
     *   }
     * })
     * 
    **/
    delete<T extends IncomeDeleteArgs>(
      args: SelectSubset<T, IncomeDeleteArgs>
    ): CheckSelect<T, Prisma__IncomeClient<Income>, Prisma__IncomeClient<IncomeGetPayload<T>>>

    /**
     * Update one Income.
     * @param {IncomeUpdateArgs} args - Arguments to update one Income.
     * @example
     * // Update one Income
     * const income = await prisma.income.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IncomeUpdateArgs>(
      args: SelectSubset<T, IncomeUpdateArgs>
    ): CheckSelect<T, Prisma__IncomeClient<Income>, Prisma__IncomeClient<IncomeGetPayload<T>>>

    /**
     * Delete zero or more Incomes.
     * @param {IncomeDeleteManyArgs} args - Arguments to filter Incomes to delete.
     * @example
     * // Delete a few Incomes
     * const { count } = await prisma.income.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IncomeDeleteManyArgs>(
      args?: SelectSubset<T, IncomeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incomes
     * const income = await prisma.income.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IncomeUpdateManyArgs>(
      args: SelectSubset<T, IncomeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Income.
     * @param {IncomeUpsertArgs} args - Arguments to update or create a Income.
     * @example
     * // Update or create a Income
     * const income = await prisma.income.upsert({
     *   create: {
     *     // ... data to create a Income
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Income we want to update
     *   }
     * })
    **/
    upsert<T extends IncomeUpsertArgs>(
      args: SelectSubset<T, IncomeUpsertArgs>
    ): CheckSelect<T, Prisma__IncomeClient<Income>, Prisma__IncomeClient<IncomeGetPayload<T>>>

    /**
     * Count the number of Incomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeCountArgs} args - Arguments to filter Incomes to count.
     * @example
     * // Count the number of Incomes
     * const count = await prisma.income.count({
     *   where: {
     *     // ... the filter for the Incomes we want to count
     *   }
     * })
    **/
    count<T extends IncomeCountArgs>(
      args?: Subset<T, IncomeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Income.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomeAggregateArgs>(args: Subset<T, IncomeAggregateArgs>): PrismaPromise<GetIncomeAggregateType<T>>

    /**
     * Group by Income.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomeGroupByArgs['orderBy'] }
        : { orderBy?: IncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomeGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Income.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IncomeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    workDay<T extends WorkDayArgs = {}>(args?: Subset<T, WorkDayArgs>): CheckSelect<T, Prisma__WorkDayClient<WorkDay | null >, Prisma__WorkDayClient<WorkDayGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Income findUnique
   */
  export type IncomeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Income
     * 
    **/
    select?: IncomeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncomeInclude | null
    /**
     * Throw an Error if a Income can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Income to fetch.
     * 
    **/
    where: IncomeWhereUniqueInput
  }


  /**
   * Income findFirst
   */
  export type IncomeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Income
     * 
    **/
    select?: IncomeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncomeInclude | null
    /**
     * Throw an Error if a Income can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Income to fetch.
     * 
    **/
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     * 
    **/
    orderBy?: Enumerable<IncomeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incomes.
     * 
    **/
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incomes.
     * 
    **/
    distinct?: Enumerable<IncomeScalarFieldEnum>
  }


  /**
   * Income findMany
   */
  export type IncomeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Income
     * 
    **/
    select?: IncomeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncomeInclude | null
    /**
     * Filter, which Incomes to fetch.
     * 
    **/
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     * 
    **/
    orderBy?: Enumerable<IncomeOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incomes.
     * 
    **/
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IncomeScalarFieldEnum>
  }


  /**
   * Income create
   */
  export type IncomeCreateArgs = {
    /**
     * Select specific fields to fetch from the Income
     * 
    **/
    select?: IncomeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncomeInclude | null
    /**
     * The data needed to create a Income.
     * 
    **/
    data: XOR<IncomeCreateInput, IncomeUncheckedCreateInput>
  }


  /**
   * Income createMany
   */
  export type IncomeCreateManyArgs = {
    data: Enumerable<IncomeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Income update
   */
  export type IncomeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Income
     * 
    **/
    select?: IncomeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncomeInclude | null
    /**
     * The data needed to update a Income.
     * 
    **/
    data: XOR<IncomeUpdateInput, IncomeUncheckedUpdateInput>
    /**
     * Choose, which Income to update.
     * 
    **/
    where: IncomeWhereUniqueInput
  }


  /**
   * Income updateMany
   */
  export type IncomeUpdateManyArgs = {
    data: XOR<IncomeUpdateManyMutationInput, IncomeUncheckedUpdateManyInput>
    where?: IncomeWhereInput
  }


  /**
   * Income upsert
   */
  export type IncomeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Income
     * 
    **/
    select?: IncomeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncomeInclude | null
    /**
     * The filter to search for the Income to update in case it exists.
     * 
    **/
    where: IncomeWhereUniqueInput
    /**
     * In case the Income found by the `where` argument doesn't exist, create a new Income with this data.
     * 
    **/
    create: XOR<IncomeCreateInput, IncomeUncheckedCreateInput>
    /**
     * In case the Income was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IncomeUpdateInput, IncomeUncheckedUpdateInput>
  }


  /**
   * Income delete
   */
  export type IncomeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Income
     * 
    **/
    select?: IncomeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncomeInclude | null
    /**
     * Filter which Income to delete.
     * 
    **/
    where: IncomeWhereUniqueInput
  }


  /**
   * Income deleteMany
   */
  export type IncomeDeleteManyArgs = {
    where?: IncomeWhereInput
  }


  /**
   * Income without action
   */
  export type IncomeArgs = {
    /**
     * Select specific fields to fetch from the Income
     * 
    **/
    select?: IncomeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IncomeInclude | null
  }



  /**
   * Model Item
   */


  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
    max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    price: number | null
    priceToGo: number | null
    employeePrice: number | null
  }

  export type ItemSumAggregateOutputType = {
    price: number | null
    priceToGo: number | null
    employeePrice: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    name: string | null
    price: number | null
    priceToGo: number | null
    employeePrice: number | null
    category: string | null
    canTakeToGo: boolean | null
    isActive: boolean | null
    hasTaxSubstitution: boolean | null
    establishmentId: string | null
    itemNCMId: string | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    name: string | null
    price: number | null
    priceToGo: number | null
    employeePrice: number | null
    category: string | null
    canTakeToGo: boolean | null
    isActive: boolean | null
    hasTaxSubstitution: boolean | null
    establishmentId: string | null
    itemNCMId: string | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    itemId: number
    name: number
    price: number
    priceToGo: number
    employeePrice: number
    category: number
    canTakeToGo: number
    isActive: number
    hasTaxSubstitution: number
    establishmentId: number
    itemNCMId: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    price?: true
    priceToGo?: true
    employeePrice?: true
  }

  export type ItemSumAggregateInputType = {
    price?: true
    priceToGo?: true
    employeePrice?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    itemId?: true
    name?: true
    price?: true
    priceToGo?: true
    employeePrice?: true
    category?: true
    canTakeToGo?: true
    isActive?: true
    hasTaxSubstitution?: true
    establishmentId?: true
    itemNCMId?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    itemId?: true
    name?: true
    price?: true
    priceToGo?: true
    employeePrice?: true
    category?: true
    canTakeToGo?: true
    isActive?: true
    hasTaxSubstitution?: true
    establishmentId?: true
    itemNCMId?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    itemId?: true
    name?: true
    price?: true
    priceToGo?: true
    employeePrice?: true
    category?: true
    canTakeToGo?: true
    isActive?: true
    hasTaxSubstitution?: true
    establishmentId?: true
    itemNCMId?: true
    _all?: true
  }

  export type ItemAggregateArgs = {
    /**
     * Filter which Item to aggregate.
     * 
    **/
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }


    
    
  export type ItemGroupByArgs = {
    where?: ItemWhereInput
    orderBy?: Enumerable<ItemOrderByInput>
    by: Array<ItemScalarFieldEnum>
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }


  export type ItemGroupByOutputType = {
    id: string
    itemId: string
    name: string
    price: number
    priceToGo: number | null
    employeePrice: number | null
    category: string
    canTakeToGo: boolean | null
    isActive: boolean
    hasTaxSubstitution: boolean | null
    establishmentId: string | null
    itemNCMId: string | null
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Promise<
    Array<
      PickArray<ItemGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ItemGroupByOutputType[P]> 
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      > 
    >


  export type ItemSelect = {
    id?: boolean
    itemId?: boolean
    name?: boolean
    price?: boolean
    priceToGo?: boolean
    employeePrice?: boolean
    category?: boolean
    canTakeToGo?: boolean
    isActive?: boolean
    hasTaxSubstitution?: boolean
    establishmentId?: boolean
    itemNCMId?: boolean
    establishment?: boolean | EstablishmentArgs
    itemNCM?: boolean | NCMArgs
    orderItem?: boolean | OrderItemFindManyArgs
  }

  export type ItemInclude = {
    establishment?: boolean | EstablishmentArgs
    itemNCM?: boolean | NCMArgs
    orderItem?: boolean | OrderItemFindManyArgs
  }

  export type ItemGetPayload<
    S extends boolean | null | undefined | ItemArgs,
    U = keyof S
      > = S extends true
        ? Item
    : S extends undefined
    ? never
    : S extends ItemArgs | ItemFindManyArgs
    ?'include' extends U
    ? Item  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['include'][P]> | null :
        P extends 'itemNCM'
        ? NCMGetPayload<S['include'][P]> | null :
        P extends 'orderItem'
        ? Array < OrderItemGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Item ?Item [P]
  : 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['select'][P]> | null :
        P extends 'itemNCM'
        ? NCMGetPayload<S['select'][P]> | null :
        P extends 'orderItem'
        ? Array < OrderItemGetPayload<S['select'][P]>>  : never
  } 
    : Item
  : Item


  type ItemCountArgs = Merge<
    Omit<ItemFindManyArgs, 'select' | 'include'> & {
      select?: ItemCountAggregateInputType | true
    }
  >

  export interface ItemDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Item'> extends True ? CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>> : CheckSelect<T, Prisma__ItemClient<Item | null >, Prisma__ItemClient<ItemGetPayload<T> | null >>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Item'> extends True ? CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>> : CheckSelect<T, Prisma__ItemClient<Item | null >, Prisma__ItemClient<ItemGetPayload<T> | null >>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemFindManyArgs>(
      args?: SelectSubset<T, ItemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Item>>, PrismaPromise<Array<ItemGetPayload<T>>>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
    **/
    create<T extends ItemCreateArgs>(
      args: SelectSubset<T, ItemCreateArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Create many Items.
     *     @param {ItemCreateManyArgs} args - Arguments to create many Items.
     *     @example
     *     // Create many Items
     *     const item = await prisma.item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemCreateManyArgs>(
      args?: SelectSubset<T, ItemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
    **/
    delete<T extends ItemDeleteArgs>(
      args: SelectSubset<T, ItemDeleteArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemUpdateArgs>(
      args: SelectSubset<T, ItemUpdateArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemDeleteManyArgs>(
      args?: SelectSubset<T, ItemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemUpdateManyArgs>(
      args: SelectSubset<T, ItemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
    **/
    upsert<T extends ItemUpsertArgs>(
      args: SelectSubset<T, ItemUpsertArgs>
    ): CheckSelect<T, Prisma__ItemClient<Item>, Prisma__ItemClient<ItemGetPayload<T>>>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ItemClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    establishment<T extends EstablishmentArgs = {}>(args?: Subset<T, EstablishmentArgs>): CheckSelect<T, Prisma__EstablishmentClient<Establishment | null >, Prisma__EstablishmentClient<EstablishmentGetPayload<T> | null >>;

    itemNCM<T extends NCMArgs = {}>(args?: Subset<T, NCMArgs>): CheckSelect<T, Prisma__NCMClient<NCM | null >, Prisma__NCMClient<NCMGetPayload<T> | null >>;

    orderItem<T extends OrderItemFindManyArgs = {}>(args?: Subset<T, OrderItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderItem>>, PrismaPromise<Array<OrderItemGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * Throw an Error if a Item can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Item to fetch.
     * 
    **/
    where: ItemWhereUniqueInput
  }


  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * Throw an Error if a Item can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Item to fetch.
     * 
    **/
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     * 
    **/
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     * 
    **/
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Item findMany
   */
  export type ItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * Filter, which Items to fetch.
     * 
    **/
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     * 
    **/
    orderBy?: Enumerable<ItemOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     * 
    **/
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Item create
   */
  export type ItemCreateArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * The data needed to create a Item.
     * 
    **/
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }


  /**
   * Item createMany
   */
  export type ItemCreateManyArgs = {
    data: Enumerable<ItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Item update
   */
  export type ItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * The data needed to update a Item.
     * 
    **/
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     * 
    **/
    where: ItemWhereUniqueInput
  }


  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs = {
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    where?: ItemWhereInput
  }


  /**
   * Item upsert
   */
  export type ItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * The filter to search for the Item to update in case it exists.
     * 
    **/
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     * 
    **/
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }


  /**
   * Item delete
   */
  export type ItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
    /**
     * Filter which Item to delete.
     * 
    **/
    where: ItemWhereUniqueInput
  }


  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs = {
    where?: ItemWhereInput
  }


  /**
   * Item without action
   */
  export type ItemArgs = {
    /**
     * Select specific fields to fetch from the Item
     * 
    **/
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ItemInclude | null
  }



  /**
   * Model NCM
   */


  export type AggregateNCM = {
    _count: NCMCountAggregateOutputType | null
    count: NCMCountAggregateOutputType | null
    _min: NCMMinAggregateOutputType | null
    min: NCMMinAggregateOutputType | null
    _max: NCMMaxAggregateOutputType | null
    max: NCMMaxAggregateOutputType | null
  }

  export type NCMMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    description: string | null
  }

  export type NCMMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    description: string | null
  }

  export type NCMCountAggregateOutputType = {
    id: number
    identifier: number
    description: number
    _all: number
  }


  export type NCMMinAggregateInputType = {
    id?: true
    identifier?: true
    description?: true
  }

  export type NCMMaxAggregateInputType = {
    id?: true
    identifier?: true
    description?: true
  }

  export type NCMCountAggregateInputType = {
    id?: true
    identifier?: true
    description?: true
    _all?: true
  }

  export type NCMAggregateArgs = {
    /**
     * Filter which NCM to aggregate.
     * 
    **/
    where?: NCMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NCMS to fetch.
     * 
    **/
    orderBy?: Enumerable<NCMOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NCMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NCMS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NCMS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NCMS
    **/
    _count?: true | NCMCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | NCMCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NCMMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: NCMMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NCMMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: NCMMaxAggregateInputType
  }

  export type GetNCMAggregateType<T extends NCMAggregateArgs> = {
        [P in keyof T & keyof AggregateNCM]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNCM[P]>
      : GetScalarType<T[P], AggregateNCM[P]>
  }


    
    
  export type NCMGroupByArgs = {
    where?: NCMWhereInput
    orderBy?: Enumerable<NCMOrderByInput>
    by: Array<NCMScalarFieldEnum>
    having?: NCMScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NCMCountAggregateInputType | true
    _min?: NCMMinAggregateInputType
    _max?: NCMMaxAggregateInputType
  }


  export type NCMGroupByOutputType = {
    id: string
    identifier: string
    description: string | null
    _count: NCMCountAggregateOutputType | null
    _min: NCMMinAggregateOutputType | null
    _max: NCMMaxAggregateOutputType | null
  }

  type GetNCMGroupByPayload<T extends NCMGroupByArgs> = Promise<
    Array<
      PickArray<NCMGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof NCMGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], NCMGroupByOutputType[P]> 
            : GetScalarType<T[P], NCMGroupByOutputType[P]>
        }
      > 
    >


  export type NCMSelect = {
    id?: boolean
    identifier?: boolean
    description?: boolean
    items?: boolean | ItemFindManyArgs
  }

  export type NCMInclude = {
    items?: boolean | ItemFindManyArgs
  }

  export type NCMGetPayload<
    S extends boolean | null | undefined | NCMArgs,
    U = keyof S
      > = S extends true
        ? NCM
    : S extends undefined
    ? never
    : S extends NCMArgs | NCMFindManyArgs
    ?'include' extends U
    ? NCM  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'items'
        ? Array < ItemGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof NCM ?NCM [P]
  : 
          P extends 'items'
        ? Array < ItemGetPayload<S['select'][P]>>  : never
  } 
    : NCM
  : NCM


  type NCMCountArgs = Merge<
    Omit<NCMFindManyArgs, 'select' | 'include'> & {
      select?: NCMCountAggregateInputType | true
    }
  >

  export interface NCMDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one NCM that matches the filter.
     * @param {NCMFindUniqueArgs} args - Arguments to find a NCM
     * @example
     * // Get one NCM
     * const nCM = await prisma.nCM.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NCMFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NCMFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NCM'> extends True ? CheckSelect<T, Prisma__NCMClient<NCM>, Prisma__NCMClient<NCMGetPayload<T>>> : CheckSelect<T, Prisma__NCMClient<NCM | null >, Prisma__NCMClient<NCMGetPayload<T> | null >>

    /**
     * Find the first NCM that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCMFindFirstArgs} args - Arguments to find a NCM
     * @example
     * // Get one NCM
     * const nCM = await prisma.nCM.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NCMFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NCMFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NCM'> extends True ? CheckSelect<T, Prisma__NCMClient<NCM>, Prisma__NCMClient<NCMGetPayload<T>>> : CheckSelect<T, Prisma__NCMClient<NCM | null >, Prisma__NCMClient<NCMGetPayload<T> | null >>

    /**
     * Find zero or more NCMS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCMFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NCMS
     * const nCMS = await prisma.nCM.findMany()
     * 
     * // Get first 10 NCMS
     * const nCMS = await prisma.nCM.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nCMWithIdOnly = await prisma.nCM.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NCMFindManyArgs>(
      args?: SelectSubset<T, NCMFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<NCM>>, PrismaPromise<Array<NCMGetPayload<T>>>>

    /**
     * Create a NCM.
     * @param {NCMCreateArgs} args - Arguments to create a NCM.
     * @example
     * // Create one NCM
     * const NCM = await prisma.nCM.create({
     *   data: {
     *     // ... data to create a NCM
     *   }
     * })
     * 
    **/
    create<T extends NCMCreateArgs>(
      args: SelectSubset<T, NCMCreateArgs>
    ): CheckSelect<T, Prisma__NCMClient<NCM>, Prisma__NCMClient<NCMGetPayload<T>>>

    /**
     * Create many NCMS.
     *     @param {NCMCreateManyArgs} args - Arguments to create many NCMS.
     *     @example
     *     // Create many NCMS
     *     const nCM = await prisma.nCM.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NCMCreateManyArgs>(
      args?: SelectSubset<T, NCMCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a NCM.
     * @param {NCMDeleteArgs} args - Arguments to delete one NCM.
     * @example
     * // Delete one NCM
     * const NCM = await prisma.nCM.delete({
     *   where: {
     *     // ... filter to delete one NCM
     *   }
     * })
     * 
    **/
    delete<T extends NCMDeleteArgs>(
      args: SelectSubset<T, NCMDeleteArgs>
    ): CheckSelect<T, Prisma__NCMClient<NCM>, Prisma__NCMClient<NCMGetPayload<T>>>

    /**
     * Update one NCM.
     * @param {NCMUpdateArgs} args - Arguments to update one NCM.
     * @example
     * // Update one NCM
     * const nCM = await prisma.nCM.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NCMUpdateArgs>(
      args: SelectSubset<T, NCMUpdateArgs>
    ): CheckSelect<T, Prisma__NCMClient<NCM>, Prisma__NCMClient<NCMGetPayload<T>>>

    /**
     * Delete zero or more NCMS.
     * @param {NCMDeleteManyArgs} args - Arguments to filter NCMS to delete.
     * @example
     * // Delete a few NCMS
     * const { count } = await prisma.nCM.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NCMDeleteManyArgs>(
      args?: SelectSubset<T, NCMDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more NCMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCMUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NCMS
     * const nCM = await prisma.nCM.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NCMUpdateManyArgs>(
      args: SelectSubset<T, NCMUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one NCM.
     * @param {NCMUpsertArgs} args - Arguments to update or create a NCM.
     * @example
     * // Update or create a NCM
     * const nCM = await prisma.nCM.upsert({
     *   create: {
     *     // ... data to create a NCM
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NCM we want to update
     *   }
     * })
    **/
    upsert<T extends NCMUpsertArgs>(
      args: SelectSubset<T, NCMUpsertArgs>
    ): CheckSelect<T, Prisma__NCMClient<NCM>, Prisma__NCMClient<NCMGetPayload<T>>>

    /**
     * Count the number of NCMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCMCountArgs} args - Arguments to filter NCMS to count.
     * @example
     * // Count the number of NCMS
     * const count = await prisma.nCM.count({
     *   where: {
     *     // ... the filter for the NCMS we want to count
     *   }
     * })
    **/
    count<T extends NCMCountArgs>(
      args?: Subset<T, NCMCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NCMCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NCM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCMAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NCMAggregateArgs>(args: Subset<T, NCMAggregateArgs>): PrismaPromise<GetNCMAggregateType<T>>

    /**
     * Group by NCM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCMGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NCMGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NCMGroupByArgs['orderBy'] }
        : { orderBy?: NCMGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NCMGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNCMGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for NCM.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NCMClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    items<T extends ItemFindManyArgs = {}>(args?: Subset<T, ItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Item>>, PrismaPromise<Array<ItemGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * NCM findUnique
   */
  export type NCMFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the NCM
     * 
    **/
    select?: NCMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NCMInclude | null
    /**
     * Throw an Error if a NCM can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NCM to fetch.
     * 
    **/
    where: NCMWhereUniqueInput
  }


  /**
   * NCM findFirst
   */
  export type NCMFindFirstArgs = {
    /**
     * Select specific fields to fetch from the NCM
     * 
    **/
    select?: NCMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NCMInclude | null
    /**
     * Throw an Error if a NCM can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NCM to fetch.
     * 
    **/
    where?: NCMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NCMS to fetch.
     * 
    **/
    orderBy?: Enumerable<NCMOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NCMS.
     * 
    **/
    cursor?: NCMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NCMS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NCMS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NCMS.
     * 
    **/
    distinct?: Enumerable<NCMScalarFieldEnum>
  }


  /**
   * NCM findMany
   */
  export type NCMFindManyArgs = {
    /**
     * Select specific fields to fetch from the NCM
     * 
    **/
    select?: NCMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NCMInclude | null
    /**
     * Filter, which NCMS to fetch.
     * 
    **/
    where?: NCMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NCMS to fetch.
     * 
    **/
    orderBy?: Enumerable<NCMOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NCMS.
     * 
    **/
    cursor?: NCMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NCMS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NCMS.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NCMScalarFieldEnum>
  }


  /**
   * NCM create
   */
  export type NCMCreateArgs = {
    /**
     * Select specific fields to fetch from the NCM
     * 
    **/
    select?: NCMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NCMInclude | null
    /**
     * The data needed to create a NCM.
     * 
    **/
    data: XOR<NCMCreateInput, NCMUncheckedCreateInput>
  }


  /**
   * NCM createMany
   */
  export type NCMCreateManyArgs = {
    data: Enumerable<NCMCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NCM update
   */
  export type NCMUpdateArgs = {
    /**
     * Select specific fields to fetch from the NCM
     * 
    **/
    select?: NCMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NCMInclude | null
    /**
     * The data needed to update a NCM.
     * 
    **/
    data: XOR<NCMUpdateInput, NCMUncheckedUpdateInput>
    /**
     * Choose, which NCM to update.
     * 
    **/
    where: NCMWhereUniqueInput
  }


  /**
   * NCM updateMany
   */
  export type NCMUpdateManyArgs = {
    data: XOR<NCMUpdateManyMutationInput, NCMUncheckedUpdateManyInput>
    where?: NCMWhereInput
  }


  /**
   * NCM upsert
   */
  export type NCMUpsertArgs = {
    /**
     * Select specific fields to fetch from the NCM
     * 
    **/
    select?: NCMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NCMInclude | null
    /**
     * The filter to search for the NCM to update in case it exists.
     * 
    **/
    where: NCMWhereUniqueInput
    /**
     * In case the NCM found by the `where` argument doesn't exist, create a new NCM with this data.
     * 
    **/
    create: XOR<NCMCreateInput, NCMUncheckedCreateInput>
    /**
     * In case the NCM was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NCMUpdateInput, NCMUncheckedUpdateInput>
  }


  /**
   * NCM delete
   */
  export type NCMDeleteArgs = {
    /**
     * Select specific fields to fetch from the NCM
     * 
    **/
    select?: NCMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NCMInclude | null
    /**
     * Filter which NCM to delete.
     * 
    **/
    where: NCMWhereUniqueInput
  }


  /**
   * NCM deleteMany
   */
  export type NCMDeleteManyArgs = {
    where?: NCMWhereInput
  }


  /**
   * NCM without action
   */
  export type NCMArgs = {
    /**
     * Select specific fields to fetch from the NCM
     * 
    **/
    select?: NCMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NCMInclude | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
    max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    block: number | null
    orderId: number | null
  }

  export type OrderSumAggregateOutputType = {
    block: number | null
    orderId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    block: number | null
    orderId: number | null
    cancelled: boolean | null
    cancelationJustification: string | null
    wasModified: boolean | null
    isEmployeeOrder: boolean | null
    reuse: boolean | null
    isToGo: boolean | null
    toGoReference: string | null
    workDayId: string | null
    billId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    block: number | null
    orderId: number | null
    cancelled: boolean | null
    cancelationJustification: string | null
    wasModified: boolean | null
    isEmployeeOrder: boolean | null
    reuse: boolean | null
    isToGo: boolean | null
    toGoReference: string | null
    workDayId: string | null
    billId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    createdAt: number
    block: number
    orderId: number
    cancelled: number
    cancelationJustification: number
    wasModified: number
    isEmployeeOrder: number
    reuse: number
    isToGo: number
    toGoReference: number
    workDayId: number
    billId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    block?: true
    orderId?: true
  }

  export type OrderSumAggregateInputType = {
    block?: true
    orderId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    createdAt?: true
    block?: true
    orderId?: true
    cancelled?: true
    cancelationJustification?: true
    wasModified?: true
    isEmployeeOrder?: true
    reuse?: true
    isToGo?: true
    toGoReference?: true
    workDayId?: true
    billId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    createdAt?: true
    block?: true
    orderId?: true
    cancelled?: true
    cancelationJustification?: true
    wasModified?: true
    isEmployeeOrder?: true
    reuse?: true
    isToGo?: true
    toGoReference?: true
    workDayId?: true
    billId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    createdAt?: true
    block?: true
    orderId?: true
    cancelled?: true
    cancelationJustification?: true
    wasModified?: true
    isEmployeeOrder?: true
    reuse?: true
    isToGo?: true
    toGoReference?: true
    workDayId?: true
    billId?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which Order to aggregate.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }


    
    
  export type OrderGroupByArgs = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByInput>
    by: Array<OrderScalarFieldEnum>
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: string
    createdAt: Date
    block: number
    orderId: number
    cancelled: boolean | null
    cancelationJustification: string | null
    wasModified: boolean | null
    isEmployeeOrder: boolean | null
    reuse: boolean | null
    isToGo: boolean | null
    toGoReference: string | null
    workDayId: string | null
    billId: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Promise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], OrderGroupByOutputType[P]> 
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      > 
    >


  export type OrderSelect = {
    id?: boolean
    createdAt?: boolean
    block?: boolean
    orderId?: boolean
    cancelled?: boolean
    cancelationJustification?: boolean
    wasModified?: boolean
    isEmployeeOrder?: boolean
    reuse?: boolean
    isToGo?: boolean
    toGoReference?: boolean
    workDayId?: boolean
    billId?: boolean
    bill?: boolean | BillArgs
    workDay?: boolean | WorkDayArgs
    orderItems?: boolean | OrderItemFindManyArgs
    modifiedOrdersId?: boolean | OrderFindManyArgs
    modifiedOrders?: boolean | OrderFindManyArgs
  }

  export type OrderInclude = {
    bill?: boolean | BillArgs
    workDay?: boolean | WorkDayArgs
    orderItems?: boolean | OrderItemFindManyArgs
    modifiedOrdersId?: boolean | OrderFindManyArgs
    modifiedOrders?: boolean | OrderFindManyArgs
  }

  export type OrderGetPayload<
    S extends boolean | null | undefined | OrderArgs,
    U = keyof S
      > = S extends true
        ? Order
    : S extends undefined
    ? never
    : S extends OrderArgs | OrderFindManyArgs
    ?'include' extends U
    ? Order  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'bill'
        ? BillGetPayload<S['include'][P]> | null :
        P extends 'workDay'
        ? WorkDayGetPayload<S['include'][P]> | null :
        P extends 'orderItems'
        ? Array < OrderItemGetPayload<S['include'][P]>>  :
        P extends 'modifiedOrdersId'
        ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends 'modifiedOrders'
        ? Array < OrderGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Order ?Order [P]
  : 
          P extends 'bill'
        ? BillGetPayload<S['select'][P]> | null :
        P extends 'workDay'
        ? WorkDayGetPayload<S['select'][P]> | null :
        P extends 'orderItems'
        ? Array < OrderItemGetPayload<S['select'][P]>>  :
        P extends 'modifiedOrdersId'
        ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends 'modifiedOrders'
        ? Array < OrderGetPayload<S['select'][P]>>  : never
  } 
    : Order
  : Order


  type OrderCountArgs = Merge<
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }
  >

  export interface OrderDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>> : CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs>
    ): CheckSelect<T, Prisma__OrderClient<Order>, Prisma__OrderClient<OrderGetPayload<T>>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    bill<T extends BillArgs = {}>(args?: Subset<T, BillArgs>): CheckSelect<T, Prisma__BillClient<Bill | null >, Prisma__BillClient<BillGetPayload<T> | null >>;

    workDay<T extends WorkDayArgs = {}>(args?: Subset<T, WorkDayArgs>): CheckSelect<T, Prisma__WorkDayClient<WorkDay | null >, Prisma__WorkDayClient<WorkDayGetPayload<T> | null >>;

    orderItems<T extends OrderItemFindManyArgs = {}>(args?: Subset<T, OrderItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderItem>>, PrismaPromise<Array<OrderItemGetPayload<T>>>>;

    modifiedOrdersId<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>;

    modifiedOrders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Throw an Error if a Order can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Throw an Error if a Order can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Order to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     * 
    **/
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter, which Orders to fetch.
     * 
    **/
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     * 
    **/
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to create a Order.
     * 
    **/
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs = {
    data: Enumerable<OrderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The data needed to update a Order.
     * 
    **/
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs = {
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * The filter to search for the Order to update in case it exists.
     * 
    **/
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     * 
    **/
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
    /**
     * Filter which Order to delete.
     * 
    **/
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs = {
    where?: OrderWhereInput
  }


  /**
   * Order without action
   */
  export type OrderArgs = {
    /**
     * Select specific fields to fetch from the Order
     * 
    **/
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderInclude | null
  }



  /**
   * Model OrderItem
   */


  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
    max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    orderId: string | null
    employeeId: string | null
    itemId: string | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    orderId: string | null
    employeeId: string | null
    itemId: string | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    quantity: number
    orderId: number
    employeeId: number
    itemId: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    quantity?: true
    orderId?: true
    employeeId?: true
    itemId?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    quantity?: true
    orderId?: true
    employeeId?: true
    itemId?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    quantity?: true
    orderId?: true
    employeeId?: true
    itemId?: true
    _all?: true
  }

  export type OrderItemAggregateArgs = {
    /**
     * Filter which OrderItem to aggregate.
     * 
    **/
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderItemOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }


    
    
  export type OrderItemGroupByArgs = {
    where?: OrderItemWhereInput
    orderBy?: Enumerable<OrderItemOrderByInput>
    by: Array<OrderItemScalarFieldEnum>
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }


  export type OrderItemGroupByOutputType = {
    id: string
    quantity: number
    orderId: string | null
    employeeId: string | null
    itemId: string | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Promise<
    Array<
      PickArray<OrderItemGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]> 
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      > 
    >


  export type OrderItemSelect = {
    id?: boolean
    quantity?: boolean
    orderId?: boolean
    employeeId?: boolean
    itemId?: boolean
    employee?: boolean | EmployeeArgs
    item?: boolean | ItemArgs
    order?: boolean | OrderArgs
  }

  export type OrderItemInclude = {
    employee?: boolean | EmployeeArgs
    item?: boolean | ItemArgs
    order?: boolean | OrderArgs
  }

  export type OrderItemGetPayload<
    S extends boolean | null | undefined | OrderItemArgs,
    U = keyof S
      > = S extends true
        ? OrderItem
    : S extends undefined
    ? never
    : S extends OrderItemArgs | OrderItemFindManyArgs
    ?'include' extends U
    ? OrderItem  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'employee'
        ? EmployeeGetPayload<S['include'][P]> | null :
        P extends 'item'
        ? ItemGetPayload<S['include'][P]> | null :
        P extends 'order'
        ? OrderGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OrderItem ?OrderItem [P]
  : 
          P extends 'employee'
        ? EmployeeGetPayload<S['select'][P]> | null :
        P extends 'item'
        ? ItemGetPayload<S['select'][P]> | null :
        P extends 'order'
        ? OrderGetPayload<S['select'][P]> | null : never
  } 
    : OrderItem
  : OrderItem


  type OrderItemCountArgs = Merge<
    Omit<OrderItemFindManyArgs, 'select' | 'include'> & {
      select?: OrderItemCountAggregateInputType | true
    }
  >

  export interface OrderItemDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrderItem'> extends True ? CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>> : CheckSelect<T, Prisma__OrderItemClient<OrderItem | null >, Prisma__OrderItemClient<OrderItemGetPayload<T> | null >>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrderItem'> extends True ? CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>> : CheckSelect<T, Prisma__OrderItemClient<OrderItem | null >, Prisma__OrderItemClient<OrderItemGetPayload<T> | null >>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderItemFindManyArgs>(
      args?: SelectSubset<T, OrderItemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OrderItem>>, PrismaPromise<Array<OrderItemGetPayload<T>>>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
    **/
    create<T extends OrderItemCreateArgs>(
      args: SelectSubset<T, OrderItemCreateArgs>
    ): CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>>

    /**
     * Create many OrderItems.
     *     @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     *     @example
     *     // Create many OrderItems
     *     const orderItem = await prisma.orderItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderItemCreateManyArgs>(
      args?: SelectSubset<T, OrderItemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
    **/
    delete<T extends OrderItemDeleteArgs>(
      args: SelectSubset<T, OrderItemDeleteArgs>
    ): CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderItemUpdateArgs>(
      args: SelectSubset<T, OrderItemUpdateArgs>
    ): CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderItemDeleteManyArgs>(
      args?: SelectSubset<T, OrderItemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderItemUpdateManyArgs>(
      args: SelectSubset<T, OrderItemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
    **/
    upsert<T extends OrderItemUpsertArgs>(
      args: SelectSubset<T, OrderItemUpsertArgs>
    ): CheckSelect<T, Prisma__OrderItemClient<OrderItem>, Prisma__OrderItemClient<OrderItemGetPayload<T>>>

    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderItemClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    employee<T extends EmployeeArgs = {}>(args?: Subset<T, EmployeeArgs>): CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>;

    item<T extends ItemArgs = {}>(args?: Subset<T, ItemArgs>): CheckSelect<T, Prisma__ItemClient<Item | null >, Prisma__ItemClient<ItemGetPayload<T> | null >>;

    order<T extends OrderArgs = {}>(args?: Subset<T, OrderArgs>): CheckSelect<T, Prisma__OrderClient<Order | null >, Prisma__OrderClient<OrderGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * Throw an Error if a OrderItem can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OrderItem to fetch.
     * 
    **/
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * Throw an Error if a OrderItem can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OrderItem to fetch.
     * 
    **/
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderItemOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     * 
    **/
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     * 
    **/
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }


  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * Filter, which OrderItems to fetch.
     * 
    **/
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderItemOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     * 
    **/
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderItemScalarFieldEnum>
  }


  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * The data needed to create a OrderItem.
     * 
    **/
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }


  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs = {
    data: Enumerable<OrderItemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * The data needed to update a OrderItem.
     * 
    **/
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     * 
    **/
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs = {
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    where?: OrderItemWhereInput
  }


  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     * 
    **/
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     * 
    **/
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }


  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
    /**
     * Filter which OrderItem to delete.
     * 
    **/
    where: OrderItemWhereUniqueInput
  }


  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs = {
    where?: OrderItemWhereInput
  }


  /**
   * OrderItem without action
   */
  export type OrderItemArgs = {
    /**
     * Select specific fields to fetch from the OrderItem
     * 
    **/
    select?: OrderItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderItemInclude | null
  }



  /**
   * Model OrderPad
   */


  export type AggregateOrderPad = {
    _count: OrderPadCountAggregateOutputType | null
    count: OrderPadCountAggregateOutputType | null
    _avg: OrderPadAvgAggregateOutputType | null
    avg: OrderPadAvgAggregateOutputType | null
    _sum: OrderPadSumAggregateOutputType | null
    sum: OrderPadSumAggregateOutputType | null
    _min: OrderPadMinAggregateOutputType | null
    min: OrderPadMinAggregateOutputType | null
    _max: OrderPadMaxAggregateOutputType | null
    max: OrderPadMaxAggregateOutputType | null
  }

  export type OrderPadAvgAggregateOutputType = {
    block: number | null
    firstOrderId: number | null
    lastOrderId: number | null
  }

  export type OrderPadSumAggregateOutputType = {
    block: number | null
    firstOrderId: number | null
    lastOrderId: number | null
  }

  export type OrderPadMinAggregateOutputType = {
    id: string | null
    block: number | null
    firstOrderId: number | null
    lastOrderId: number | null
    used: boolean | null
    workDayId: string | null
    employeeId: string | null
  }

  export type OrderPadMaxAggregateOutputType = {
    id: string | null
    block: number | null
    firstOrderId: number | null
    lastOrderId: number | null
    used: boolean | null
    workDayId: string | null
    employeeId: string | null
  }

  export type OrderPadCountAggregateOutputType = {
    id: number
    block: number
    firstOrderId: number
    lastOrderId: number
    used: number
    workDayId: number
    employeeId: number
    _all: number
  }


  export type OrderPadAvgAggregateInputType = {
    block?: true
    firstOrderId?: true
    lastOrderId?: true
  }

  export type OrderPadSumAggregateInputType = {
    block?: true
    firstOrderId?: true
    lastOrderId?: true
  }

  export type OrderPadMinAggregateInputType = {
    id?: true
    block?: true
    firstOrderId?: true
    lastOrderId?: true
    used?: true
    workDayId?: true
    employeeId?: true
  }

  export type OrderPadMaxAggregateInputType = {
    id?: true
    block?: true
    firstOrderId?: true
    lastOrderId?: true
    used?: true
    workDayId?: true
    employeeId?: true
  }

  export type OrderPadCountAggregateInputType = {
    id?: true
    block?: true
    firstOrderId?: true
    lastOrderId?: true
    used?: true
    workDayId?: true
    employeeId?: true
    _all?: true
  }

  export type OrderPadAggregateArgs = {
    /**
     * Filter which OrderPad to aggregate.
     * 
    **/
    where?: OrderPadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderPads to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderPadOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: OrderPadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderPads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderPads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderPads
    **/
    _count?: true | OrderPadCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | OrderPadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderPadAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: OrderPadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderPadSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: OrderPadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderPadMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: OrderPadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderPadMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: OrderPadMaxAggregateInputType
  }

  export type GetOrderPadAggregateType<T extends OrderPadAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderPad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderPad[P]>
      : GetScalarType<T[P], AggregateOrderPad[P]>
  }


    
    
  export type OrderPadGroupByArgs = {
    where?: OrderPadWhereInput
    orderBy?: Enumerable<OrderPadOrderByInput>
    by: Array<OrderPadScalarFieldEnum>
    having?: OrderPadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderPadCountAggregateInputType | true
    _avg?: OrderPadAvgAggregateInputType
    _sum?: OrderPadSumAggregateInputType
    _min?: OrderPadMinAggregateInputType
    _max?: OrderPadMaxAggregateInputType
  }


  export type OrderPadGroupByOutputType = {
    id: string
    block: number
    firstOrderId: number
    lastOrderId: number | null
    used: boolean
    workDayId: string | null
    employeeId: string | null
    _count: OrderPadCountAggregateOutputType | null
    _avg: OrderPadAvgAggregateOutputType | null
    _sum: OrderPadSumAggregateOutputType | null
    _min: OrderPadMinAggregateOutputType | null
    _max: OrderPadMaxAggregateOutputType | null
  }

  type GetOrderPadGroupByPayload<T extends OrderPadGroupByArgs> = Promise<
    Array<
      PickArray<OrderPadGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof OrderPadGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], OrderPadGroupByOutputType[P]> 
            : GetScalarType<T[P], OrderPadGroupByOutputType[P]>
        }
      > 
    >


  export type OrderPadSelect = {
    id?: boolean
    block?: boolean
    firstOrderId?: boolean
    lastOrderId?: boolean
    used?: boolean
    workDayId?: boolean
    employeeId?: boolean
    employee?: boolean | EmployeeArgs
    workDay?: boolean | WorkDayArgs
  }

  export type OrderPadInclude = {
    employee?: boolean | EmployeeArgs
    workDay?: boolean | WorkDayArgs
  }

  export type OrderPadGetPayload<
    S extends boolean | null | undefined | OrderPadArgs,
    U = keyof S
      > = S extends true
        ? OrderPad
    : S extends undefined
    ? never
    : S extends OrderPadArgs | OrderPadFindManyArgs
    ?'include' extends U
    ? OrderPad  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'employee'
        ? EmployeeGetPayload<S['include'][P]> | null :
        P extends 'workDay'
        ? WorkDayGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OrderPad ?OrderPad [P]
  : 
          P extends 'employee'
        ? EmployeeGetPayload<S['select'][P]> | null :
        P extends 'workDay'
        ? WorkDayGetPayload<S['select'][P]> | null : never
  } 
    : OrderPad
  : OrderPad


  type OrderPadCountArgs = Merge<
    Omit<OrderPadFindManyArgs, 'select' | 'include'> & {
      select?: OrderPadCountAggregateInputType | true
    }
  >

  export interface OrderPadDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OrderPad that matches the filter.
     * @param {OrderPadFindUniqueArgs} args - Arguments to find a OrderPad
     * @example
     * // Get one OrderPad
     * const orderPad = await prisma.orderPad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderPadFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderPadFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OrderPad'> extends True ? CheckSelect<T, Prisma__OrderPadClient<OrderPad>, Prisma__OrderPadClient<OrderPadGetPayload<T>>> : CheckSelect<T, Prisma__OrderPadClient<OrderPad | null >, Prisma__OrderPadClient<OrderPadGetPayload<T> | null >>

    /**
     * Find the first OrderPad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPadFindFirstArgs} args - Arguments to find a OrderPad
     * @example
     * // Get one OrderPad
     * const orderPad = await prisma.orderPad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderPadFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderPadFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OrderPad'> extends True ? CheckSelect<T, Prisma__OrderPadClient<OrderPad>, Prisma__OrderPadClient<OrderPadGetPayload<T>>> : CheckSelect<T, Prisma__OrderPadClient<OrderPad | null >, Prisma__OrderPadClient<OrderPadGetPayload<T> | null >>

    /**
     * Find zero or more OrderPads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderPads
     * const orderPads = await prisma.orderPad.findMany()
     * 
     * // Get first 10 OrderPads
     * const orderPads = await prisma.orderPad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderPadWithIdOnly = await prisma.orderPad.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderPadFindManyArgs>(
      args?: SelectSubset<T, OrderPadFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OrderPad>>, PrismaPromise<Array<OrderPadGetPayload<T>>>>

    /**
     * Create a OrderPad.
     * @param {OrderPadCreateArgs} args - Arguments to create a OrderPad.
     * @example
     * // Create one OrderPad
     * const OrderPad = await prisma.orderPad.create({
     *   data: {
     *     // ... data to create a OrderPad
     *   }
     * })
     * 
    **/
    create<T extends OrderPadCreateArgs>(
      args: SelectSubset<T, OrderPadCreateArgs>
    ): CheckSelect<T, Prisma__OrderPadClient<OrderPad>, Prisma__OrderPadClient<OrderPadGetPayload<T>>>

    /**
     * Create many OrderPads.
     *     @param {OrderPadCreateManyArgs} args - Arguments to create many OrderPads.
     *     @example
     *     // Create many OrderPads
     *     const orderPad = await prisma.orderPad.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderPadCreateManyArgs>(
      args?: SelectSubset<T, OrderPadCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OrderPad.
     * @param {OrderPadDeleteArgs} args - Arguments to delete one OrderPad.
     * @example
     * // Delete one OrderPad
     * const OrderPad = await prisma.orderPad.delete({
     *   where: {
     *     // ... filter to delete one OrderPad
     *   }
     * })
     * 
    **/
    delete<T extends OrderPadDeleteArgs>(
      args: SelectSubset<T, OrderPadDeleteArgs>
    ): CheckSelect<T, Prisma__OrderPadClient<OrderPad>, Prisma__OrderPadClient<OrderPadGetPayload<T>>>

    /**
     * Update one OrderPad.
     * @param {OrderPadUpdateArgs} args - Arguments to update one OrderPad.
     * @example
     * // Update one OrderPad
     * const orderPad = await prisma.orderPad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderPadUpdateArgs>(
      args: SelectSubset<T, OrderPadUpdateArgs>
    ): CheckSelect<T, Prisma__OrderPadClient<OrderPad>, Prisma__OrderPadClient<OrderPadGetPayload<T>>>

    /**
     * Delete zero or more OrderPads.
     * @param {OrderPadDeleteManyArgs} args - Arguments to filter OrderPads to delete.
     * @example
     * // Delete a few OrderPads
     * const { count } = await prisma.orderPad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderPadDeleteManyArgs>(
      args?: SelectSubset<T, OrderPadDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderPads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderPads
     * const orderPad = await prisma.orderPad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderPadUpdateManyArgs>(
      args: SelectSubset<T, OrderPadUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderPad.
     * @param {OrderPadUpsertArgs} args - Arguments to update or create a OrderPad.
     * @example
     * // Update or create a OrderPad
     * const orderPad = await prisma.orderPad.upsert({
     *   create: {
     *     // ... data to create a OrderPad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderPad we want to update
     *   }
     * })
    **/
    upsert<T extends OrderPadUpsertArgs>(
      args: SelectSubset<T, OrderPadUpsertArgs>
    ): CheckSelect<T, Prisma__OrderPadClient<OrderPad>, Prisma__OrderPadClient<OrderPadGetPayload<T>>>

    /**
     * Count the number of OrderPads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPadCountArgs} args - Arguments to filter OrderPads to count.
     * @example
     * // Count the number of OrderPads
     * const count = await prisma.orderPad.count({
     *   where: {
     *     // ... the filter for the OrderPads we want to count
     *   }
     * })
    **/
    count<T extends OrderPadCountArgs>(
      args?: Subset<T, OrderPadCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderPadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderPad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderPadAggregateArgs>(args: Subset<T, OrderPadAggregateArgs>): PrismaPromise<GetOrderPadAggregateType<T>>

    /**
     * Group by OrderPad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderPadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderPadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderPadGroupByArgs['orderBy'] }
        : { orderBy?: OrderPadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderPadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderPadGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderPad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderPadClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    employee<T extends EmployeeArgs = {}>(args?: Subset<T, EmployeeArgs>): CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>;

    workDay<T extends WorkDayArgs = {}>(args?: Subset<T, WorkDayArgs>): CheckSelect<T, Prisma__WorkDayClient<WorkDay | null >, Prisma__WorkDayClient<WorkDayGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OrderPad findUnique
   */
  export type OrderPadFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OrderPad
     * 
    **/
    select?: OrderPadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderPadInclude | null
    /**
     * Throw an Error if a OrderPad can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OrderPad to fetch.
     * 
    **/
    where: OrderPadWhereUniqueInput
  }


  /**
   * OrderPad findFirst
   */
  export type OrderPadFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OrderPad
     * 
    **/
    select?: OrderPadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderPadInclude | null
    /**
     * Throw an Error if a OrderPad can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OrderPad to fetch.
     * 
    **/
    where?: OrderPadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderPads to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderPadOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderPads.
     * 
    **/
    cursor?: OrderPadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderPads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderPads.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderPads.
     * 
    **/
    distinct?: Enumerable<OrderPadScalarFieldEnum>
  }


  /**
   * OrderPad findMany
   */
  export type OrderPadFindManyArgs = {
    /**
     * Select specific fields to fetch from the OrderPad
     * 
    **/
    select?: OrderPadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderPadInclude | null
    /**
     * Filter, which OrderPads to fetch.
     * 
    **/
    where?: OrderPadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderPads to fetch.
     * 
    **/
    orderBy?: Enumerable<OrderPadOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderPads.
     * 
    **/
    cursor?: OrderPadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderPads from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderPads.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrderPadScalarFieldEnum>
  }


  /**
   * OrderPad create
   */
  export type OrderPadCreateArgs = {
    /**
     * Select specific fields to fetch from the OrderPad
     * 
    **/
    select?: OrderPadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderPadInclude | null
    /**
     * The data needed to create a OrderPad.
     * 
    **/
    data: XOR<OrderPadCreateInput, OrderPadUncheckedCreateInput>
  }


  /**
   * OrderPad createMany
   */
  export type OrderPadCreateManyArgs = {
    data: Enumerable<OrderPadCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OrderPad update
   */
  export type OrderPadUpdateArgs = {
    /**
     * Select specific fields to fetch from the OrderPad
     * 
    **/
    select?: OrderPadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderPadInclude | null
    /**
     * The data needed to update a OrderPad.
     * 
    **/
    data: XOR<OrderPadUpdateInput, OrderPadUncheckedUpdateInput>
    /**
     * Choose, which OrderPad to update.
     * 
    **/
    where: OrderPadWhereUniqueInput
  }


  /**
   * OrderPad updateMany
   */
  export type OrderPadUpdateManyArgs = {
    data: XOR<OrderPadUpdateManyMutationInput, OrderPadUncheckedUpdateManyInput>
    where?: OrderPadWhereInput
  }


  /**
   * OrderPad upsert
   */
  export type OrderPadUpsertArgs = {
    /**
     * Select specific fields to fetch from the OrderPad
     * 
    **/
    select?: OrderPadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderPadInclude | null
    /**
     * The filter to search for the OrderPad to update in case it exists.
     * 
    **/
    where: OrderPadWhereUniqueInput
    /**
     * In case the OrderPad found by the `where` argument doesn't exist, create a new OrderPad with this data.
     * 
    **/
    create: XOR<OrderPadCreateInput, OrderPadUncheckedCreateInput>
    /**
     * In case the OrderPad was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<OrderPadUpdateInput, OrderPadUncheckedUpdateInput>
  }


  /**
   * OrderPad delete
   */
  export type OrderPadDeleteArgs = {
    /**
     * Select specific fields to fetch from the OrderPad
     * 
    **/
    select?: OrderPadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderPadInclude | null
    /**
     * Filter which OrderPad to delete.
     * 
    **/
    where: OrderPadWhereUniqueInput
  }


  /**
   * OrderPad deleteMany
   */
  export type OrderPadDeleteManyArgs = {
    where?: OrderPadWhereInput
  }


  /**
   * OrderPad without action
   */
  export type OrderPadArgs = {
    /**
     * Select specific fields to fetch from the OrderPad
     * 
    **/
    select?: OrderPadSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: OrderPadInclude | null
  }



  /**
   * Model Payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
    max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    value: number | null
  }

  export type PaymentSumAggregateOutputType = {
    value: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    value: number | null
    paymentType: string | null
    paymentTypeOption: string | null
    isActive: boolean | null
    expenseId: string | null
    checkDataId: string | null
    billId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    value: number | null
    paymentType: string | null
    paymentTypeOption: string | null
    isActive: boolean | null
    expenseId: string | null
    checkDataId: string | null
    billId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    createdAt: number
    value: number
    paymentType: number
    paymentTypeOption: number
    isActive: number
    expenseId: number
    checkDataId: number
    billId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    value?: true
  }

  export type PaymentSumAggregateInputType = {
    value?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    createdAt?: true
    value?: true
    paymentType?: true
    paymentTypeOption?: true
    isActive?: true
    expenseId?: true
    checkDataId?: true
    billId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    value?: true
    paymentType?: true
    paymentTypeOption?: true
    isActive?: true
    expenseId?: true
    checkDataId?: true
    billId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    createdAt?: true
    value?: true
    paymentType?: true
    paymentTypeOption?: true
    isActive?: true
    expenseId?: true
    checkDataId?: true
    billId?: true
    _all?: true
  }

  export type PaymentAggregateArgs = {
    /**
     * Filter which Payment to aggregate.
     * 
    **/
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }


    
    
  export type PaymentGroupByArgs = {
    where?: PaymentWhereInput
    orderBy?: Enumerable<PaymentOrderByInput>
    by: Array<PaymentScalarFieldEnum>
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    id: string
    createdAt: Date
    value: number
    paymentType: string
    paymentTypeOption: string | null
    isActive: boolean
    expenseId: string | null
    checkDataId: string | null
    billId: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Promise<
    Array<
      PickArray<PaymentGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], PaymentGroupByOutputType[P]> 
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      > 
    >


  export type PaymentSelect = {
    id?: boolean
    createdAt?: boolean
    value?: boolean
    paymentType?: boolean
    paymentTypeOption?: boolean
    isActive?: boolean
    expenseId?: boolean
    checkDataId?: boolean
    billId?: boolean
    bill?: boolean | BillArgs
    checkData?: boolean | CheckDataArgs
    expense?: boolean | ExpenseArgs
  }

  export type PaymentInclude = {
    bill?: boolean | BillArgs
    checkData?: boolean | CheckDataArgs
    expense?: boolean | ExpenseArgs
  }

  export type PaymentGetPayload<
    S extends boolean | null | undefined | PaymentArgs,
    U = keyof S
      > = S extends true
        ? Payment
    : S extends undefined
    ? never
    : S extends PaymentArgs | PaymentFindManyArgs
    ?'include' extends U
    ? Payment  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'bill'
        ? BillGetPayload<S['include'][P]> | null :
        P extends 'checkData'
        ? CheckDataGetPayload<S['include'][P]> | null :
        P extends 'expense'
        ? ExpenseGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Payment ?Payment [P]
  : 
          P extends 'bill'
        ? BillGetPayload<S['select'][P]> | null :
        P extends 'checkData'
        ? CheckDataGetPayload<S['select'][P]> | null :
        P extends 'expense'
        ? ExpenseGetPayload<S['select'][P]> | null : never
  } 
    : Payment
  : Payment


  type PaymentCountArgs = Merge<
    Omit<PaymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }
  >

  export interface PaymentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PaymentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Payment'> extends True ? CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>> : CheckSelect<T, Prisma__PaymentClient<Payment | null >, Prisma__PaymentClient<PaymentGetPayload<T> | null >>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PaymentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Payment'> extends True ? CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>> : CheckSelect<T, Prisma__PaymentClient<Payment | null >, Prisma__PaymentClient<PaymentGetPayload<T> | null >>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs>(
      args?: SelectSubset<T, PaymentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Payment>>, PrismaPromise<Array<PaymentGetPayload<T>>>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs>(
      args: SelectSubset<T, PaymentCreateArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs>(
      args?: SelectSubset<T, PaymentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs>(
      args: SelectSubset<T, PaymentDeleteArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs>(
      args: SelectSubset<T, PaymentUpdateArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs>(
      args?: SelectSubset<T, PaymentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs>(
      args: SelectSubset<T, PaymentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs>(
      args: SelectSubset<T, PaymentUpsertArgs>
    ): CheckSelect<T, Prisma__PaymentClient<Payment>, Prisma__PaymentClient<PaymentGetPayload<T>>>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    bill<T extends BillArgs = {}>(args?: Subset<T, BillArgs>): CheckSelect<T, Prisma__BillClient<Bill | null >, Prisma__BillClient<BillGetPayload<T> | null >>;

    checkData<T extends CheckDataArgs = {}>(args?: Subset<T, CheckDataArgs>): CheckSelect<T, Prisma__CheckDataClient<CheckData | null >, Prisma__CheckDataClient<CheckDataGetPayload<T> | null >>;

    expense<T extends ExpenseArgs = {}>(args?: Subset<T, ExpenseArgs>): CheckSelect<T, Prisma__ExpenseClient<Expense | null >, Prisma__ExpenseClient<ExpenseGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * Throw an Error if a Payment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Payment to fetch.
     * 
    **/
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * Throw an Error if a Payment can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Payment to fetch.
     * 
    **/
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     * 
    **/
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     * 
    **/
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * Filter, which Payments to fetch.
     * 
    **/
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     * 
    **/
    orderBy?: Enumerable<PaymentOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     * 
    **/
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * Payment create
   */
  export type PaymentCreateArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * The data needed to create a Payment.
     * 
    **/
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }


  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs = {
    data: Enumerable<PaymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Payment update
   */
  export type PaymentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * The data needed to update a Payment.
     * 
    **/
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     * 
    **/
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs = {
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    where?: PaymentWhereInput
  }


  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * The filter to search for the Payment to update in case it exists.
     * 
    **/
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     * 
    **/
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }


  /**
   * Payment delete
   */
  export type PaymentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
    /**
     * Filter which Payment to delete.
     * 
    **/
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs = {
    where?: PaymentWhereInput
  }


  /**
   * Payment without action
   */
  export type PaymentArgs = {
    /**
     * Select specific fields to fetch from the Payment
     * 
    **/
    select?: PaymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PaymentInclude | null
  }



  /**
   * Model Permission
   */


  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
    max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    role: UserRole | null
    userId: string | null
    establishmentId: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    role: UserRole | null
    userId: string | null
    establishmentId: string | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    createdAt: number
    role: number
    userId: number
    establishmentId: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    createdAt?: true
    role?: true
    userId?: true
    establishmentId?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    role?: true
    userId?: true
    establishmentId?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    createdAt?: true
    role?: true
    userId?: true
    establishmentId?: true
    _all?: true
  }

  export type PermissionAggregateArgs = {
    /**
     * Filter which Permission to aggregate.
     * 
    **/
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermissionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }


    
    
  export type PermissionGroupByArgs = {
    where?: PermissionWhereInput
    orderBy?: Enumerable<PermissionOrderByInput>
    by: Array<PermissionScalarFieldEnum>
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }


  export type PermissionGroupByOutputType = {
    id: string
    createdAt: Date
    role: UserRole
    userId: string | null
    establishmentId: string | null
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Promise<
    Array<
      PickArray<PermissionGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], PermissionGroupByOutputType[P]> 
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      > 
    >


  export type PermissionSelect = {
    id?: boolean
    createdAt?: boolean
    role?: boolean
    userId?: boolean
    establishmentId?: boolean
    establishment?: boolean | EstablishmentArgs
    user?: boolean | UserArgs
  }

  export type PermissionInclude = {
    establishment?: boolean | EstablishmentArgs
    user?: boolean | UserArgs
  }

  export type PermissionGetPayload<
    S extends boolean | null | undefined | PermissionArgs,
    U = keyof S
      > = S extends true
        ? Permission
    : S extends undefined
    ? never
    : S extends PermissionArgs | PermissionFindManyArgs
    ?'include' extends U
    ? Permission  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['include'][P]> | null :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Permission ?Permission [P]
  : 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['select'][P]> | null :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> | null : never
  } 
    : Permission
  : Permission


  type PermissionCountArgs = Merge<
    Omit<PermissionFindManyArgs, 'select' | 'include'> & {
      select?: PermissionCountAggregateInputType | true
    }
  >

  export interface PermissionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PermissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PermissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Permission'> extends True ? CheckSelect<T, Prisma__PermissionClient<Permission>, Prisma__PermissionClient<PermissionGetPayload<T>>> : CheckSelect<T, Prisma__PermissionClient<Permission | null >, Prisma__PermissionClient<PermissionGetPayload<T> | null >>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PermissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PermissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Permission'> extends True ? CheckSelect<T, Prisma__PermissionClient<Permission>, Prisma__PermissionClient<PermissionGetPayload<T>>> : CheckSelect<T, Prisma__PermissionClient<Permission | null >, Prisma__PermissionClient<PermissionGetPayload<T> | null >>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PermissionFindManyArgs>(
      args?: SelectSubset<T, PermissionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Permission>>, PrismaPromise<Array<PermissionGetPayload<T>>>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
    **/
    create<T extends PermissionCreateArgs>(
      args: SelectSubset<T, PermissionCreateArgs>
    ): CheckSelect<T, Prisma__PermissionClient<Permission>, Prisma__PermissionClient<PermissionGetPayload<T>>>

    /**
     * Create many Permissions.
     *     @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     *     @example
     *     // Create many Permissions
     *     const permission = await prisma.permission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PermissionCreateManyArgs>(
      args?: SelectSubset<T, PermissionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
    **/
    delete<T extends PermissionDeleteArgs>(
      args: SelectSubset<T, PermissionDeleteArgs>
    ): CheckSelect<T, Prisma__PermissionClient<Permission>, Prisma__PermissionClient<PermissionGetPayload<T>>>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PermissionUpdateArgs>(
      args: SelectSubset<T, PermissionUpdateArgs>
    ): CheckSelect<T, Prisma__PermissionClient<Permission>, Prisma__PermissionClient<PermissionGetPayload<T>>>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PermissionDeleteManyArgs>(
      args?: SelectSubset<T, PermissionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PermissionUpdateManyArgs>(
      args: SelectSubset<T, PermissionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
    **/
    upsert<T extends PermissionUpsertArgs>(
      args: SelectSubset<T, PermissionUpsertArgs>
    ): CheckSelect<T, Prisma__PermissionClient<Permission>, Prisma__PermissionClient<PermissionGetPayload<T>>>

    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PermissionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    establishment<T extends EstablishmentArgs = {}>(args?: Subset<T, EstablishmentArgs>): CheckSelect<T, Prisma__EstablishmentClient<Establishment | null >, Prisma__EstablishmentClient<EstablishmentGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Permission
     * 
    **/
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionInclude | null
    /**
     * Throw an Error if a Permission can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Permission to fetch.
     * 
    **/
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Permission
     * 
    **/
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionInclude | null
    /**
     * Throw an Error if a Permission can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Permission to fetch.
     * 
    **/
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermissionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     * 
    **/
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     * 
    **/
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Permission
     * 
    **/
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionInclude | null
    /**
     * Filter, which Permissions to fetch.
     * 
    **/
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     * 
    **/
    orderBy?: Enumerable<PermissionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     * 
    **/
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * Permission create
   */
  export type PermissionCreateArgs = {
    /**
     * Select specific fields to fetch from the Permission
     * 
    **/
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionInclude | null
    /**
     * The data needed to create a Permission.
     * 
    **/
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }


  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs = {
    data: Enumerable<PermissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Permission update
   */
  export type PermissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Permission
     * 
    **/
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionInclude | null
    /**
     * The data needed to update a Permission.
     * 
    **/
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     * 
    **/
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs = {
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    where?: PermissionWhereInput
  }


  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Permission
     * 
    **/
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionInclude | null
    /**
     * The filter to search for the Permission to update in case it exists.
     * 
    **/
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     * 
    **/
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }


  /**
   * Permission delete
   */
  export type PermissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Permission
     * 
    **/
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionInclude | null
    /**
     * Filter which Permission to delete.
     * 
    **/
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs = {
    where?: PermissionWhereInput
  }


  /**
   * Permission without action
   */
  export type PermissionArgs = {
    /**
     * Select specific fields to fetch from the Permission
     * 
    **/
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PermissionInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
    max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    supplier: string | null
    brand: string | null
    unit: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    supplier: string | null
    brand: string | null
    unit: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    category: number
    supplier: number
    brand: number
    unit: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    supplier?: true
    brand?: true
    unit?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    supplier?: true
    brand?: true
    unit?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    supplier?: true
    brand?: true
    unit?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }


    
    
  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: string
    name: string
    category: string
    supplier: string
    brand: string | null
    unit: string
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Promise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ProductGroupByOutputType[P]> 
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      > 
    >


  export type ProductSelect = {
    id?: boolean
    name?: boolean
    category?: boolean
    supplier?: boolean
    brand?: boolean
    unit?: boolean
    ExpenseItem?: boolean | ExpenseItemFindManyArgs
  }

  export type ProductInclude = {
    ExpenseItem?: boolean | ExpenseItemFindManyArgs
  }

  export type ProductGetPayload<
    S extends boolean | null | undefined | ProductArgs,
    U = keyof S
      > = S extends true
        ? Product
    : S extends undefined
    ? never
    : S extends ProductArgs | ProductFindManyArgs
    ?'include' extends U
    ? Product  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ExpenseItem'
        ? Array < ExpenseItemGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Product ?Product [P]
  : 
          P extends 'ExpenseItem'
        ? Array < ExpenseItemGetPayload<S['select'][P]>>  : never
  } 
    : Product
  : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ExpenseItem<T extends ExpenseItemFindManyArgs = {}>(args?: Subset<T, ExpenseItemFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ExpenseItem>>, PrismaPromise<Array<ExpenseItemGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    where?: ProductWhereInput
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Model Table
   */


  export type AggregateTable = {
    _count: TableCountAggregateOutputType | null
    count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
    max: TableMaxAggregateOutputType | null
  }

  export type TableAvgAggregateOutputType = {
    tableNumber: number | null
  }

  export type TableSumAggregateOutputType = {
    tableNumber: number | null
  }

  export type TableMinAggregateOutputType = {
    id: string | null
    tableNumber: number | null
    establishmentId: string | null
  }

  export type TableMaxAggregateOutputType = {
    id: string | null
    tableNumber: number | null
    establishmentId: string | null
  }

  export type TableCountAggregateOutputType = {
    id: number
    tableNumber: number
    establishmentId: number
    _all: number
  }


  export type TableAvgAggregateInputType = {
    tableNumber?: true
  }

  export type TableSumAggregateInputType = {
    tableNumber?: true
  }

  export type TableMinAggregateInputType = {
    id?: true
    tableNumber?: true
    establishmentId?: true
  }

  export type TableMaxAggregateInputType = {
    id?: true
    tableNumber?: true
    establishmentId?: true
  }

  export type TableCountAggregateInputType = {
    id?: true
    tableNumber?: true
    establishmentId?: true
    _all?: true
  }

  export type TableAggregateArgs = {
    /**
     * Filter which Table to aggregate.
     * 
    **/
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     * 
    **/
    orderBy?: Enumerable<TableOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tables
    **/
    _count?: true | TableCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TableAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: TableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TableSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: TableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TableMaxAggregateInputType
  }

  export type GetTableAggregateType<T extends TableAggregateArgs> = {
        [P in keyof T & keyof AggregateTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable[P]>
      : GetScalarType<T[P], AggregateTable[P]>
  }


    
    
  export type TableGroupByArgs = {
    where?: TableWhereInput
    orderBy?: Enumerable<TableOrderByInput>
    by: Array<TableScalarFieldEnum>
    having?: TableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableCountAggregateInputType | true
    _avg?: TableAvgAggregateInputType
    _sum?: TableSumAggregateInputType
    _min?: TableMinAggregateInputType
    _max?: TableMaxAggregateInputType
  }


  export type TableGroupByOutputType = {
    id: string
    tableNumber: number
    establishmentId: string | null
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  type GetTableGroupByPayload<T extends TableGroupByArgs> = Promise<
    Array<
      PickArray<TableGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TableGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TableGroupByOutputType[P]> 
            : GetScalarType<T[P], TableGroupByOutputType[P]>
        }
      > 
    >


  export type TableSelect = {
    id?: boolean
    tableNumber?: boolean
    establishmentId?: boolean
    establishment?: boolean | EstablishmentArgs
    data?: boolean | TableDataFindManyArgs
  }

  export type TableInclude = {
    establishment?: boolean | EstablishmentArgs
    data?: boolean | TableDataFindManyArgs
  }

  export type TableGetPayload<
    S extends boolean | null | undefined | TableArgs,
    U = keyof S
      > = S extends true
        ? Table
    : S extends undefined
    ? never
    : S extends TableArgs | TableFindManyArgs
    ?'include' extends U
    ? Table  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['include'][P]> | null :
        P extends 'data'
        ? Array < TableDataGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Table ?Table [P]
  : 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['select'][P]> | null :
        P extends 'data'
        ? Array < TableDataGetPayload<S['select'][P]>>  : never
  } 
    : Table
  : Table


  type TableCountArgs = Merge<
    Omit<TableFindManyArgs, 'select' | 'include'> & {
      select?: TableCountAggregateInputType | true
    }
  >

  export interface TableDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Table that matches the filter.
     * @param {TableFindUniqueArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TableFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TableFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Table'> extends True ? CheckSelect<T, Prisma__TableClient<Table>, Prisma__TableClient<TableGetPayload<T>>> : CheckSelect<T, Prisma__TableClient<Table | null >, Prisma__TableClient<TableGetPayload<T> | null >>

    /**
     * Find the first Table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TableFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TableFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Table'> extends True ? CheckSelect<T, Prisma__TableClient<Table>, Prisma__TableClient<TableGetPayload<T>>> : CheckSelect<T, Prisma__TableClient<Table | null >, Prisma__TableClient<TableGetPayload<T> | null >>

    /**
     * Find zero or more Tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables
     * const tables = await prisma.table.findMany()
     * 
     * // Get first 10 Tables
     * const tables = await prisma.table.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableWithIdOnly = await prisma.table.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TableFindManyArgs>(
      args?: SelectSubset<T, TableFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Table>>, PrismaPromise<Array<TableGetPayload<T>>>>

    /**
     * Create a Table.
     * @param {TableCreateArgs} args - Arguments to create a Table.
     * @example
     * // Create one Table
     * const Table = await prisma.table.create({
     *   data: {
     *     // ... data to create a Table
     *   }
     * })
     * 
    **/
    create<T extends TableCreateArgs>(
      args: SelectSubset<T, TableCreateArgs>
    ): CheckSelect<T, Prisma__TableClient<Table>, Prisma__TableClient<TableGetPayload<T>>>

    /**
     * Create many Tables.
     *     @param {TableCreateManyArgs} args - Arguments to create many Tables.
     *     @example
     *     // Create many Tables
     *     const table = await prisma.table.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TableCreateManyArgs>(
      args?: SelectSubset<T, TableCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Table.
     * @param {TableDeleteArgs} args - Arguments to delete one Table.
     * @example
     * // Delete one Table
     * const Table = await prisma.table.delete({
     *   where: {
     *     // ... filter to delete one Table
     *   }
     * })
     * 
    **/
    delete<T extends TableDeleteArgs>(
      args: SelectSubset<T, TableDeleteArgs>
    ): CheckSelect<T, Prisma__TableClient<Table>, Prisma__TableClient<TableGetPayload<T>>>

    /**
     * Update one Table.
     * @param {TableUpdateArgs} args - Arguments to update one Table.
     * @example
     * // Update one Table
     * const table = await prisma.table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TableUpdateArgs>(
      args: SelectSubset<T, TableUpdateArgs>
    ): CheckSelect<T, Prisma__TableClient<Table>, Prisma__TableClient<TableGetPayload<T>>>

    /**
     * Delete zero or more Tables.
     * @param {TableDeleteManyArgs} args - Arguments to filter Tables to delete.
     * @example
     * // Delete a few Tables
     * const { count } = await prisma.table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TableDeleteManyArgs>(
      args?: SelectSubset<T, TableDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TableUpdateManyArgs>(
      args: SelectSubset<T, TableUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Table.
     * @param {TableUpsertArgs} args - Arguments to update or create a Table.
     * @example
     * // Update or create a Table
     * const table = await prisma.table.upsert({
     *   create: {
     *     // ... data to create a Table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table we want to update
     *   }
     * })
    **/
    upsert<T extends TableUpsertArgs>(
      args: SelectSubset<T, TableUpsertArgs>
    ): CheckSelect<T, Prisma__TableClient<Table>, Prisma__TableClient<TableGetPayload<T>>>

    /**
     * Count the number of Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableCountArgs} args - Arguments to filter Tables to count.
     * @example
     * // Count the number of Tables
     * const count = await prisma.table.count({
     *   where: {
     *     // ... the filter for the Tables we want to count
     *   }
     * })
    **/
    count<T extends TableCountArgs>(
      args?: Subset<T, TableCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableAggregateArgs>(args: Subset<T, TableAggregateArgs>): PrismaPromise<GetTableAggregateType<T>>

    /**
     * Group by Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableGroupByArgs['orderBy'] }
        : { orderBy?: TableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TableClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    establishment<T extends EstablishmentArgs = {}>(args?: Subset<T, EstablishmentArgs>): CheckSelect<T, Prisma__EstablishmentClient<Establishment | null >, Prisma__EstablishmentClient<EstablishmentGetPayload<T> | null >>;

    data<T extends TableDataFindManyArgs = {}>(args?: Subset<T, TableDataFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TableData>>, PrismaPromise<Array<TableDataGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Table findUnique
   */
  export type TableFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Table
     * 
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableInclude | null
    /**
     * Throw an Error if a Table can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Table to fetch.
     * 
    **/
    where: TableWhereUniqueInput
  }


  /**
   * Table findFirst
   */
  export type TableFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Table
     * 
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableInclude | null
    /**
     * Throw an Error if a Table can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Table to fetch.
     * 
    **/
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     * 
    **/
    orderBy?: Enumerable<TableOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     * 
    **/
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     * 
    **/
    distinct?: Enumerable<TableScalarFieldEnum>
  }


  /**
   * Table findMany
   */
  export type TableFindManyArgs = {
    /**
     * Select specific fields to fetch from the Table
     * 
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableInclude | null
    /**
     * Filter, which Tables to fetch.
     * 
    **/
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     * 
    **/
    orderBy?: Enumerable<TableOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tables.
     * 
    **/
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TableScalarFieldEnum>
  }


  /**
   * Table create
   */
  export type TableCreateArgs = {
    /**
     * Select specific fields to fetch from the Table
     * 
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableInclude | null
    /**
     * The data needed to create a Table.
     * 
    **/
    data: XOR<TableCreateInput, TableUncheckedCreateInput>
  }


  /**
   * Table createMany
   */
  export type TableCreateManyArgs = {
    data: Enumerable<TableCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Table update
   */
  export type TableUpdateArgs = {
    /**
     * Select specific fields to fetch from the Table
     * 
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableInclude | null
    /**
     * The data needed to update a Table.
     * 
    **/
    data: XOR<TableUpdateInput, TableUncheckedUpdateInput>
    /**
     * Choose, which Table to update.
     * 
    **/
    where: TableWhereUniqueInput
  }


  /**
   * Table updateMany
   */
  export type TableUpdateManyArgs = {
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyInput>
    where?: TableWhereInput
  }


  /**
   * Table upsert
   */
  export type TableUpsertArgs = {
    /**
     * Select specific fields to fetch from the Table
     * 
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableInclude | null
    /**
     * The filter to search for the Table to update in case it exists.
     * 
    **/
    where: TableWhereUniqueInput
    /**
     * In case the Table found by the `where` argument doesn't exist, create a new Table with this data.
     * 
    **/
    create: XOR<TableCreateInput, TableUncheckedCreateInput>
    /**
     * In case the Table was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TableUpdateInput, TableUncheckedUpdateInput>
  }


  /**
   * Table delete
   */
  export type TableDeleteArgs = {
    /**
     * Select specific fields to fetch from the Table
     * 
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableInclude | null
    /**
     * Filter which Table to delete.
     * 
    **/
    where: TableWhereUniqueInput
  }


  /**
   * Table deleteMany
   */
  export type TableDeleteManyArgs = {
    where?: TableWhereInput
  }


  /**
   * Table without action
   */
  export type TableArgs = {
    /**
     * Select specific fields to fetch from the Table
     * 
    **/
    select?: TableSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableInclude | null
  }



  /**
   * Model TableData
   */


  export type AggregateTableData = {
    _count: TableDataCountAggregateOutputType | null
    count: TableDataCountAggregateOutputType | null
    _avg: TableDataAvgAggregateOutputType | null
    avg: TableDataAvgAggregateOutputType | null
    _sum: TableDataSumAggregateOutputType | null
    sum: TableDataSumAggregateOutputType | null
    _min: TableDataMinAggregateOutputType | null
    min: TableDataMinAggregateOutputType | null
    _max: TableDataMaxAggregateOutputType | null
    max: TableDataMaxAggregateOutputType | null
  }

  export type TableDataAvgAggregateOutputType = {
    totalOccupations: number | null
  }

  export type TableDataSumAggregateOutputType = {
    totalOccupations: number | null
  }

  export type TableDataMinAggregateOutputType = {
    id: string | null
    totalOccupations: number | null
    workDayId: string | null
    tableId: string | null
    waiterId: string | null
  }

  export type TableDataMaxAggregateOutputType = {
    id: string | null
    totalOccupations: number | null
    workDayId: string | null
    tableId: string | null
    waiterId: string | null
  }

  export type TableDataCountAggregateOutputType = {
    id: number
    totalOccupations: number
    workDayId: number
    tableId: number
    waiterId: number
    _all: number
  }


  export type TableDataAvgAggregateInputType = {
    totalOccupations?: true
  }

  export type TableDataSumAggregateInputType = {
    totalOccupations?: true
  }

  export type TableDataMinAggregateInputType = {
    id?: true
    totalOccupations?: true
    workDayId?: true
    tableId?: true
    waiterId?: true
  }

  export type TableDataMaxAggregateInputType = {
    id?: true
    totalOccupations?: true
    workDayId?: true
    tableId?: true
    waiterId?: true
  }

  export type TableDataCountAggregateInputType = {
    id?: true
    totalOccupations?: true
    workDayId?: true
    tableId?: true
    waiterId?: true
    _all?: true
  }

  export type TableDataAggregateArgs = {
    /**
     * Filter which TableData to aggregate.
     * 
    **/
    where?: TableDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableData to fetch.
     * 
    **/
    orderBy?: Enumerable<TableDataOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TableDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableData from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableData.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TableData
    **/
    _count?: true | TableDataCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | TableDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TableDataAvgAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_avg`
    **/
    avg?: TableDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TableDataSumAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_sum`
    **/
    sum?: TableDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableDataMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: TableDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableDataMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: TableDataMaxAggregateInputType
  }

  export type GetTableDataAggregateType<T extends TableDataAggregateArgs> = {
        [P in keyof T & keyof AggregateTableData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTableData[P]>
      : GetScalarType<T[P], AggregateTableData[P]>
  }


    
    
  export type TableDataGroupByArgs = {
    where?: TableDataWhereInput
    orderBy?: Enumerable<TableDataOrderByInput>
    by: Array<TableDataScalarFieldEnum>
    having?: TableDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableDataCountAggregateInputType | true
    _avg?: TableDataAvgAggregateInputType
    _sum?: TableDataSumAggregateInputType
    _min?: TableDataMinAggregateInputType
    _max?: TableDataMaxAggregateInputType
  }


  export type TableDataGroupByOutputType = {
    id: string
    totalOccupations: number
    workDayId: string | null
    tableId: string | null
    waiterId: string | null
    _count: TableDataCountAggregateOutputType | null
    _avg: TableDataAvgAggregateOutputType | null
    _sum: TableDataSumAggregateOutputType | null
    _min: TableDataMinAggregateOutputType | null
    _max: TableDataMaxAggregateOutputType | null
  }

  type GetTableDataGroupByPayload<T extends TableDataGroupByArgs> = Promise<
    Array<
      PickArray<TableDataGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof TableDataGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], TableDataGroupByOutputType[P]> 
            : GetScalarType<T[P], TableDataGroupByOutputType[P]>
        }
      > 
    >


  export type TableDataSelect = {
    id?: boolean
    totalOccupations?: boolean
    workDayId?: boolean
    tableId?: boolean
    waiterId?: boolean
    table?: boolean | TableArgs
    waiter?: boolean | EmployeeArgs
    workDay?: boolean | WorkDayArgs
    bills?: boolean | BillFindManyArgs
  }

  export type TableDataInclude = {
    table?: boolean | TableArgs
    waiter?: boolean | EmployeeArgs
    workDay?: boolean | WorkDayArgs
    bills?: boolean | BillFindManyArgs
  }

  export type TableDataGetPayload<
    S extends boolean | null | undefined | TableDataArgs,
    U = keyof S
      > = S extends true
        ? TableData
    : S extends undefined
    ? never
    : S extends TableDataArgs | TableDataFindManyArgs
    ?'include' extends U
    ? TableData  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'table'
        ? TableGetPayload<S['include'][P]> | null :
        P extends 'waiter'
        ? EmployeeGetPayload<S['include'][P]> | null :
        P extends 'workDay'
        ? WorkDayGetPayload<S['include'][P]> | null :
        P extends 'bills'
        ? Array < BillGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof TableData ?TableData [P]
  : 
          P extends 'table'
        ? TableGetPayload<S['select'][P]> | null :
        P extends 'waiter'
        ? EmployeeGetPayload<S['select'][P]> | null :
        P extends 'workDay'
        ? WorkDayGetPayload<S['select'][P]> | null :
        P extends 'bills'
        ? Array < BillGetPayload<S['select'][P]>>  : never
  } 
    : TableData
  : TableData


  type TableDataCountArgs = Merge<
    Omit<TableDataFindManyArgs, 'select' | 'include'> & {
      select?: TableDataCountAggregateInputType | true
    }
  >

  export interface TableDataDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TableData that matches the filter.
     * @param {TableDataFindUniqueArgs} args - Arguments to find a TableData
     * @example
     * // Get one TableData
     * const tableData = await prisma.tableData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TableDataFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TableDataFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TableData'> extends True ? CheckSelect<T, Prisma__TableDataClient<TableData>, Prisma__TableDataClient<TableDataGetPayload<T>>> : CheckSelect<T, Prisma__TableDataClient<TableData | null >, Prisma__TableDataClient<TableDataGetPayload<T> | null >>

    /**
     * Find the first TableData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataFindFirstArgs} args - Arguments to find a TableData
     * @example
     * // Get one TableData
     * const tableData = await prisma.tableData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TableDataFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TableDataFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TableData'> extends True ? CheckSelect<T, Prisma__TableDataClient<TableData>, Prisma__TableDataClient<TableDataGetPayload<T>>> : CheckSelect<T, Prisma__TableDataClient<TableData | null >, Prisma__TableDataClient<TableDataGetPayload<T> | null >>

    /**
     * Find zero or more TableData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TableData
     * const tableData = await prisma.tableData.findMany()
     * 
     * // Get first 10 TableData
     * const tableData = await prisma.tableData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableDataWithIdOnly = await prisma.tableData.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TableDataFindManyArgs>(
      args?: SelectSubset<T, TableDataFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TableData>>, PrismaPromise<Array<TableDataGetPayload<T>>>>

    /**
     * Create a TableData.
     * @param {TableDataCreateArgs} args - Arguments to create a TableData.
     * @example
     * // Create one TableData
     * const TableData = await prisma.tableData.create({
     *   data: {
     *     // ... data to create a TableData
     *   }
     * })
     * 
    **/
    create<T extends TableDataCreateArgs>(
      args: SelectSubset<T, TableDataCreateArgs>
    ): CheckSelect<T, Prisma__TableDataClient<TableData>, Prisma__TableDataClient<TableDataGetPayload<T>>>

    /**
     * Create many TableData.
     *     @param {TableDataCreateManyArgs} args - Arguments to create many TableData.
     *     @example
     *     // Create many TableData
     *     const tableData = await prisma.tableData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TableDataCreateManyArgs>(
      args?: SelectSubset<T, TableDataCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TableData.
     * @param {TableDataDeleteArgs} args - Arguments to delete one TableData.
     * @example
     * // Delete one TableData
     * const TableData = await prisma.tableData.delete({
     *   where: {
     *     // ... filter to delete one TableData
     *   }
     * })
     * 
    **/
    delete<T extends TableDataDeleteArgs>(
      args: SelectSubset<T, TableDataDeleteArgs>
    ): CheckSelect<T, Prisma__TableDataClient<TableData>, Prisma__TableDataClient<TableDataGetPayload<T>>>

    /**
     * Update one TableData.
     * @param {TableDataUpdateArgs} args - Arguments to update one TableData.
     * @example
     * // Update one TableData
     * const tableData = await prisma.tableData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TableDataUpdateArgs>(
      args: SelectSubset<T, TableDataUpdateArgs>
    ): CheckSelect<T, Prisma__TableDataClient<TableData>, Prisma__TableDataClient<TableDataGetPayload<T>>>

    /**
     * Delete zero or more TableData.
     * @param {TableDataDeleteManyArgs} args - Arguments to filter TableData to delete.
     * @example
     * // Delete a few TableData
     * const { count } = await prisma.tableData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TableDataDeleteManyArgs>(
      args?: SelectSubset<T, TableDataDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TableData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TableData
     * const tableData = await prisma.tableData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TableDataUpdateManyArgs>(
      args: SelectSubset<T, TableDataUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TableData.
     * @param {TableDataUpsertArgs} args - Arguments to update or create a TableData.
     * @example
     * // Update or create a TableData
     * const tableData = await prisma.tableData.upsert({
     *   create: {
     *     // ... data to create a TableData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TableData we want to update
     *   }
     * })
    **/
    upsert<T extends TableDataUpsertArgs>(
      args: SelectSubset<T, TableDataUpsertArgs>
    ): CheckSelect<T, Prisma__TableDataClient<TableData>, Prisma__TableDataClient<TableDataGetPayload<T>>>

    /**
     * Count the number of TableData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataCountArgs} args - Arguments to filter TableData to count.
     * @example
     * // Count the number of TableData
     * const count = await prisma.tableData.count({
     *   where: {
     *     // ... the filter for the TableData we want to count
     *   }
     * })
    **/
    count<T extends TableDataCountArgs>(
      args?: Subset<T, TableDataCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TableData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableDataAggregateArgs>(args: Subset<T, TableDataAggregateArgs>): PrismaPromise<GetTableDataAggregateType<T>>

    /**
     * Group by TableData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableDataGroupByArgs['orderBy'] }
        : { orderBy?: TableDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableDataGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TableData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TableDataClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    table<T extends TableArgs = {}>(args?: Subset<T, TableArgs>): CheckSelect<T, Prisma__TableClient<Table | null >, Prisma__TableClient<TableGetPayload<T> | null >>;

    waiter<T extends EmployeeArgs = {}>(args?: Subset<T, EmployeeArgs>): CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>;

    workDay<T extends WorkDayArgs = {}>(args?: Subset<T, WorkDayArgs>): CheckSelect<T, Prisma__WorkDayClient<WorkDay | null >, Prisma__WorkDayClient<WorkDayGetPayload<T> | null >>;

    bills<T extends BillFindManyArgs = {}>(args?: Subset<T, BillFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Bill>>, PrismaPromise<Array<BillGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TableData findUnique
   */
  export type TableDataFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TableData
     * 
    **/
    select?: TableDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableDataInclude | null
    /**
     * Throw an Error if a TableData can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TableData to fetch.
     * 
    **/
    where: TableDataWhereUniqueInput
  }


  /**
   * TableData findFirst
   */
  export type TableDataFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TableData
     * 
    **/
    select?: TableDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableDataInclude | null
    /**
     * Throw an Error if a TableData can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TableData to fetch.
     * 
    **/
    where?: TableDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableData to fetch.
     * 
    **/
    orderBy?: Enumerable<TableDataOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TableData.
     * 
    **/
    cursor?: TableDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableData from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableData.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TableData.
     * 
    **/
    distinct?: Enumerable<TableDataScalarFieldEnum>
  }


  /**
   * TableData findMany
   */
  export type TableDataFindManyArgs = {
    /**
     * Select specific fields to fetch from the TableData
     * 
    **/
    select?: TableDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableDataInclude | null
    /**
     * Filter, which TableData to fetch.
     * 
    **/
    where?: TableDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableData to fetch.
     * 
    **/
    orderBy?: Enumerable<TableDataOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TableData.
     * 
    **/
    cursor?: TableDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableData from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableData.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TableDataScalarFieldEnum>
  }


  /**
   * TableData create
   */
  export type TableDataCreateArgs = {
    /**
     * Select specific fields to fetch from the TableData
     * 
    **/
    select?: TableDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableDataInclude | null
    /**
     * The data needed to create a TableData.
     * 
    **/
    data: XOR<TableDataCreateInput, TableDataUncheckedCreateInput>
  }


  /**
   * TableData createMany
   */
  export type TableDataCreateManyArgs = {
    data: Enumerable<TableDataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TableData update
   */
  export type TableDataUpdateArgs = {
    /**
     * Select specific fields to fetch from the TableData
     * 
    **/
    select?: TableDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableDataInclude | null
    /**
     * The data needed to update a TableData.
     * 
    **/
    data: XOR<TableDataUpdateInput, TableDataUncheckedUpdateInput>
    /**
     * Choose, which TableData to update.
     * 
    **/
    where: TableDataWhereUniqueInput
  }


  /**
   * TableData updateMany
   */
  export type TableDataUpdateManyArgs = {
    data: XOR<TableDataUpdateManyMutationInput, TableDataUncheckedUpdateManyInput>
    where?: TableDataWhereInput
  }


  /**
   * TableData upsert
   */
  export type TableDataUpsertArgs = {
    /**
     * Select specific fields to fetch from the TableData
     * 
    **/
    select?: TableDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableDataInclude | null
    /**
     * The filter to search for the TableData to update in case it exists.
     * 
    **/
    where: TableDataWhereUniqueInput
    /**
     * In case the TableData found by the `where` argument doesn't exist, create a new TableData with this data.
     * 
    **/
    create: XOR<TableDataCreateInput, TableDataUncheckedCreateInput>
    /**
     * In case the TableData was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TableDataUpdateInput, TableDataUncheckedUpdateInput>
  }


  /**
   * TableData delete
   */
  export type TableDataDeleteArgs = {
    /**
     * Select specific fields to fetch from the TableData
     * 
    **/
    select?: TableDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableDataInclude | null
    /**
     * Filter which TableData to delete.
     * 
    **/
    where: TableDataWhereUniqueInput
  }


  /**
   * TableData deleteMany
   */
  export type TableDataDeleteManyArgs = {
    where?: TableDataWhereInput
  }


  /**
   * TableData without action
   */
  export type TableDataArgs = {
    /**
     * Select specific fields to fetch from the TableData
     * 
    **/
    select?: TableDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TableDataInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    email: number
    password: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }


    
    
  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    email: string | null
    password: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserGroupByOutputType[P]> 
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      > 
    >


  export type UserSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    password?: boolean
    permissions?: boolean | PermissionFindManyArgs
    responsibleWorkDays?: boolean | WorkDayFindManyArgs
  }

  export type UserInclude = {
    permissions?: boolean | PermissionFindManyArgs
    responsibleWorkDays?: boolean | WorkDayFindManyArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'permissions'
        ? Array < PermissionGetPayload<S['include'][P]>>  :
        P extends 'responsibleWorkDays'
        ? Array < WorkDayGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'permissions'
        ? Array < PermissionGetPayload<S['select'][P]>>  :
        P extends 'responsibleWorkDays'
        ? Array < WorkDayGetPayload<S['select'][P]>>  : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    permissions<T extends PermissionFindManyArgs = {}>(args?: Subset<T, PermissionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Permission>>, PrismaPromise<Array<PermissionGetPayload<T>>>>;

    responsibleWorkDays<T extends WorkDayFindManyArgs = {}>(args?: Subset<T, WorkDayFindManyArgs>): CheckSelect<T, PrismaPromise<Array<WorkDay>>, PrismaPromise<Array<WorkDayGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model WorkDay
   */


  export type AggregateWorkDay = {
    _count: WorkDayCountAggregateOutputType | null
    count: WorkDayCountAggregateOutputType | null
    _min: WorkDayMinAggregateOutputType | null
    min: WorkDayMinAggregateOutputType | null
    _max: WorkDayMaxAggregateOutputType | null
    max: WorkDayMaxAggregateOutputType | null
  }

  export type WorkDayMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    isCurrent: boolean | null
    openDate: Date | null
    closeDate: Date | null
    establishmentId: string | null
    userResponsibleId: string | null
  }

  export type WorkDayMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    isCurrent: boolean | null
    openDate: Date | null
    closeDate: Date | null
    establishmentId: string | null
    userResponsibleId: string | null
  }

  export type WorkDayCountAggregateOutputType = {
    id: number
    createdAt: number
    isCurrent: number
    openDate: number
    closeDate: number
    establishmentId: number
    userResponsibleId: number
    _all: number
  }


  export type WorkDayMinAggregateInputType = {
    id?: true
    createdAt?: true
    isCurrent?: true
    openDate?: true
    closeDate?: true
    establishmentId?: true
    userResponsibleId?: true
  }

  export type WorkDayMaxAggregateInputType = {
    id?: true
    createdAt?: true
    isCurrent?: true
    openDate?: true
    closeDate?: true
    establishmentId?: true
    userResponsibleId?: true
  }

  export type WorkDayCountAggregateInputType = {
    id?: true
    createdAt?: true
    isCurrent?: true
    openDate?: true
    closeDate?: true
    establishmentId?: true
    userResponsibleId?: true
    _all?: true
  }

  export type WorkDayAggregateArgs = {
    /**
     * Filter which WorkDay to aggregate.
     * 
    **/
    where?: WorkDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkDays to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkDayOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WorkDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkDays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkDays.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkDays
    **/
    _count?: true | WorkDayCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | WorkDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkDayMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: WorkDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkDayMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: WorkDayMaxAggregateInputType
  }

  export type GetWorkDayAggregateType<T extends WorkDayAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkDay[P]>
      : GetScalarType<T[P], AggregateWorkDay[P]>
  }


    
    
  export type WorkDayGroupByArgs = {
    where?: WorkDayWhereInput
    orderBy?: Enumerable<WorkDayOrderByInput>
    by: Array<WorkDayScalarFieldEnum>
    having?: WorkDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkDayCountAggregateInputType | true
    _min?: WorkDayMinAggregateInputType
    _max?: WorkDayMaxAggregateInputType
  }


  export type WorkDayGroupByOutputType = {
    id: string
    createdAt: Date
    isCurrent: boolean
    openDate: Date
    closeDate: Date | null
    establishmentId: string | null
    userResponsibleId: string | null
    _count: WorkDayCountAggregateOutputType | null
    _min: WorkDayMinAggregateOutputType | null
    _max: WorkDayMaxAggregateOutputType | null
  }

  type GetWorkDayGroupByPayload<T extends WorkDayGroupByArgs> = Promise<
    Array<
      PickArray<WorkDayGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof WorkDayGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], WorkDayGroupByOutputType[P]> 
            : GetScalarType<T[P], WorkDayGroupByOutputType[P]>
        }
      > 
    >


  export type WorkDaySelect = {
    id?: boolean
    createdAt?: boolean
    isCurrent?: boolean
    openDate?: boolean
    closeDate?: boolean
    establishmentId?: boolean
    userResponsibleId?: boolean
    establishment?: boolean | EstablishmentArgs
    userResponsible?: boolean | UserArgs
    bills?: boolean | BillFindManyArgs
    incomes?: boolean | IncomeFindManyArgs
    orders?: boolean | OrderFindManyArgs
    orderPads?: boolean | OrderPadFindManyArgs
    tables?: boolean | TableDataFindManyArgs
  }

  export type WorkDayInclude = {
    establishment?: boolean | EstablishmentArgs
    userResponsible?: boolean | UserArgs
    bills?: boolean | BillFindManyArgs
    incomes?: boolean | IncomeFindManyArgs
    orders?: boolean | OrderFindManyArgs
    orderPads?: boolean | OrderPadFindManyArgs
    tables?: boolean | TableDataFindManyArgs
  }

  export type WorkDayGetPayload<
    S extends boolean | null | undefined | WorkDayArgs,
    U = keyof S
      > = S extends true
        ? WorkDay
    : S extends undefined
    ? never
    : S extends WorkDayArgs | WorkDayFindManyArgs
    ?'include' extends U
    ? WorkDay  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['include'][P]> | null :
        P extends 'userResponsible'
        ? UserGetPayload<S['include'][P]> | null :
        P extends 'bills'
        ? Array < BillGetPayload<S['include'][P]>>  :
        P extends 'incomes'
        ? Array < IncomeGetPayload<S['include'][P]>>  :
        P extends 'orders'
        ? Array < OrderGetPayload<S['include'][P]>>  :
        P extends 'orderPads'
        ? Array < OrderPadGetPayload<S['include'][P]>>  :
        P extends 'tables'
        ? Array < TableDataGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkDay ?WorkDay [P]
  : 
          P extends 'establishment'
        ? EstablishmentGetPayload<S['select'][P]> | null :
        P extends 'userResponsible'
        ? UserGetPayload<S['select'][P]> | null :
        P extends 'bills'
        ? Array < BillGetPayload<S['select'][P]>>  :
        P extends 'incomes'
        ? Array < IncomeGetPayload<S['select'][P]>>  :
        P extends 'orders'
        ? Array < OrderGetPayload<S['select'][P]>>  :
        P extends 'orderPads'
        ? Array < OrderPadGetPayload<S['select'][P]>>  :
        P extends 'tables'
        ? Array < TableDataGetPayload<S['select'][P]>>  : never
  } 
    : WorkDay
  : WorkDay


  type WorkDayCountArgs = Merge<
    Omit<WorkDayFindManyArgs, 'select' | 'include'> & {
      select?: WorkDayCountAggregateInputType | true
    }
  >

  export interface WorkDayDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one WorkDay that matches the filter.
     * @param {WorkDayFindUniqueArgs} args - Arguments to find a WorkDay
     * @example
     * // Get one WorkDay
     * const workDay = await prisma.workDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkDayFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkDayFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkDay'> extends True ? CheckSelect<T, Prisma__WorkDayClient<WorkDay>, Prisma__WorkDayClient<WorkDayGetPayload<T>>> : CheckSelect<T, Prisma__WorkDayClient<WorkDay | null >, Prisma__WorkDayClient<WorkDayGetPayload<T> | null >>

    /**
     * Find the first WorkDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkDayFindFirstArgs} args - Arguments to find a WorkDay
     * @example
     * // Get one WorkDay
     * const workDay = await prisma.workDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkDayFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkDayFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkDay'> extends True ? CheckSelect<T, Prisma__WorkDayClient<WorkDay>, Prisma__WorkDayClient<WorkDayGetPayload<T>>> : CheckSelect<T, Prisma__WorkDayClient<WorkDay | null >, Prisma__WorkDayClient<WorkDayGetPayload<T> | null >>

    /**
     * Find zero or more WorkDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkDayFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkDays
     * const workDays = await prisma.workDay.findMany()
     * 
     * // Get first 10 WorkDays
     * const workDays = await prisma.workDay.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workDayWithIdOnly = await prisma.workDay.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkDayFindManyArgs>(
      args?: SelectSubset<T, WorkDayFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<WorkDay>>, PrismaPromise<Array<WorkDayGetPayload<T>>>>

    /**
     * Create a WorkDay.
     * @param {WorkDayCreateArgs} args - Arguments to create a WorkDay.
     * @example
     * // Create one WorkDay
     * const WorkDay = await prisma.workDay.create({
     *   data: {
     *     // ... data to create a WorkDay
     *   }
     * })
     * 
    **/
    create<T extends WorkDayCreateArgs>(
      args: SelectSubset<T, WorkDayCreateArgs>
    ): CheckSelect<T, Prisma__WorkDayClient<WorkDay>, Prisma__WorkDayClient<WorkDayGetPayload<T>>>

    /**
     * Create many WorkDays.
     *     @param {WorkDayCreateManyArgs} args - Arguments to create many WorkDays.
     *     @example
     *     // Create many WorkDays
     *     const workDay = await prisma.workDay.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkDayCreateManyArgs>(
      args?: SelectSubset<T, WorkDayCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WorkDay.
     * @param {WorkDayDeleteArgs} args - Arguments to delete one WorkDay.
     * @example
     * // Delete one WorkDay
     * const WorkDay = await prisma.workDay.delete({
     *   where: {
     *     // ... filter to delete one WorkDay
     *   }
     * })
     * 
    **/
    delete<T extends WorkDayDeleteArgs>(
      args: SelectSubset<T, WorkDayDeleteArgs>
    ): CheckSelect<T, Prisma__WorkDayClient<WorkDay>, Prisma__WorkDayClient<WorkDayGetPayload<T>>>

    /**
     * Update one WorkDay.
     * @param {WorkDayUpdateArgs} args - Arguments to update one WorkDay.
     * @example
     * // Update one WorkDay
     * const workDay = await prisma.workDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkDayUpdateArgs>(
      args: SelectSubset<T, WorkDayUpdateArgs>
    ): CheckSelect<T, Prisma__WorkDayClient<WorkDay>, Prisma__WorkDayClient<WorkDayGetPayload<T>>>

    /**
     * Delete zero or more WorkDays.
     * @param {WorkDayDeleteManyArgs} args - Arguments to filter WorkDays to delete.
     * @example
     * // Delete a few WorkDays
     * const { count } = await prisma.workDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkDayDeleteManyArgs>(
      args?: SelectSubset<T, WorkDayDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkDays
     * const workDay = await prisma.workDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkDayUpdateManyArgs>(
      args: SelectSubset<T, WorkDayUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkDay.
     * @param {WorkDayUpsertArgs} args - Arguments to update or create a WorkDay.
     * @example
     * // Update or create a WorkDay
     * const workDay = await prisma.workDay.upsert({
     *   create: {
     *     // ... data to create a WorkDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkDay we want to update
     *   }
     * })
    **/
    upsert<T extends WorkDayUpsertArgs>(
      args: SelectSubset<T, WorkDayUpsertArgs>
    ): CheckSelect<T, Prisma__WorkDayClient<WorkDay>, Prisma__WorkDayClient<WorkDayGetPayload<T>>>

    /**
     * Count the number of WorkDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkDayCountArgs} args - Arguments to filter WorkDays to count.
     * @example
     * // Count the number of WorkDays
     * const count = await prisma.workDay.count({
     *   where: {
     *     // ... the filter for the WorkDays we want to count
     *   }
     * })
    **/
    count<T extends WorkDayCountArgs>(
      args?: Subset<T, WorkDayCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkDayAggregateArgs>(args: Subset<T, WorkDayAggregateArgs>): PrismaPromise<GetWorkDayAggregateType<T>>

    /**
     * Group by WorkDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkDayGroupByArgs['orderBy'] }
        : { orderBy?: WorkDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkDayGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkDayClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    establishment<T extends EstablishmentArgs = {}>(args?: Subset<T, EstablishmentArgs>): CheckSelect<T, Prisma__EstablishmentClient<Establishment | null >, Prisma__EstablishmentClient<EstablishmentGetPayload<T> | null >>;

    userResponsible<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    bills<T extends BillFindManyArgs = {}>(args?: Subset<T, BillFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Bill>>, PrismaPromise<Array<BillGetPayload<T>>>>;

    incomes<T extends IncomeFindManyArgs = {}>(args?: Subset<T, IncomeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Income>>, PrismaPromise<Array<IncomeGetPayload<T>>>>;

    orders<T extends OrderFindManyArgs = {}>(args?: Subset<T, OrderFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Order>>, PrismaPromise<Array<OrderGetPayload<T>>>>;

    orderPads<T extends OrderPadFindManyArgs = {}>(args?: Subset<T, OrderPadFindManyArgs>): CheckSelect<T, PrismaPromise<Array<OrderPad>>, PrismaPromise<Array<OrderPadGetPayload<T>>>>;

    tables<T extends TableDataFindManyArgs = {}>(args?: Subset<T, TableDataFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TableData>>, PrismaPromise<Array<TableDataGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * WorkDay findUnique
   */
  export type WorkDayFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the WorkDay
     * 
    **/
    select?: WorkDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkDayInclude | null
    /**
     * Throw an Error if a WorkDay can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkDay to fetch.
     * 
    **/
    where: WorkDayWhereUniqueInput
  }


  /**
   * WorkDay findFirst
   */
  export type WorkDayFindFirstArgs = {
    /**
     * Select specific fields to fetch from the WorkDay
     * 
    **/
    select?: WorkDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkDayInclude | null
    /**
     * Throw an Error if a WorkDay can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkDay to fetch.
     * 
    **/
    where?: WorkDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkDays to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkDayOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkDays.
     * 
    **/
    cursor?: WorkDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkDays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkDays.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkDays.
     * 
    **/
    distinct?: Enumerable<WorkDayScalarFieldEnum>
  }


  /**
   * WorkDay findMany
   */
  export type WorkDayFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkDay
     * 
    **/
    select?: WorkDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkDayInclude | null
    /**
     * Filter, which WorkDays to fetch.
     * 
    **/
    where?: WorkDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkDays to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkDayOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkDays.
     * 
    **/
    cursor?: WorkDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkDays from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkDays.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkDayScalarFieldEnum>
  }


  /**
   * WorkDay create
   */
  export type WorkDayCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkDay
     * 
    **/
    select?: WorkDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkDayInclude | null
    /**
     * The data needed to create a WorkDay.
     * 
    **/
    data: XOR<WorkDayCreateInput, WorkDayUncheckedCreateInput>
  }


  /**
   * WorkDay createMany
   */
  export type WorkDayCreateManyArgs = {
    data: Enumerable<WorkDayCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkDay update
   */
  export type WorkDayUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkDay
     * 
    **/
    select?: WorkDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkDayInclude | null
    /**
     * The data needed to update a WorkDay.
     * 
    **/
    data: XOR<WorkDayUpdateInput, WorkDayUncheckedUpdateInput>
    /**
     * Choose, which WorkDay to update.
     * 
    **/
    where: WorkDayWhereUniqueInput
  }


  /**
   * WorkDay updateMany
   */
  export type WorkDayUpdateManyArgs = {
    data: XOR<WorkDayUpdateManyMutationInput, WorkDayUncheckedUpdateManyInput>
    where?: WorkDayWhereInput
  }


  /**
   * WorkDay upsert
   */
  export type WorkDayUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkDay
     * 
    **/
    select?: WorkDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkDayInclude | null
    /**
     * The filter to search for the WorkDay to update in case it exists.
     * 
    **/
    where: WorkDayWhereUniqueInput
    /**
     * In case the WorkDay found by the `where` argument doesn't exist, create a new WorkDay with this data.
     * 
    **/
    create: XOR<WorkDayCreateInput, WorkDayUncheckedCreateInput>
    /**
     * In case the WorkDay was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WorkDayUpdateInput, WorkDayUncheckedUpdateInput>
  }


  /**
   * WorkDay delete
   */
  export type WorkDayDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkDay
     * 
    **/
    select?: WorkDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkDayInclude | null
    /**
     * Filter which WorkDay to delete.
     * 
    **/
    where: WorkDayWhereUniqueInput
  }


  /**
   * WorkDay deleteMany
   */
  export type WorkDayDeleteManyArgs = {
    where?: WorkDayWhereInput
  }


  /**
   * WorkDay without action
   */
  export type WorkDayArgs = {
    /**
     * Select specific fields to fetch from the WorkDay
     * 
    **/
    select?: WorkDaySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkDayInclude | null
  }



  /**
   * Model WorkHour
   */


  export type AggregateWorkHour = {
    _count: WorkHourCountAggregateOutputType | null
    count: WorkHourCountAggregateOutputType | null
    _min: WorkHourMinAggregateOutputType | null
    min: WorkHourMinAggregateOutputType | null
    _max: WorkHourMaxAggregateOutputType | null
    max: WorkHourMaxAggregateOutputType | null
  }

  export type WorkHourMinAggregateOutputType = {
    id: string | null
    weekday: WeekDay | null
    startTime: string | null
    endTime: string | null
    isDayOff: boolean | null
    employeeId: string | null
  }

  export type WorkHourMaxAggregateOutputType = {
    id: string | null
    weekday: WeekDay | null
    startTime: string | null
    endTime: string | null
    isDayOff: boolean | null
    employeeId: string | null
  }

  export type WorkHourCountAggregateOutputType = {
    id: number
    weekday: number
    startTime: number
    endTime: number
    isDayOff: number
    employeeId: number
    _all: number
  }


  export type WorkHourMinAggregateInputType = {
    id?: true
    weekday?: true
    startTime?: true
    endTime?: true
    isDayOff?: true
    employeeId?: true
  }

  export type WorkHourMaxAggregateInputType = {
    id?: true
    weekday?: true
    startTime?: true
    endTime?: true
    isDayOff?: true
    employeeId?: true
  }

  export type WorkHourCountAggregateInputType = {
    id?: true
    weekday?: true
    startTime?: true
    endTime?: true
    isDayOff?: true
    employeeId?: true
    _all?: true
  }

  export type WorkHourAggregateArgs = {
    /**
     * Filter which WorkHour to aggregate.
     * 
    **/
    where?: WorkHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkHours to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkHourOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WorkHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkHours from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkHours.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkHours
    **/
    _count?: true | WorkHourCountAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_count`
    **/
    count?: true | WorkHourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkHourMinAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_min`
    **/
    min?: WorkHourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkHourMaxAggregateInputType
    /**
     * @deprecated since 2.23.0 please use `_max`
    **/
    max?: WorkHourMaxAggregateInputType
  }

  export type GetWorkHourAggregateType<T extends WorkHourAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkHour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkHour[P]>
      : GetScalarType<T[P], AggregateWorkHour[P]>
  }


    
    
  export type WorkHourGroupByArgs = {
    where?: WorkHourWhereInput
    orderBy?: Enumerable<WorkHourOrderByInput>
    by: Array<WorkHourScalarFieldEnum>
    having?: WorkHourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkHourCountAggregateInputType | true
    _min?: WorkHourMinAggregateInputType
    _max?: WorkHourMaxAggregateInputType
  }


  export type WorkHourGroupByOutputType = {
    id: string
    weekday: WeekDay
    startTime: string | null
    endTime: string | null
    isDayOff: boolean | null
    employeeId: string | null
    _count: WorkHourCountAggregateOutputType | null
    _min: WorkHourMinAggregateOutputType | null
    _max: WorkHourMaxAggregateOutputType | null
  }

  type GetWorkHourGroupByPayload<T extends WorkHourGroupByArgs> = Promise<
    Array<
      PickArray<WorkHourGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof WorkHourGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], WorkHourGroupByOutputType[P]> 
            : GetScalarType<T[P], WorkHourGroupByOutputType[P]>
        }
      > 
    >


  export type WorkHourSelect = {
    id?: boolean
    weekday?: boolean
    startTime?: boolean
    endTime?: boolean
    isDayOff?: boolean
    employeeId?: boolean
    employee?: boolean | EmployeeArgs
  }

  export type WorkHourInclude = {
    employee?: boolean | EmployeeArgs
  }

  export type WorkHourGetPayload<
    S extends boolean | null | undefined | WorkHourArgs,
    U = keyof S
      > = S extends true
        ? WorkHour
    : S extends undefined
    ? never
    : S extends WorkHourArgs | WorkHourFindManyArgs
    ?'include' extends U
    ? WorkHour  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'employee'
        ? EmployeeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof WorkHour ?WorkHour [P]
  : 
          P extends 'employee'
        ? EmployeeGetPayload<S['select'][P]> | null : never
  } 
    : WorkHour
  : WorkHour


  type WorkHourCountArgs = Merge<
    Omit<WorkHourFindManyArgs, 'select' | 'include'> & {
      select?: WorkHourCountAggregateInputType | true
    }
  >

  export interface WorkHourDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one WorkHour that matches the filter.
     * @param {WorkHourFindUniqueArgs} args - Arguments to find a WorkHour
     * @example
     * // Get one WorkHour
     * const workHour = await prisma.workHour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkHourFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkHourFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkHour'> extends True ? CheckSelect<T, Prisma__WorkHourClient<WorkHour>, Prisma__WorkHourClient<WorkHourGetPayload<T>>> : CheckSelect<T, Prisma__WorkHourClient<WorkHour | null >, Prisma__WorkHourClient<WorkHourGetPayload<T> | null >>

    /**
     * Find the first WorkHour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkHourFindFirstArgs} args - Arguments to find a WorkHour
     * @example
     * // Get one WorkHour
     * const workHour = await prisma.workHour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkHourFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkHourFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkHour'> extends True ? CheckSelect<T, Prisma__WorkHourClient<WorkHour>, Prisma__WorkHourClient<WorkHourGetPayload<T>>> : CheckSelect<T, Prisma__WorkHourClient<WorkHour | null >, Prisma__WorkHourClient<WorkHourGetPayload<T> | null >>

    /**
     * Find zero or more WorkHours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkHourFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkHours
     * const workHours = await prisma.workHour.findMany()
     * 
     * // Get first 10 WorkHours
     * const workHours = await prisma.workHour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workHourWithIdOnly = await prisma.workHour.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkHourFindManyArgs>(
      args?: SelectSubset<T, WorkHourFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<WorkHour>>, PrismaPromise<Array<WorkHourGetPayload<T>>>>

    /**
     * Create a WorkHour.
     * @param {WorkHourCreateArgs} args - Arguments to create a WorkHour.
     * @example
     * // Create one WorkHour
     * const WorkHour = await prisma.workHour.create({
     *   data: {
     *     // ... data to create a WorkHour
     *   }
     * })
     * 
    **/
    create<T extends WorkHourCreateArgs>(
      args: SelectSubset<T, WorkHourCreateArgs>
    ): CheckSelect<T, Prisma__WorkHourClient<WorkHour>, Prisma__WorkHourClient<WorkHourGetPayload<T>>>

    /**
     * Create many WorkHours.
     *     @param {WorkHourCreateManyArgs} args - Arguments to create many WorkHours.
     *     @example
     *     // Create many WorkHours
     *     const workHour = await prisma.workHour.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkHourCreateManyArgs>(
      args?: SelectSubset<T, WorkHourCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WorkHour.
     * @param {WorkHourDeleteArgs} args - Arguments to delete one WorkHour.
     * @example
     * // Delete one WorkHour
     * const WorkHour = await prisma.workHour.delete({
     *   where: {
     *     // ... filter to delete one WorkHour
     *   }
     * })
     * 
    **/
    delete<T extends WorkHourDeleteArgs>(
      args: SelectSubset<T, WorkHourDeleteArgs>
    ): CheckSelect<T, Prisma__WorkHourClient<WorkHour>, Prisma__WorkHourClient<WorkHourGetPayload<T>>>

    /**
     * Update one WorkHour.
     * @param {WorkHourUpdateArgs} args - Arguments to update one WorkHour.
     * @example
     * // Update one WorkHour
     * const workHour = await prisma.workHour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkHourUpdateArgs>(
      args: SelectSubset<T, WorkHourUpdateArgs>
    ): CheckSelect<T, Prisma__WorkHourClient<WorkHour>, Prisma__WorkHourClient<WorkHourGetPayload<T>>>

    /**
     * Delete zero or more WorkHours.
     * @param {WorkHourDeleteManyArgs} args - Arguments to filter WorkHours to delete.
     * @example
     * // Delete a few WorkHours
     * const { count } = await prisma.workHour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkHourDeleteManyArgs>(
      args?: SelectSubset<T, WorkHourDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkHourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkHours
     * const workHour = await prisma.workHour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkHourUpdateManyArgs>(
      args: SelectSubset<T, WorkHourUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkHour.
     * @param {WorkHourUpsertArgs} args - Arguments to update or create a WorkHour.
     * @example
     * // Update or create a WorkHour
     * const workHour = await prisma.workHour.upsert({
     *   create: {
     *     // ... data to create a WorkHour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkHour we want to update
     *   }
     * })
    **/
    upsert<T extends WorkHourUpsertArgs>(
      args: SelectSubset<T, WorkHourUpsertArgs>
    ): CheckSelect<T, Prisma__WorkHourClient<WorkHour>, Prisma__WorkHourClient<WorkHourGetPayload<T>>>

    /**
     * Count the number of WorkHours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkHourCountArgs} args - Arguments to filter WorkHours to count.
     * @example
     * // Count the number of WorkHours
     * const count = await prisma.workHour.count({
     *   where: {
     *     // ... the filter for the WorkHours we want to count
     *   }
     * })
    **/
    count<T extends WorkHourCountArgs>(
      args?: Subset<T, WorkHourCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkHourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkHourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkHourAggregateArgs>(args: Subset<T, WorkHourAggregateArgs>): PrismaPromise<GetWorkHourAggregateType<T>>

    /**
     * Group by WorkHour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkHourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkHourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkHourGroupByArgs['orderBy'] }
        : { orderBy?: WorkHourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkHourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkHourGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkHour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkHourClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    employee<T extends EmployeeArgs = {}>(args?: Subset<T, EmployeeArgs>): CheckSelect<T, Prisma__EmployeeClient<Employee | null >, Prisma__EmployeeClient<EmployeeGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * WorkHour findUnique
   */
  export type WorkHourFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the WorkHour
     * 
    **/
    select?: WorkHourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkHourInclude | null
    /**
     * Throw an Error if a WorkHour can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkHour to fetch.
     * 
    **/
    where: WorkHourWhereUniqueInput
  }


  /**
   * WorkHour findFirst
   */
  export type WorkHourFindFirstArgs = {
    /**
     * Select specific fields to fetch from the WorkHour
     * 
    **/
    select?: WorkHourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkHourInclude | null
    /**
     * Throw an Error if a WorkHour can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which WorkHour to fetch.
     * 
    **/
    where?: WorkHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkHours to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkHourOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkHours.
     * 
    **/
    cursor?: WorkHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkHours from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkHours.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkHours.
     * 
    **/
    distinct?: Enumerable<WorkHourScalarFieldEnum>
  }


  /**
   * WorkHour findMany
   */
  export type WorkHourFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkHour
     * 
    **/
    select?: WorkHourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkHourInclude | null
    /**
     * Filter, which WorkHours to fetch.
     * 
    **/
    where?: WorkHourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkHours to fetch.
     * 
    **/
    orderBy?: Enumerable<WorkHourOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkHours.
     * 
    **/
    cursor?: WorkHourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkHours from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkHours.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WorkHourScalarFieldEnum>
  }


  /**
   * WorkHour create
   */
  export type WorkHourCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkHour
     * 
    **/
    select?: WorkHourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkHourInclude | null
    /**
     * The data needed to create a WorkHour.
     * 
    **/
    data: XOR<WorkHourCreateInput, WorkHourUncheckedCreateInput>
  }


  /**
   * WorkHour createMany
   */
  export type WorkHourCreateManyArgs = {
    data: Enumerable<WorkHourCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkHour update
   */
  export type WorkHourUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkHour
     * 
    **/
    select?: WorkHourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkHourInclude | null
    /**
     * The data needed to update a WorkHour.
     * 
    **/
    data: XOR<WorkHourUpdateInput, WorkHourUncheckedUpdateInput>
    /**
     * Choose, which WorkHour to update.
     * 
    **/
    where: WorkHourWhereUniqueInput
  }


  /**
   * WorkHour updateMany
   */
  export type WorkHourUpdateManyArgs = {
    data: XOR<WorkHourUpdateManyMutationInput, WorkHourUncheckedUpdateManyInput>
    where?: WorkHourWhereInput
  }


  /**
   * WorkHour upsert
   */
  export type WorkHourUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkHour
     * 
    **/
    select?: WorkHourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkHourInclude | null
    /**
     * The filter to search for the WorkHour to update in case it exists.
     * 
    **/
    where: WorkHourWhereUniqueInput
    /**
     * In case the WorkHour found by the `where` argument doesn't exist, create a new WorkHour with this data.
     * 
    **/
    create: XOR<WorkHourCreateInput, WorkHourUncheckedCreateInput>
    /**
     * In case the WorkHour was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WorkHourUpdateInput, WorkHourUncheckedUpdateInput>
  }


  /**
   * WorkHour delete
   */
  export type WorkHourDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkHour
     * 
    **/
    select?: WorkHourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkHourInclude | null
    /**
     * Filter which WorkHour to delete.
     * 
    **/
    where: WorkHourWhereUniqueInput
  }


  /**
   * WorkHour deleteMany
   */
  export type WorkHourDeleteManyArgs = {
    where?: WorkHourWhereInput
  }


  /**
   * WorkHour without action
   */
  export type WorkHourArgs = {
    /**
     * Select specific fields to fetch from the WorkHour
     * 
    **/
    select?: WorkHourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WorkHourInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const BillScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    closedAt: 'closedAt',
    status: 'status',
    discount: 'discount',
    discountReason: 'discountReason',
    value: 'value',
    valueAfterDiscount: 'valueAfterDiscount',
    wasReopen: 'wasReopen',
    registered: 'registered',
    workDayId: 'workDayId',
    tableDataId: 'tableDataId'
  };

  export type BillScalarFieldEnum = (typeof BillScalarFieldEnum)[keyof typeof BillScalarFieldEnum]


  export const CheckDataScalarFieldEnum: {
    id: 'id',
    checkbookId: 'checkbookId',
    compensationNumber: 'compensationNumber',
    bankNumber: 'bankNumber'
  };

  export type CheckDataScalarFieldEnum = (typeof CheckDataScalarFieldEnum)[keyof typeof CheckDataScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    complement: 'complement',
    postCode: 'postCode',
    telephoneNumber: 'telephoneNumber',
    distanceKm: 'distanceKm',
    distanceTime: 'distanceTime',
    establishmentId: 'establishmentId'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    employeeId: 'employeeId',
    name: 'name',
    role: 'role',
    admissionDate: 'admissionDate',
    terminationDate: 'terminationDate',
    isActive: 'isActive',
    establishmentId: 'establishmentId'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const EstablishmentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    lat: 'lat',
    long: 'long',
    restaurantId: 'restaurantId',
    valueInCashRegister: 'valueInCashRegister',
    maximumInCashRegister: 'maximumInCashRegister',
    incomeMaxReference: 'incomeMaxReference',
    isOpen: 'isOpen',
    totalInvoices: 'totalInvoices',
    discountReasons: 'discountReasons'
  };

  export type EstablishmentScalarFieldEnum = (typeof EstablishmentScalarFieldEnum)[keyof typeof EstablishmentScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    NFE: 'NFE',
    NFEReference: 'NFEReference',
    date: 'date',
    executionDate: 'executionDate',
    establishmentId: 'establishmentId'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const ExpenseItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    quantity: 'quantity',
    value: 'value',
    details: 'details',
    productId: 'productId'
  };

  export type ExpenseItemScalarFieldEnum = (typeof ExpenseItemScalarFieldEnum)[keyof typeof ExpenseItemScalarFieldEnum]


  export const IncomeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    reference: 'reference',
    value: 'value',
    type: 'type',
    workDayId: 'workDayId'
  };

  export type IncomeScalarFieldEnum = (typeof IncomeScalarFieldEnum)[keyof typeof IncomeScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    name: 'name',
    price: 'price',
    priceToGo: 'priceToGo',
    employeePrice: 'employeePrice',
    category: 'category',
    canTakeToGo: 'canTakeToGo',
    isActive: 'isActive',
    hasTaxSubstitution: 'hasTaxSubstitution',
    establishmentId: 'establishmentId',
    itemNCMId: 'itemNCMId'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const NCMScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    description: 'description'
  };

  export type NCMScalarFieldEnum = (typeof NCMScalarFieldEnum)[keyof typeof NCMScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    block: 'block',
    orderId: 'orderId',
    cancelled: 'cancelled',
    cancelationJustification: 'cancelationJustification',
    wasModified: 'wasModified',
    isEmployeeOrder: 'isEmployeeOrder',
    reuse: 'reuse',
    isToGo: 'isToGo',
    toGoReference: 'toGoReference',
    workDayId: 'workDayId',
    billId: 'billId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    orderId: 'orderId',
    employeeId: 'employeeId',
    itemId: 'itemId'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OrderPadScalarFieldEnum: {
    id: 'id',
    block: 'block',
    firstOrderId: 'firstOrderId',
    lastOrderId: 'lastOrderId',
    used: 'used',
    workDayId: 'workDayId',
    employeeId: 'employeeId'
  };

  export type OrderPadScalarFieldEnum = (typeof OrderPadScalarFieldEnum)[keyof typeof OrderPadScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    value: 'value',
    paymentType: 'paymentType',
    paymentTypeOption: 'paymentTypeOption',
    isActive: 'isActive',
    expenseId: 'expenseId',
    checkDataId: 'checkDataId',
    billId: 'billId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    role: 'role',
    userId: 'userId',
    establishmentId: 'establishmentId'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    supplier: 'supplier',
    brand: 'brand',
    unit: 'unit'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const TableScalarFieldEnum: {
    id: 'id',
    tableNumber: 'tableNumber',
    establishmentId: 'establishmentId'
  };

  export type TableScalarFieldEnum = (typeof TableScalarFieldEnum)[keyof typeof TableScalarFieldEnum]


  export const TableDataScalarFieldEnum: {
    id: 'id',
    totalOccupations: 'totalOccupations',
    workDayId: 'workDayId',
    tableId: 'tableId',
    waiterId: 'waiterId'
  };

  export type TableDataScalarFieldEnum = (typeof TableDataScalarFieldEnum)[keyof typeof TableDataScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WorkDayScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    isCurrent: 'isCurrent',
    openDate: 'openDate',
    closeDate: 'closeDate',
    establishmentId: 'establishmentId',
    userResponsibleId: 'userResponsibleId'
  };

  export type WorkDayScalarFieldEnum = (typeof WorkDayScalarFieldEnum)[keyof typeof WorkDayScalarFieldEnum]


  export const WorkHourScalarFieldEnum: {
    id: 'id',
    weekday: 'weekday',
    startTime: 'startTime',
    endTime: 'endTime',
    isDayOff: 'isDayOff',
    employeeId: 'employeeId'
  };

  export type WorkHourScalarFieldEnum = (typeof WorkHourScalarFieldEnum)[keyof typeof WorkHourScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type BillWhereInput = {
    AND?: Enumerable<BillWhereInput>
    OR?: Enumerable<BillWhereInput>
    NOT?: Enumerable<BillWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    closedAt?: DateTimeNullableFilter | Date | string | null
    status?: EnumBillStatusFilter | BillStatus
    discount?: FloatNullableFilter | number | null
    discountReason?: StringNullableFilter | string | null
    value?: FloatNullableFilter | number | null
    valueAfterDiscount?: FloatNullableFilter | number | null
    wasReopen?: BoolNullableFilter | boolean | null
    registered?: BoolNullableFilter | boolean | null
    workDayId?: StringNullableFilter | string | null
    tableDataId?: StringNullableFilter | string | null
    tableData?: XOR<TableDataRelationFilter, TableDataWhereInput> | null
    workDay?: XOR<WorkDayRelationFilter, WorkDayWhereInput> | null
    orders?: OrderListRelationFilter
    payments?: PaymentListRelationFilter
    reopenBillsId?: BillListRelationFilter
    reopenBills?: BillListRelationFilter
  }

  export type BillOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrder
    status?: SortOrder
    discount?: SortOrder
    discountReason?: SortOrder
    value?: SortOrder
    valueAfterDiscount?: SortOrder
    wasReopen?: SortOrder
    registered?: SortOrder
    workDayId?: SortOrder
    tableDataId?: SortOrder
  }

  export type BillWhereUniqueInput = {
    id?: string
  }

  export type BillScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BillScalarWhereWithAggregatesInput>
    OR?: Enumerable<BillScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BillScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: EnumBillStatusWithAggregatesFilter | BillStatus
    discount?: FloatNullableWithAggregatesFilter | number | null
    discountReason?: StringNullableWithAggregatesFilter | string | null
    value?: FloatNullableWithAggregatesFilter | number | null
    valueAfterDiscount?: FloatNullableWithAggregatesFilter | number | null
    wasReopen?: BoolNullableWithAggregatesFilter | boolean | null
    registered?: BoolNullableWithAggregatesFilter | boolean | null
    workDayId?: StringNullableWithAggregatesFilter | string | null
    tableDataId?: StringNullableWithAggregatesFilter | string | null
  }

  export type CheckDataWhereInput = {
    AND?: Enumerable<CheckDataWhereInput>
    OR?: Enumerable<CheckDataWhereInput>
    NOT?: Enumerable<CheckDataWhereInput>
    id?: StringFilter | string
    checkbookId?: StringNullableFilter | string | null
    compensationNumber?: IntNullableFilter | number | null
    bankNumber?: IntNullableFilter | number | null
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput> | null
  }

  export type CheckDataOrderByInput = {
    id?: SortOrder
    checkbookId?: SortOrder
    compensationNumber?: SortOrder
    bankNumber?: SortOrder
  }

  export type CheckDataWhereUniqueInput = {
    id?: string
  }

  export type CheckDataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CheckDataScalarWhereWithAggregatesInput>
    OR?: Enumerable<CheckDataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CheckDataScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    checkbookId?: StringNullableWithAggregatesFilter | string | null
    compensationNumber?: IntNullableWithAggregatesFilter | number | null
    bankNumber?: IntNullableWithAggregatesFilter | number | null
  }

  export type ClientWhereInput = {
    AND?: Enumerable<ClientWhereInput>
    OR?: Enumerable<ClientWhereInput>
    NOT?: Enumerable<ClientWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    address?: StringFilter | string
    complement?: StringNullableFilter | string | null
    postCode?: StringFilter | string
    telephoneNumber?: StringFilter | string
    distanceKm?: StringFilter | string
    distanceTime?: StringFilter | string
    establishmentId?: StringNullableFilter | string | null
    establishment?: XOR<EstablishmentRelationFilter, EstablishmentWhereInput> | null
  }

  export type ClientOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    complement?: SortOrder
    postCode?: SortOrder
    telephoneNumber?: SortOrder
    distanceKm?: SortOrder
    distanceTime?: SortOrder
    establishmentId?: SortOrder
  }

  export type ClientWhereUniqueInput = {
    id?: string
    telephoneNumber?: string
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClientScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClientScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    complement?: StringNullableWithAggregatesFilter | string | null
    postCode?: StringWithAggregatesFilter | string
    telephoneNumber?: StringWithAggregatesFilter | string
    distanceKm?: StringWithAggregatesFilter | string
    distanceTime?: StringWithAggregatesFilter | string
    establishmentId?: StringNullableWithAggregatesFilter | string | null
  }

  export type EmployeeWhereInput = {
    AND?: Enumerable<EmployeeWhereInput>
    OR?: Enumerable<EmployeeWhereInput>
    NOT?: Enumerable<EmployeeWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    employeeId?: IntFilter | number
    name?: StringFilter | string
    role?: StringFilter | string
    admissionDate?: DateTimeNullableFilter | Date | string | null
    terminationDate?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolFilter | boolean
    establishmentId?: StringNullableFilter | string | null
    establishment?: XOR<EstablishmentRelationFilter, EstablishmentWhereInput> | null
    itemsOrdered?: OrderItemListRelationFilter
    orderPads?: OrderPadListRelationFilter
    tables?: TableDataListRelationFilter
    workHours?: WorkHourListRelationFilter
  }

  export type EmployeeOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    employeeId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    admissionDate?: SortOrder
    terminationDate?: SortOrder
    isActive?: SortOrder
    establishmentId?: SortOrder
  }

  export type EmployeeWhereUniqueInput = {
    id?: string
    employeeId?: number
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EmployeeScalarWhereWithAggregatesInput>
    OR?: Enumerable<EmployeeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EmployeeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    employeeId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    role?: StringWithAggregatesFilter | string
    admissionDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    terminationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isActive?: BoolWithAggregatesFilter | boolean
    establishmentId?: StringNullableWithAggregatesFilter | string | null
  }

  export type EstablishmentWhereInput = {
    AND?: Enumerable<EstablishmentWhereInput>
    OR?: Enumerable<EstablishmentWhereInput>
    NOT?: Enumerable<EstablishmentWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    lat?: FloatFilter | number
    long?: FloatFilter | number
    restaurantId?: StringFilter | string
    valueInCashRegister?: FloatFilter | number
    maximumInCashRegister?: FloatFilter | number
    incomeMaxReference?: IntFilter | number
    isOpen?: BoolFilter | boolean
    totalInvoices?: IntNullableFilter | number | null
    discountReasons?: StringNullableListFilter
    clients?: ClientListRelationFilter
    employees?: EmployeeListRelationFilter
    expenses?: ExpenseListRelationFilter
    items?: ItemListRelationFilter
    permissions?: PermissionListRelationFilter
    tables?: TableListRelationFilter
    workingDays?: WorkDayListRelationFilter
  }

  export type EstablishmentOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    restaurantId?: SortOrder
    valueInCashRegister?: SortOrder
    maximumInCashRegister?: SortOrder
    incomeMaxReference?: SortOrder
    isOpen?: SortOrder
    totalInvoices?: SortOrder
    discountReasons?: SortOrder
  }

  export type EstablishmentWhereUniqueInput = {
    id?: string
  }

  export type EstablishmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EstablishmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<EstablishmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EstablishmentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    lat?: FloatWithAggregatesFilter | number
    long?: FloatWithAggregatesFilter | number
    restaurantId?: StringWithAggregatesFilter | string
    valueInCashRegister?: FloatWithAggregatesFilter | number
    maximumInCashRegister?: FloatWithAggregatesFilter | number
    incomeMaxReference?: IntWithAggregatesFilter | number
    isOpen?: BoolWithAggregatesFilter | boolean
    totalInvoices?: IntNullableWithAggregatesFilter | number | null
    discountReasons?: StringNullableListFilter
  }

  export type ExpenseWhereInput = {
    AND?: Enumerable<ExpenseWhereInput>
    OR?: Enumerable<ExpenseWhereInput>
    NOT?: Enumerable<ExpenseWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    NFE?: BoolFilter | boolean
    NFEReference?: StringNullableFilter | string | null
    date?: DateTimeFilter | Date | string
    executionDate?: DateTimeFilter | Date | string
    establishmentId?: StringNullableFilter | string | null
    establishment?: XOR<EstablishmentRelationFilter, EstablishmentWhereInput> | null
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput> | null
    expenseItems?: ExpenseItemListRelationFilter
  }

  export type ExpenseOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    NFE?: SortOrder
    NFEReference?: SortOrder
    date?: SortOrder
    executionDate?: SortOrder
    establishmentId?: SortOrder
  }

  export type ExpenseWhereUniqueInput = {
    id?: string
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExpenseScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExpenseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExpenseScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    NFE?: BoolWithAggregatesFilter | boolean
    NFEReference?: StringNullableWithAggregatesFilter | string | null
    date?: DateTimeWithAggregatesFilter | Date | string
    executionDate?: DateTimeWithAggregatesFilter | Date | string
    establishmentId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ExpenseItemWhereInput = {
    AND?: Enumerable<ExpenseItemWhereInput>
    OR?: Enumerable<ExpenseItemWhereInput>
    NOT?: Enumerable<ExpenseItemWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    quantity?: FloatFilter | number
    value?: FloatFilter | number
    details?: StringNullableFilter | string | null
    productId?: StringNullableFilter | string | null
    product?: XOR<ProductRelationFilter, ProductWhereInput> | null
    Expense?: ExpenseListRelationFilter
  }

  export type ExpenseItemOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    quantity?: SortOrder
    value?: SortOrder
    details?: SortOrder
    productId?: SortOrder
  }

  export type ExpenseItemWhereUniqueInput = {
    id?: string
  }

  export type ExpenseItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExpenseItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExpenseItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExpenseItemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    quantity?: FloatWithAggregatesFilter | number
    value?: FloatWithAggregatesFilter | number
    details?: StringNullableWithAggregatesFilter | string | null
    productId?: StringNullableWithAggregatesFilter | string | null
  }

  export type IncomeWhereInput = {
    AND?: Enumerable<IncomeWhereInput>
    OR?: Enumerable<IncomeWhereInput>
    NOT?: Enumerable<IncomeWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    reference?: StringFilter | string
    value?: FloatFilter | number
    type?: StringNullableFilter | string | null
    workDayId?: StringNullableFilter | string | null
    workDay?: XOR<WorkDayRelationFilter, WorkDayWhereInput> | null
  }

  export type IncomeOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    reference?: SortOrder
    value?: SortOrder
    type?: SortOrder
    workDayId?: SortOrder
  }

  export type IncomeWhereUniqueInput = {
    id?: string
    reference?: string
  }

  export type IncomeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IncomeScalarWhereWithAggregatesInput>
    OR?: Enumerable<IncomeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IncomeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    reference?: StringWithAggregatesFilter | string
    value?: FloatWithAggregatesFilter | number
    type?: StringNullableWithAggregatesFilter | string | null
    workDayId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ItemWhereInput = {
    AND?: Enumerable<ItemWhereInput>
    OR?: Enumerable<ItemWhereInput>
    NOT?: Enumerable<ItemWhereInput>
    id?: StringFilter | string
    itemId?: StringFilter | string
    name?: StringFilter | string
    price?: FloatFilter | number
    priceToGo?: FloatNullableFilter | number | null
    employeePrice?: FloatNullableFilter | number | null
    category?: StringFilter | string
    canTakeToGo?: BoolNullableFilter | boolean | null
    isActive?: BoolFilter | boolean
    hasTaxSubstitution?: BoolNullableFilter | boolean | null
    establishmentId?: StringNullableFilter | string | null
    itemNCMId?: StringNullableFilter | string | null
    establishment?: XOR<EstablishmentRelationFilter, EstablishmentWhereInput> | null
    itemNCM?: XOR<NCMRelationFilter, NCMWhereInput> | null
    orderItem?: OrderItemListRelationFilter
  }

  export type ItemOrderByInput = {
    id?: SortOrder
    itemId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    priceToGo?: SortOrder
    employeePrice?: SortOrder
    category?: SortOrder
    canTakeToGo?: SortOrder
    isActive?: SortOrder
    hasTaxSubstitution?: SortOrder
    establishmentId?: SortOrder
    itemNCMId?: SortOrder
  }

  export type ItemWhereUniqueInput = {
    id?: string
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<ItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ItemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    itemId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    priceToGo?: FloatNullableWithAggregatesFilter | number | null
    employeePrice?: FloatNullableWithAggregatesFilter | number | null
    category?: StringWithAggregatesFilter | string
    canTakeToGo?: BoolNullableWithAggregatesFilter | boolean | null
    isActive?: BoolWithAggregatesFilter | boolean
    hasTaxSubstitution?: BoolNullableWithAggregatesFilter | boolean | null
    establishmentId?: StringNullableWithAggregatesFilter | string | null
    itemNCMId?: StringNullableWithAggregatesFilter | string | null
  }

  export type NCMWhereInput = {
    AND?: Enumerable<NCMWhereInput>
    OR?: Enumerable<NCMWhereInput>
    NOT?: Enumerable<NCMWhereInput>
    id?: StringFilter | string
    identifier?: StringFilter | string
    description?: StringNullableFilter | string | null
    items?: ItemListRelationFilter
  }

  export type NCMOrderByInput = {
    id?: SortOrder
    identifier?: SortOrder
    description?: SortOrder
  }

  export type NCMWhereUniqueInput = {
    id?: string
  }

  export type NCMScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NCMScalarWhereWithAggregatesInput>
    OR?: Enumerable<NCMScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NCMScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    identifier?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    block?: IntFilter | number
    orderId?: IntFilter | number
    cancelled?: BoolNullableFilter | boolean | null
    cancelationJustification?: StringNullableFilter | string | null
    wasModified?: BoolNullableFilter | boolean | null
    isEmployeeOrder?: BoolNullableFilter | boolean | null
    reuse?: BoolNullableFilter | boolean | null
    isToGo?: BoolNullableFilter | boolean | null
    toGoReference?: StringNullableFilter | string | null
    workDayId?: StringNullableFilter | string | null
    billId?: StringNullableFilter | string | null
    bill?: XOR<BillRelationFilter, BillWhereInput> | null
    workDay?: XOR<WorkDayRelationFilter, WorkDayWhereInput> | null
    orderItems?: OrderItemListRelationFilter
    modifiedOrdersId?: OrderListRelationFilter
    modifiedOrders?: OrderListRelationFilter
  }

  export type OrderOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    block?: SortOrder
    orderId?: SortOrder
    cancelled?: SortOrder
    cancelationJustification?: SortOrder
    wasModified?: SortOrder
    isEmployeeOrder?: SortOrder
    reuse?: SortOrder
    isToGo?: SortOrder
    toGoReference?: SortOrder
    workDayId?: SortOrder
    billId?: SortOrder
  }

  export type OrderWhereUniqueInput = {
    id?: string
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    block?: IntWithAggregatesFilter | number
    orderId?: IntWithAggregatesFilter | number
    cancelled?: BoolNullableWithAggregatesFilter | boolean | null
    cancelationJustification?: StringNullableWithAggregatesFilter | string | null
    wasModified?: BoolNullableWithAggregatesFilter | boolean | null
    isEmployeeOrder?: BoolNullableWithAggregatesFilter | boolean | null
    reuse?: BoolNullableWithAggregatesFilter | boolean | null
    isToGo?: BoolNullableWithAggregatesFilter | boolean | null
    toGoReference?: StringNullableWithAggregatesFilter | string | null
    workDayId?: StringNullableWithAggregatesFilter | string | null
    billId?: StringNullableWithAggregatesFilter | string | null
  }

  export type OrderItemWhereInput = {
    AND?: Enumerable<OrderItemWhereInput>
    OR?: Enumerable<OrderItemWhereInput>
    NOT?: Enumerable<OrderItemWhereInput>
    id?: StringFilter | string
    quantity?: IntFilter | number
    orderId?: StringNullableFilter | string | null
    employeeId?: StringNullableFilter | string | null
    itemId?: StringNullableFilter | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput> | null
    item?: XOR<ItemRelationFilter, ItemWhereInput> | null
    order?: XOR<OrderRelationFilter, OrderWhereInput> | null
  }

  export type OrderItemOrderByInput = {
    id?: SortOrder
    quantity?: SortOrder
    orderId?: SortOrder
    employeeId?: SortOrder
    itemId?: SortOrder
  }

  export type OrderItemWhereUniqueInput = {
    id?: string
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderItemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    orderId?: StringNullableWithAggregatesFilter | string | null
    employeeId?: StringNullableWithAggregatesFilter | string | null
    itemId?: StringNullableWithAggregatesFilter | string | null
  }

  export type OrderPadWhereInput = {
    AND?: Enumerable<OrderPadWhereInput>
    OR?: Enumerable<OrderPadWhereInput>
    NOT?: Enumerable<OrderPadWhereInput>
    id?: StringFilter | string
    block?: IntFilter | number
    firstOrderId?: IntFilter | number
    lastOrderId?: IntNullableFilter | number | null
    used?: BoolFilter | boolean
    workDayId?: StringNullableFilter | string | null
    employeeId?: StringNullableFilter | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput> | null
    workDay?: XOR<WorkDayRelationFilter, WorkDayWhereInput> | null
  }

  export type OrderPadOrderByInput = {
    id?: SortOrder
    block?: SortOrder
    firstOrderId?: SortOrder
    lastOrderId?: SortOrder
    used?: SortOrder
    workDayId?: SortOrder
    employeeId?: SortOrder
  }

  export type OrderPadWhereUniqueInput = {
    id?: string
  }

  export type OrderPadScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderPadScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderPadScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderPadScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    block?: IntWithAggregatesFilter | number
    firstOrderId?: IntWithAggregatesFilter | number
    lastOrderId?: IntNullableWithAggregatesFilter | number | null
    used?: BoolWithAggregatesFilter | boolean
    workDayId?: StringNullableWithAggregatesFilter | string | null
    employeeId?: StringNullableWithAggregatesFilter | string | null
  }

  export type PaymentWhereInput = {
    AND?: Enumerable<PaymentWhereInput>
    OR?: Enumerable<PaymentWhereInput>
    NOT?: Enumerable<PaymentWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    value?: FloatFilter | number
    paymentType?: StringFilter | string
    paymentTypeOption?: StringNullableFilter | string | null
    isActive?: BoolFilter | boolean
    expenseId?: StringNullableFilter | string | null
    checkDataId?: StringNullableFilter | string | null
    billId?: StringNullableFilter | string | null
    bill?: XOR<BillRelationFilter, BillWhereInput> | null
    checkData?: XOR<CheckDataRelationFilter, CheckDataWhereInput> | null
    expense?: XOR<ExpenseRelationFilter, ExpenseWhereInput> | null
  }

  export type PaymentOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    value?: SortOrder
    paymentType?: SortOrder
    paymentTypeOption?: SortOrder
    isActive?: SortOrder
    expenseId?: SortOrder
    checkDataId?: SortOrder
    billId?: SortOrder
  }

  export type PaymentWhereUniqueInput = {
    id?: string
    expenseId?: string
    checkDataId?: string
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PaymentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    value?: FloatWithAggregatesFilter | number
    paymentType?: StringWithAggregatesFilter | string
    paymentTypeOption?: StringNullableWithAggregatesFilter | string | null
    isActive?: BoolWithAggregatesFilter | boolean
    expenseId?: StringNullableWithAggregatesFilter | string | null
    checkDataId?: StringNullableWithAggregatesFilter | string | null
    billId?: StringNullableWithAggregatesFilter | string | null
  }

  export type PermissionWhereInput = {
    AND?: Enumerable<PermissionWhereInput>
    OR?: Enumerable<PermissionWhereInput>
    NOT?: Enumerable<PermissionWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    role?: EnumUserRoleFilter | UserRole
    userId?: StringNullableFilter | string | null
    establishmentId?: StringNullableFilter | string | null
    establishment?: XOR<EstablishmentRelationFilter, EstablishmentWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type PermissionOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    userId?: SortOrder
    establishmentId?: SortOrder
  }

  export type PermissionWhereUniqueInput = {
    id?: string
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PermissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<PermissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PermissionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    role?: EnumUserRoleWithAggregatesFilter | UserRole
    userId?: StringNullableWithAggregatesFilter | string | null
    establishmentId?: StringNullableWithAggregatesFilter | string | null
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    category?: StringFilter | string
    supplier?: StringFilter | string
    brand?: StringNullableFilter | string | null
    unit?: StringFilter | string
    ExpenseItem?: ExpenseItemListRelationFilter
  }

  export type ProductOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    supplier?: SortOrder
    brand?: SortOrder
    unit?: SortOrder
  }

  export type ProductWhereUniqueInput = {
    id?: string
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    category?: StringWithAggregatesFilter | string
    supplier?: StringWithAggregatesFilter | string
    brand?: StringNullableWithAggregatesFilter | string | null
    unit?: StringWithAggregatesFilter | string
  }

  export type TableWhereInput = {
    AND?: Enumerable<TableWhereInput>
    OR?: Enumerable<TableWhereInput>
    NOT?: Enumerable<TableWhereInput>
    id?: StringFilter | string
    tableNumber?: IntFilter | number
    establishmentId?: StringNullableFilter | string | null
    establishment?: XOR<EstablishmentRelationFilter, EstablishmentWhereInput> | null
    data?: TableDataListRelationFilter
  }

  export type TableOrderByInput = {
    id?: SortOrder
    tableNumber?: SortOrder
    establishmentId?: SortOrder
  }

  export type TableWhereUniqueInput = {
    id?: string
    tableNumber?: number
  }

  export type TableScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TableScalarWhereWithAggregatesInput>
    OR?: Enumerable<TableScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TableScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    tableNumber?: IntWithAggregatesFilter | number
    establishmentId?: StringNullableWithAggregatesFilter | string | null
  }

  export type TableDataWhereInput = {
    AND?: Enumerable<TableDataWhereInput>
    OR?: Enumerable<TableDataWhereInput>
    NOT?: Enumerable<TableDataWhereInput>
    id?: StringFilter | string
    totalOccupations?: IntFilter | number
    workDayId?: StringNullableFilter | string | null
    tableId?: StringNullableFilter | string | null
    waiterId?: StringNullableFilter | string | null
    table?: XOR<TableRelationFilter, TableWhereInput> | null
    waiter?: XOR<EmployeeRelationFilter, EmployeeWhereInput> | null
    workDay?: XOR<WorkDayRelationFilter, WorkDayWhereInput> | null
    bills?: BillListRelationFilter
  }

  export type TableDataOrderByInput = {
    id?: SortOrder
    totalOccupations?: SortOrder
    workDayId?: SortOrder
    tableId?: SortOrder
    waiterId?: SortOrder
  }

  export type TableDataWhereUniqueInput = {
    id?: string
  }

  export type TableDataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TableDataScalarWhereWithAggregatesInput>
    OR?: Enumerable<TableDataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TableDataScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    totalOccupations?: IntWithAggregatesFilter | number
    workDayId?: StringNullableWithAggregatesFilter | string | null
    tableId?: StringNullableWithAggregatesFilter | string | null
    waiterId?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    email?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    permissions?: PermissionListRelationFilter
    responsibleWorkDays?: WorkDayListRelationFilter
  }

  export type UserOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    email?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
  }

  export type WorkDayWhereInput = {
    AND?: Enumerable<WorkDayWhereInput>
    OR?: Enumerable<WorkDayWhereInput>
    NOT?: Enumerable<WorkDayWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    isCurrent?: BoolFilter | boolean
    openDate?: DateTimeFilter | Date | string
    closeDate?: DateTimeNullableFilter | Date | string | null
    establishmentId?: StringNullableFilter | string | null
    userResponsibleId?: StringNullableFilter | string | null
    establishment?: XOR<EstablishmentRelationFilter, EstablishmentWhereInput> | null
    userResponsible?: XOR<UserRelationFilter, UserWhereInput> | null
    bills?: BillListRelationFilter
    incomes?: IncomeListRelationFilter
    orders?: OrderListRelationFilter
    orderPads?: OrderPadListRelationFilter
    tables?: TableDataListRelationFilter
  }

  export type WorkDayOrderByInput = {
    id?: SortOrder
    createdAt?: SortOrder
    isCurrent?: SortOrder
    openDate?: SortOrder
    closeDate?: SortOrder
    establishmentId?: SortOrder
    userResponsibleId?: SortOrder
  }

  export type WorkDayWhereUniqueInput = {
    id?: string
  }

  export type WorkDayScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkDayScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkDayScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkDayScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    isCurrent?: BoolWithAggregatesFilter | boolean
    openDate?: DateTimeWithAggregatesFilter | Date | string
    closeDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    establishmentId?: StringNullableWithAggregatesFilter | string | null
    userResponsibleId?: StringNullableWithAggregatesFilter | string | null
  }

  export type WorkHourWhereInput = {
    AND?: Enumerable<WorkHourWhereInput>
    OR?: Enumerable<WorkHourWhereInput>
    NOT?: Enumerable<WorkHourWhereInput>
    id?: StringFilter | string
    weekday?: EnumWeekDayFilter | WeekDay
    startTime?: StringNullableFilter | string | null
    endTime?: StringNullableFilter | string | null
    isDayOff?: BoolNullableFilter | boolean | null
    employeeId?: StringNullableFilter | string | null
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput> | null
  }

  export type WorkHourOrderByInput = {
    id?: SortOrder
    weekday?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isDayOff?: SortOrder
    employeeId?: SortOrder
  }

  export type WorkHourWhereUniqueInput = {
    id?: string
  }

  export type WorkHourScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkHourScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkHourScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkHourScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    weekday?: EnumWeekDayWithAggregatesFilter | WeekDay
    startTime?: StringNullableWithAggregatesFilter | string | null
    endTime?: StringNullableWithAggregatesFilter | string | null
    isDayOff?: BoolNullableWithAggregatesFilter | boolean | null
    employeeId?: StringNullableWithAggregatesFilter | string | null
  }

  export type BillCreateInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    tableData?: TableDataCreateNestedOneWithoutBillsInput
    workDay?: WorkDayCreateNestedOneWithoutBillsInput
    orders?: OrderCreateNestedManyWithoutBillInput
    payments?: PaymentCreateNestedManyWithoutBillInput
    reopenBillsId?: BillCreateNestedManyWithoutReopenBillsInput
    reopenBills?: BillCreateNestedManyWithoutReopenBillsIdInput
  }

  export type BillUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    workDayId?: string | null
    tableDataId?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutBillInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tableData?: TableDataUpdateOneWithoutBillsInput
    workDay?: WorkDayUpdateOneWithoutBillsInput
    orders?: OrderUpdateManyWithoutBillInput
    payments?: PaymentUpdateManyWithoutBillInput
    reopenBillsId?: BillUpdateManyWithoutReopenBillsInput
    reopenBills?: BillUpdateManyWithoutReopenBillsIdInput
  }

  export type BillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableDataId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutBillInput
    payments?: PaymentUncheckedUpdateManyWithoutBillInput
  }

  export type BillCreateManyInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    workDayId?: string | null
    tableDataId?: string | null
  }

  export type BillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableDataId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckDataCreateInput = {
    id?: string
    checkbookId?: string | null
    compensationNumber?: number | null
    bankNumber?: number | null
    payment?: PaymentCreateNestedOneWithoutCheckDataInput
  }

  export type CheckDataUncheckedCreateInput = {
    id?: string
    checkbookId?: string | null
    compensationNumber?: number | null
    bankNumber?: number | null
    payment?: PaymentUncheckedCreateNestedOneWithoutCheckDataInput
  }

  export type CheckDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkbookId?: NullableStringFieldUpdateOperationsInput | string | null
    compensationNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bankNumber?: NullableIntFieldUpdateOperationsInput | number | null
    payment?: PaymentUpdateOneWithoutCheckDataInput
  }

  export type CheckDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkbookId?: NullableStringFieldUpdateOperationsInput | string | null
    compensationNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bankNumber?: NullableIntFieldUpdateOperationsInput | number | null
    payment?: PaymentUncheckedUpdateOneWithoutCheckDataInput
  }

  export type CheckDataCreateManyInput = {
    id?: string
    checkbookId?: string | null
    compensationNumber?: number | null
    bankNumber?: number | null
  }

  export type CheckDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkbookId?: NullableStringFieldUpdateOperationsInput | string | null
    compensationNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bankNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CheckDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkbookId?: NullableStringFieldUpdateOperationsInput | string | null
    compensationNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bankNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    address: string
    complement?: string | null
    postCode: string
    telephoneNumber: string
    distanceKm: string
    distanceTime: string
    establishment?: EstablishmentCreateNestedOneWithoutClientsInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    complement?: string | null
    postCode: string
    telephoneNumber: string
    distanceKm: string
    distanceTime: string
    establishmentId?: string | null
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    postCode?: StringFieldUpdateOperationsInput | string
    telephoneNumber?: StringFieldUpdateOperationsInput | string
    distanceKm?: StringFieldUpdateOperationsInput | string
    distanceTime?: StringFieldUpdateOperationsInput | string
    establishment?: EstablishmentUpdateOneWithoutClientsInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    postCode?: StringFieldUpdateOperationsInput | string
    telephoneNumber?: StringFieldUpdateOperationsInput | string
    distanceKm?: StringFieldUpdateOperationsInput | string
    distanceTime?: StringFieldUpdateOperationsInput | string
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientCreateManyInput = {
    id?: string
    name: string
    address: string
    complement?: string | null
    postCode: string
    telephoneNumber: string
    distanceKm: string
    distanceTime: string
    establishmentId?: string | null
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    postCode?: StringFieldUpdateOperationsInput | string
    telephoneNumber?: StringFieldUpdateOperationsInput | string
    distanceKm?: StringFieldUpdateOperationsInput | string
    distanceTime?: StringFieldUpdateOperationsInput | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    postCode?: StringFieldUpdateOperationsInput | string
    telephoneNumber?: StringFieldUpdateOperationsInput | string
    distanceKm?: StringFieldUpdateOperationsInput | string
    distanceTime?: StringFieldUpdateOperationsInput | string
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeCreateInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    establishment?: EstablishmentCreateNestedOneWithoutEmployeesInput
    itemsOrdered?: OrderItemCreateNestedManyWithoutEmployeeInput
    orderPads?: OrderPadCreateNestedManyWithoutEmployeeInput
    tables?: TableDataCreateNestedManyWithoutWaiterInput
    workHours?: WorkHourCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    establishmentId?: string | null
    itemsOrdered?: OrderItemUncheckedCreateNestedManyWithoutEmployeeInput
    orderPads?: OrderPadUncheckedCreateNestedManyWithoutEmployeeInput
    tables?: TableDataUncheckedCreateNestedManyWithoutWaiterInput
    workHours?: WorkHourUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishment?: EstablishmentUpdateOneWithoutEmployeesInput
    itemsOrdered?: OrderItemUpdateManyWithoutEmployeeInput
    orderPads?: OrderPadUpdateManyWithoutEmployeeInput
    tables?: TableDataUpdateManyWithoutWaiterInput
    workHours?: WorkHourUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemsOrdered?: OrderItemUncheckedUpdateManyWithoutEmployeeInput
    orderPads?: OrderPadUncheckedUpdateManyWithoutEmployeeInput
    tables?: TableDataUncheckedUpdateManyWithoutWaiterInput
    workHours?: WorkHourUncheckedUpdateManyWithoutEmployeeInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    establishmentId?: string | null
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EstablishmentCreateInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientCreateNestedManyWithoutEstablishmentInput
    employees?: EmployeeCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseCreateNestedManyWithoutEstablishmentInput
    items?: ItemCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionCreateNestedManyWithoutEstablishmentInput
    tables?: TableCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedCreateNestedManyWithoutEstablishmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEstablishmentInput
    items?: ItemUncheckedCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutEstablishmentInput
    tables?: TableUncheckedCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUpdateManyWithoutEstablishmentInput
    employees?: EmployeeUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUpdateManyWithoutEstablishmentInput
    items?: ItemUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUpdateManyWithoutEstablishmentInput
    tables?: TableUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUpdateManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedUpdateManyWithoutEstablishmentInput
    employees?: EmployeeUncheckedUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEstablishmentInput
    items?: ItemUncheckedUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedUpdateManyWithoutEstablishmentInput
    tables?: TableUncheckedUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedUpdateManyWithoutEstablishmentInput
  }

  export type EstablishmentCreateManyInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreateManydiscountReasonsInput | Enumerable<string>
  }

  export type EstablishmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
  }

  export type EstablishmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
  }

  export type ExpenseCreateInput = {
    id?: string
    createdAt?: Date | string
    NFE: boolean
    NFEReference?: string | null
    date: Date | string
    executionDate: Date | string
    establishment?: EstablishmentCreateNestedOneWithoutExpensesInput
    payment?: PaymentCreateNestedOneWithoutExpenseInput
    expenseItems?: ExpenseItemCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    NFE: boolean
    NFEReference?: string | null
    date: Date | string
    executionDate: Date | string
    establishmentId?: string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NFE?: BoolFieldUpdateOperationsInput | boolean
    NFEReference?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    establishment?: EstablishmentUpdateOneWithoutExpensesInput
    payment?: PaymentUpdateOneWithoutExpenseInput
    expenseItems?: ExpenseItemUpdateManyWithoutExpenseInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NFE?: BoolFieldUpdateOperationsInput | boolean
    NFEReference?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: PaymentUncheckedUpdateOneWithoutExpenseInput
  }

  export type ExpenseCreateManyInput = {
    id?: string
    createdAt?: Date | string
    NFE: boolean
    NFEReference?: string | null
    date: Date | string
    executionDate: Date | string
    establishmentId?: string | null
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NFE?: BoolFieldUpdateOperationsInput | boolean
    NFEReference?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NFE?: BoolFieldUpdateOperationsInput | boolean
    NFEReference?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseItemCreateInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    value: number
    details?: string | null
    product?: ProductCreateNestedOneWithoutExpenseItemInput
    Expense?: ExpenseCreateNestedManyWithoutExpenseItemsInput
  }

  export type ExpenseItemUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    value: number
    details?: string | null
    productId?: string | null
  }

  export type ExpenseItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: FloatFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneWithoutExpenseItemInput
    Expense?: ExpenseUpdateManyWithoutExpenseItemsInput
  }

  export type ExpenseItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: FloatFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseItemCreateManyInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    value: number
    details?: string | null
    productId?: string | null
  }

  export type ExpenseItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: FloatFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: FloatFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncomeCreateInput = {
    id?: string
    createdAt?: Date | string
    reference: string
    value: number
    type?: string | null
    workDay?: WorkDayCreateNestedOneWithoutIncomesInput
  }

  export type IncomeUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    reference: string
    value: number
    type?: string | null
    workDayId?: string | null
  }

  export type IncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    workDay?: WorkDayUpdateOneWithoutIncomesInput
  }

  export type IncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncomeCreateManyInput = {
    id?: string
    createdAt?: Date | string
    reference: string
    value: number
    type?: string | null
    workDayId?: string | null
  }

  export type IncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemCreateInput = {
    id?: string
    itemId: string
    name: string
    price: number
    priceToGo?: number | null
    employeePrice?: number | null
    category: string
    canTakeToGo?: boolean | null
    isActive: boolean
    hasTaxSubstitution?: boolean | null
    establishment?: EstablishmentCreateNestedOneWithoutItemsInput
    itemNCM?: NCMCreateNestedOneWithoutItemsInput
    orderItem?: OrderItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    itemId: string
    name: string
    price: number
    priceToGo?: number | null
    employeePrice?: number | null
    category: string
    canTakeToGo?: boolean | null
    isActive: boolean
    hasTaxSubstitution?: boolean | null
    establishmentId?: string | null
    itemNCMId?: string | null
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceToGo?: NullableFloatFieldUpdateOperationsInput | number | null
    employeePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    canTakeToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasTaxSubstitution?: NullableBoolFieldUpdateOperationsInput | boolean | null
    establishment?: EstablishmentUpdateOneWithoutItemsInput
    itemNCM?: NCMUpdateOneWithoutItemsInput
    orderItem?: OrderItemUpdateManyWithoutItemInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceToGo?: NullableFloatFieldUpdateOperationsInput | number | null
    employeePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    canTakeToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasTaxSubstitution?: NullableBoolFieldUpdateOperationsInput | boolean | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemNCMId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItem?: OrderItemUncheckedUpdateManyWithoutItemInput
  }

  export type ItemCreateManyInput = {
    id?: string
    itemId: string
    name: string
    price: number
    priceToGo?: number | null
    employeePrice?: number | null
    category: string
    canTakeToGo?: boolean | null
    isActive: boolean
    hasTaxSubstitution?: boolean | null
    establishmentId?: string | null
    itemNCMId?: string | null
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceToGo?: NullableFloatFieldUpdateOperationsInput | number | null
    employeePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    canTakeToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasTaxSubstitution?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceToGo?: NullableFloatFieldUpdateOperationsInput | number | null
    employeePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    canTakeToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasTaxSubstitution?: NullableBoolFieldUpdateOperationsInput | boolean | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemNCMId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NCMCreateInput = {
    id?: string
    identifier: string
    description?: string | null
    items?: ItemCreateNestedManyWithoutItemNCMInput
  }

  export type NCMUncheckedCreateInput = {
    id?: string
    identifier: string
    description?: string | null
    items?: ItemUncheckedCreateNestedManyWithoutItemNCMInput
  }

  export type NCMUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemUpdateManyWithoutItemNCMInput
  }

  export type NCMUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    items?: ItemUncheckedUpdateManyWithoutItemNCMInput
  }

  export type NCMCreateManyInput = {
    id?: string
    identifier: string
    description?: string | null
  }

  export type NCMUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NCMUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    bill?: BillCreateNestedOneWithoutOrdersInput
    workDay?: WorkDayCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    modifiedOrdersId?: OrderCreateNestedManyWithoutModifiedOrdersInput
    modifiedOrders?: OrderCreateNestedManyWithoutModifiedOrdersIdInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    workDayId?: string | null
    billId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    bill?: BillUpdateOneWithoutOrdersInput
    workDay?: WorkDayUpdateOneWithoutOrdersInput
    orderItems?: OrderItemUpdateManyWithoutOrderInput
    modifiedOrdersId?: OrderUpdateManyWithoutModifiedOrdersInput
    modifiedOrders?: OrderUpdateManyWithoutModifiedOrdersIdInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderInput
  }

  export type OrderCreateManyInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    workDayId?: string | null
    billId?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity: number
    employee?: EmployeeCreateNestedOneWithoutItemsOrderedInput
    item?: ItemCreateNestedOneWithoutOrderItemInput
    order?: OrderCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    quantity: number
    orderId?: string | null
    employeeId?: string | null
    itemId?: string | null
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    employee?: EmployeeUpdateOneWithoutItemsOrderedInput
    item?: ItemUpdateOneWithoutOrderItemInput
    order?: OrderUpdateOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyInput = {
    id?: string
    quantity: number
    orderId?: string | null
    employeeId?: string | null
    itemId?: string | null
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderPadCreateInput = {
    id?: string
    block: number
    firstOrderId: number
    lastOrderId?: number | null
    used: boolean
    employee?: EmployeeCreateNestedOneWithoutOrderPadsInput
    workDay?: WorkDayCreateNestedOneWithoutOrderPadsInput
  }

  export type OrderPadUncheckedCreateInput = {
    id?: string
    block: number
    firstOrderId: number
    lastOrderId?: number | null
    used: boolean
    workDayId?: string | null
    employeeId?: string | null
  }

  export type OrderPadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    block?: IntFieldUpdateOperationsInput | number
    firstOrderId?: IntFieldUpdateOperationsInput | number
    lastOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    used?: BoolFieldUpdateOperationsInput | boolean
    employee?: EmployeeUpdateOneWithoutOrderPadsInput
    workDay?: WorkDayUpdateOneWithoutOrderPadsInput
  }

  export type OrderPadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    block?: IntFieldUpdateOperationsInput | number
    firstOrderId?: IntFieldUpdateOperationsInput | number
    lastOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    used?: BoolFieldUpdateOperationsInput | boolean
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderPadCreateManyInput = {
    id?: string
    block: number
    firstOrderId: number
    lastOrderId?: number | null
    used: boolean
    workDayId?: string | null
    employeeId?: string | null
  }

  export type OrderPadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    block?: IntFieldUpdateOperationsInput | number
    firstOrderId?: IntFieldUpdateOperationsInput | number
    lastOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrderPadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    block?: IntFieldUpdateOperationsInput | number
    firstOrderId?: IntFieldUpdateOperationsInput | number
    lastOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    used?: BoolFieldUpdateOperationsInput | boolean
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    createdAt?: Date | string
    value: number
    paymentType: string
    paymentTypeOption?: string | null
    isActive: boolean
    bill?: BillCreateNestedOneWithoutPaymentsInput
    checkData?: CheckDataCreateNestedOneWithoutPaymentInput
    expense?: ExpenseCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    value: number
    paymentType: string
    paymentTypeOption?: string | null
    isActive: boolean
    expenseId?: string | null
    checkDataId?: string | null
    billId?: string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentTypeOption?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bill?: BillUpdateOneWithoutPaymentsInput
    checkData?: CheckDataUpdateOneWithoutPaymentInput
    expense?: ExpenseUpdateOneWithoutPaymentInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentTypeOption?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    checkDataId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    createdAt?: Date | string
    value: number
    paymentType: string
    paymentTypeOption?: string | null
    isActive: boolean
    expenseId?: string | null
    checkDataId?: string | null
    billId?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentTypeOption?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentTypeOption?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    checkDataId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    role: UserRole
    establishment?: EstablishmentCreateNestedOneWithoutPermissionsInput
    user?: UserCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    role: UserRole
    userId?: string | null
    establishmentId?: string | null
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    establishment?: EstablishmentUpdateOneWithoutPermissionsInput
    user?: UserUpdateOneWithoutPermissionsInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    role: UserRole
    userId?: string | null
    establishmentId?: string | null
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    category: string
    supplier: string
    brand?: string | null
    unit: string
    ExpenseItem?: ExpenseItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    category: string
    supplier: string
    brand?: string | null
    unit: string
    ExpenseItem?: ExpenseItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    ExpenseItem?: ExpenseItemUpdateManyWithoutProductInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
    ExpenseItem?: ExpenseItemUncheckedUpdateManyWithoutProductInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    category: string
    supplier: string
    brand?: string | null
    unit: string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type TableCreateInput = {
    id?: string
    tableNumber: number
    establishment?: EstablishmentCreateNestedOneWithoutTablesInput
    data?: TableDataCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateInput = {
    id?: string
    tableNumber: number
    establishmentId?: string | null
    data?: TableDataUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableNumber?: IntFieldUpdateOperationsInput | number
    establishment?: EstablishmentUpdateOneWithoutTablesInput
    data?: TableDataUpdateManyWithoutTableInput
  }

  export type TableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableNumber?: IntFieldUpdateOperationsInput | number
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    data?: TableDataUncheckedUpdateManyWithoutTableInput
  }

  export type TableCreateManyInput = {
    id?: string
    tableNumber: number
    establishmentId?: string | null
  }

  export type TableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableNumber?: IntFieldUpdateOperationsInput | number
  }

  export type TableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableNumber?: IntFieldUpdateOperationsInput | number
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableDataCreateInput = {
    id?: string
    totalOccupations: number
    table?: TableCreateNestedOneWithoutDataInput
    waiter?: EmployeeCreateNestedOneWithoutTablesInput
    workDay?: WorkDayCreateNestedOneWithoutTablesInput
    bills?: BillCreateNestedManyWithoutTableDataInput
  }

  export type TableDataUncheckedCreateInput = {
    id?: string
    totalOccupations: number
    workDayId?: string | null
    tableId?: string | null
    waiterId?: string | null
    bills?: BillUncheckedCreateNestedManyWithoutTableDataInput
  }

  export type TableDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    table?: TableUpdateOneWithoutDataInput
    waiter?: EmployeeUpdateOneWithoutTablesInput
    workDay?: WorkDayUpdateOneWithoutTablesInput
    bills?: BillUpdateManyWithoutTableDataInput
  }

  export type TableDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    waiterId?: NullableStringFieldUpdateOperationsInput | string | null
    bills?: BillUncheckedUpdateManyWithoutTableDataInput
  }

  export type TableDataCreateManyInput = {
    id?: string
    totalOccupations: number
    workDayId?: string | null
    tableId?: string | null
    waiterId?: string | null
  }

  export type TableDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
  }

  export type TableDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    waiterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    password?: string | null
    permissions?: PermissionCreateNestedManyWithoutUserInput
    responsibleWorkDays?: WorkDayCreateNestedManyWithoutUserResponsibleInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    password?: string | null
    permissions?: PermissionUncheckedCreateNestedManyWithoutUserInput
    responsibleWorkDays?: WorkDayUncheckedCreateNestedManyWithoutUserResponsibleInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: PermissionUpdateManyWithoutUserInput
    responsibleWorkDays?: WorkDayUpdateManyWithoutUserResponsibleInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: PermissionUncheckedUpdateManyWithoutUserInput
    responsibleWorkDays?: WorkDayUncheckedUpdateManyWithoutUserResponsibleInput
  }

  export type UserCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    password?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkDayCreateInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishment?: EstablishmentCreateNestedOneWithoutWorkingDaysInput
    userResponsible?: UserCreateNestedOneWithoutResponsibleWorkDaysInput
    bills?: BillCreateNestedManyWithoutWorkDayInput
    incomes?: IncomeCreateNestedManyWithoutWorkDayInput
    orders?: OrderCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadCreateNestedManyWithoutWorkDayInput
    tables?: TableDataCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishmentId?: string | null
    userResponsibleId?: string | null
    bills?: BillUncheckedCreateNestedManyWithoutWorkDayInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutWorkDayInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedCreateNestedManyWithoutWorkDayInput
    tables?: TableDataUncheckedCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishment?: EstablishmentUpdateOneWithoutWorkingDaysInput
    userResponsible?: UserUpdateOneWithoutResponsibleWorkDaysInput
    bills?: BillUpdateManyWithoutWorkDayInput
    incomes?: IncomeUpdateManyWithoutWorkDayInput
    orders?: OrderUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUpdateManyWithoutWorkDayInput
    tables?: TableDataUpdateManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    userResponsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    bills?: BillUncheckedUpdateManyWithoutWorkDayInput
    incomes?: IncomeUncheckedUpdateManyWithoutWorkDayInput
    orders?: OrderUncheckedUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedUpdateManyWithoutWorkDayInput
    tables?: TableDataUncheckedUpdateManyWithoutWorkDayInput
  }

  export type WorkDayCreateManyInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishmentId?: string | null
    userResponsibleId?: string | null
  }

  export type WorkDayUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkDayUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    userResponsibleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkHourCreateInput = {
    id?: string
    weekday: WeekDay
    startTime?: string | null
    endTime?: string | null
    isDayOff?: boolean | null
    employee?: EmployeeCreateNestedOneWithoutWorkHoursInput
  }

  export type WorkHourUncheckedCreateInput = {
    id?: string
    weekday: WeekDay
    startTime?: string | null
    endTime?: string | null
    isDayOff?: boolean | null
    employeeId?: string | null
  }

  export type WorkHourUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekday?: EnumWeekDayFieldUpdateOperationsInput | WeekDay
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isDayOff?: NullableBoolFieldUpdateOperationsInput | boolean | null
    employee?: EmployeeUpdateOneWithoutWorkHoursInput
  }

  export type WorkHourUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekday?: EnumWeekDayFieldUpdateOperationsInput | WeekDay
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isDayOff?: NullableBoolFieldUpdateOperationsInput | boolean | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkHourCreateManyInput = {
    id?: string
    weekday: WeekDay
    startTime?: string | null
    endTime?: string | null
    isDayOff?: boolean | null
    employeeId?: string | null
  }

  export type WorkHourUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekday?: EnumWeekDayFieldUpdateOperationsInput | WeekDay
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isDayOff?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type WorkHourUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekday?: EnumWeekDayFieldUpdateOperationsInput | WeekDay
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isDayOff?: NullableBoolFieldUpdateOperationsInput | boolean | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type EnumBillStatusFilter = {
    equals?: BillStatus
    in?: Enumerable<BillStatus>
    notIn?: Enumerable<BillStatus>
    not?: NestedEnumBillStatusFilter | BillStatus
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type TableDataRelationFilter = {
    is?: TableDataWhereInput | null
    isNot?: TableDataWhereInput | null
  }

  export type WorkDayRelationFilter = {
    is?: WorkDayWhereInput | null
    isNot?: WorkDayWhereInput | null
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type BillListRelationFilter = {
    every?: BillWhereInput
    some?: BillWhereInput
    none?: BillWhereInput
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type EnumBillStatusWithAggregatesFilter = {
    equals?: BillStatus
    in?: Enumerable<BillStatus>
    notIn?: Enumerable<BillStatus>
    not?: NestedEnumBillStatusWithAggregatesFilter | BillStatus
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumBillStatusFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumBillStatusFilter
    _max?: NestedEnumBillStatusFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumBillStatusFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolNullableFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type PaymentRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type EstablishmentRelationFilter = {
    is?: EstablishmentWhereInput | null
    isNot?: EstablishmentWhereInput | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type OrderPadListRelationFilter = {
    every?: OrderPadWhereInput
    some?: OrderPadWhereInput
    none?: OrderPadWhereInput
  }

  export type TableDataListRelationFilter = {
    every?: TableDataWhereInput
    some?: TableDataWhereInput
    none?: TableDataWhereInput
  }

  export type WorkHourListRelationFilter = {
    every?: WorkHourWhereInput
    some?: WorkHourWhereInput
    none?: WorkHourWhereInput
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type TableListRelationFilter = {
    every?: TableWhereInput
    some?: TableWhereInput
    none?: TableWhereInput
  }

  export type WorkDayListRelationFilter = {
    every?: WorkDayWhereInput
    some?: WorkDayWhereInput
    none?: WorkDayWhereInput
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatFilter
    _max?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatFilter
  }

  export type ExpenseItemListRelationFilter = {
    every?: ExpenseItemWhereInput
    some?: ExpenseItemWhereInput
    none?: ExpenseItemWhereInput
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type NCMRelationFilter = {
    is?: NCMWhereInput | null
    isNot?: NCMWhereInput | null
  }

  export type BillRelationFilter = {
    is?: BillWhereInput | null
    isNot?: BillWhereInput | null
  }

  export type EmployeeRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type ItemRelationFilter = {
    is?: ItemWhereInput | null
    isNot?: ItemWhereInput | null
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type CheckDataRelationFilter = {
    is?: CheckDataWhereInput | null
    isNot?: CheckDataWhereInput | null
  }

  export type ExpenseRelationFilter = {
    is?: ExpenseWhereInput | null
    isNot?: ExpenseWhereInput | null
  }

  export type EnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumUserRoleFilter
  }

  export type TableRelationFilter = {
    is?: TableWhereInput | null
    isNot?: TableWhereInput | null
  }

  export type IncomeListRelationFilter = {
    every?: IncomeWhereInput
    some?: IncomeWhereInput
    none?: IncomeWhereInput
  }

  export type EnumWeekDayFilter = {
    equals?: WeekDay
    in?: Enumerable<WeekDay>
    notIn?: Enumerable<WeekDay>
    not?: NestedEnumWeekDayFilter | WeekDay
  }

  export type EnumWeekDayWithAggregatesFilter = {
    equals?: WeekDay
    in?: Enumerable<WeekDay>
    notIn?: Enumerable<WeekDay>
    not?: NestedEnumWeekDayWithAggregatesFilter | WeekDay
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumWeekDayFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumWeekDayFilter
    _max?: NestedEnumWeekDayFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumWeekDayFilter
  }

  export type TableDataCreateNestedOneWithoutBillsInput = {
    create?: XOR<TableDataCreateWithoutBillsInput, TableDataUncheckedCreateWithoutBillsInput>
    connectOrCreate?: TableDataCreateOrConnectWithoutBillsInput
    connect?: TableDataWhereUniqueInput
  }

  export type WorkDayCreateNestedOneWithoutBillsInput = {
    create?: XOR<WorkDayCreateWithoutBillsInput, WorkDayUncheckedCreateWithoutBillsInput>
    connectOrCreate?: WorkDayCreateOrConnectWithoutBillsInput
    connect?: WorkDayWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutBillInput = {
    create?: XOR<Enumerable<OrderCreateWithoutBillInput>, Enumerable<OrderUncheckedCreateWithoutBillInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutBillInput>
    createMany?: OrderCreateManyBillInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type PaymentCreateNestedManyWithoutBillInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutBillInput>, Enumerable<PaymentUncheckedCreateWithoutBillInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutBillInput>
    createMany?: PaymentCreateManyBillInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type BillCreateNestedManyWithoutReopenBillsInput = {
    create?: XOR<Enumerable<BillCreateWithoutReopenBillsInput>, Enumerable<BillUncheckedCreateWithoutReopenBillsInput>>
    connectOrCreate?: Enumerable<BillCreateOrConnectWithoutReopenBillsInput>
    connect?: Enumerable<BillWhereUniqueInput>
  }

  export type BillCreateNestedManyWithoutReopenBillsIdInput = {
    create?: XOR<Enumerable<BillCreateWithoutReopenBillsIdInput>, Enumerable<BillUncheckedCreateWithoutReopenBillsIdInput>>
    connectOrCreate?: Enumerable<BillCreateOrConnectWithoutReopenBillsIdInput>
    connect?: Enumerable<BillWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<Enumerable<OrderCreateWithoutBillInput>, Enumerable<OrderUncheckedCreateWithoutBillInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutBillInput>
    createMany?: OrderCreateManyBillInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type PaymentUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutBillInput>, Enumerable<PaymentUncheckedCreateWithoutBillInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutBillInput>
    createMany?: PaymentCreateManyBillInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumBillStatusFieldUpdateOperationsInput = {
    set?: BillStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type TableDataUpdateOneWithoutBillsInput = {
    create?: XOR<TableDataCreateWithoutBillsInput, TableDataUncheckedCreateWithoutBillsInput>
    connectOrCreate?: TableDataCreateOrConnectWithoutBillsInput
    upsert?: TableDataUpsertWithoutBillsInput
    connect?: TableDataWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TableDataUpdateWithoutBillsInput, TableDataUncheckedUpdateWithoutBillsInput>
  }

  export type WorkDayUpdateOneWithoutBillsInput = {
    create?: XOR<WorkDayCreateWithoutBillsInput, WorkDayUncheckedCreateWithoutBillsInput>
    connectOrCreate?: WorkDayCreateOrConnectWithoutBillsInput
    upsert?: WorkDayUpsertWithoutBillsInput
    connect?: WorkDayWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<WorkDayUpdateWithoutBillsInput, WorkDayUncheckedUpdateWithoutBillsInput>
  }

  export type OrderUpdateManyWithoutBillInput = {
    create?: XOR<Enumerable<OrderCreateWithoutBillInput>, Enumerable<OrderUncheckedCreateWithoutBillInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutBillInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutBillInput>
    createMany?: OrderCreateManyBillInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutBillInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutBillInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type PaymentUpdateManyWithoutBillInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutBillInput>, Enumerable<PaymentUncheckedCreateWithoutBillInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutBillInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutBillInput>
    createMany?: PaymentCreateManyBillInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutBillInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutBillInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type BillUpdateManyWithoutReopenBillsInput = {
    create?: XOR<Enumerable<BillCreateWithoutReopenBillsInput>, Enumerable<BillUncheckedCreateWithoutReopenBillsInput>>
    connectOrCreate?: Enumerable<BillCreateOrConnectWithoutReopenBillsInput>
    upsert?: Enumerable<BillUpsertWithWhereUniqueWithoutReopenBillsInput>
    connect?: Enumerable<BillWhereUniqueInput>
    set?: Enumerable<BillWhereUniqueInput>
    disconnect?: Enumerable<BillWhereUniqueInput>
    delete?: Enumerable<BillWhereUniqueInput>
    update?: Enumerable<BillUpdateWithWhereUniqueWithoutReopenBillsInput>
    updateMany?: Enumerable<BillUpdateManyWithWhereWithoutReopenBillsInput>
    deleteMany?: Enumerable<BillScalarWhereInput>
  }

  export type BillUpdateManyWithoutReopenBillsIdInput = {
    create?: XOR<Enumerable<BillCreateWithoutReopenBillsIdInput>, Enumerable<BillUncheckedCreateWithoutReopenBillsIdInput>>
    connectOrCreate?: Enumerable<BillCreateOrConnectWithoutReopenBillsIdInput>
    upsert?: Enumerable<BillUpsertWithWhereUniqueWithoutReopenBillsIdInput>
    connect?: Enumerable<BillWhereUniqueInput>
    set?: Enumerable<BillWhereUniqueInput>
    disconnect?: Enumerable<BillWhereUniqueInput>
    delete?: Enumerable<BillWhereUniqueInput>
    update?: Enumerable<BillUpdateWithWhereUniqueWithoutReopenBillsIdInput>
    updateMany?: Enumerable<BillUpdateManyWithWhereWithoutReopenBillsIdInput>
    deleteMany?: Enumerable<BillScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutBillInput = {
    create?: XOR<Enumerable<OrderCreateWithoutBillInput>, Enumerable<OrderUncheckedCreateWithoutBillInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutBillInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutBillInput>
    createMany?: OrderCreateManyBillInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutBillInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutBillInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type PaymentUncheckedUpdateManyWithoutBillInput = {
    create?: XOR<Enumerable<PaymentCreateWithoutBillInput>, Enumerable<PaymentUncheckedCreateWithoutBillInput>>
    connectOrCreate?: Enumerable<PaymentCreateOrConnectWithoutBillInput>
    upsert?: Enumerable<PaymentUpsertWithWhereUniqueWithoutBillInput>
    createMany?: PaymentCreateManyBillInputEnvelope
    connect?: Enumerable<PaymentWhereUniqueInput>
    set?: Enumerable<PaymentWhereUniqueInput>
    disconnect?: Enumerable<PaymentWhereUniqueInput>
    delete?: Enumerable<PaymentWhereUniqueInput>
    update?: Enumerable<PaymentUpdateWithWhereUniqueWithoutBillInput>
    updateMany?: Enumerable<PaymentUpdateManyWithWhereWithoutBillInput>
    deleteMany?: Enumerable<PaymentScalarWhereInput>
  }

  export type PaymentCreateNestedOneWithoutCheckDataInput = {
    create?: XOR<PaymentCreateWithoutCheckDataInput, PaymentUncheckedCreateWithoutCheckDataInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutCheckDataInput
    connect?: PaymentWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedOneWithoutCheckDataInput = {
    create?: XOR<PaymentCreateWithoutCheckDataInput, PaymentUncheckedCreateWithoutCheckDataInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutCheckDataInput
    connect?: PaymentWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PaymentUpdateOneWithoutCheckDataInput = {
    create?: XOR<PaymentCreateWithoutCheckDataInput, PaymentUncheckedCreateWithoutCheckDataInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutCheckDataInput
    upsert?: PaymentUpsertWithoutCheckDataInput
    connect?: PaymentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<PaymentUpdateWithoutCheckDataInput, PaymentUncheckedUpdateWithoutCheckDataInput>
  }

  export type PaymentUncheckedUpdateOneWithoutCheckDataInput = {
    create?: XOR<PaymentCreateWithoutCheckDataInput, PaymentUncheckedCreateWithoutCheckDataInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutCheckDataInput
    upsert?: PaymentUpsertWithoutCheckDataInput
    connect?: PaymentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<PaymentUpdateWithoutCheckDataInput, PaymentUncheckedUpdateWithoutCheckDataInput>
  }

  export type EstablishmentCreateNestedOneWithoutClientsInput = {
    create?: XOR<EstablishmentCreateWithoutClientsInput, EstablishmentUncheckedCreateWithoutClientsInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutClientsInput
    connect?: EstablishmentWhereUniqueInput
  }

  export type EstablishmentUpdateOneWithoutClientsInput = {
    create?: XOR<EstablishmentCreateWithoutClientsInput, EstablishmentUncheckedCreateWithoutClientsInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutClientsInput
    upsert?: EstablishmentUpsertWithoutClientsInput
    connect?: EstablishmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EstablishmentUpdateWithoutClientsInput, EstablishmentUncheckedUpdateWithoutClientsInput>
  }

  export type EstablishmentCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<EstablishmentCreateWithoutEmployeesInput, EstablishmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutEmployeesInput
    connect?: EstablishmentWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutEmployeeInput>, Enumerable<OrderItemUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutEmployeeInput>
    createMany?: OrderItemCreateManyEmployeeInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type OrderPadCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<OrderPadCreateWithoutEmployeeInput>, Enumerable<OrderPadUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<OrderPadCreateOrConnectWithoutEmployeeInput>
    createMany?: OrderPadCreateManyEmployeeInputEnvelope
    connect?: Enumerable<OrderPadWhereUniqueInput>
  }

  export type TableDataCreateNestedManyWithoutWaiterInput = {
    create?: XOR<Enumerable<TableDataCreateWithoutWaiterInput>, Enumerable<TableDataUncheckedCreateWithoutWaiterInput>>
    connectOrCreate?: Enumerable<TableDataCreateOrConnectWithoutWaiterInput>
    createMany?: TableDataCreateManyWaiterInputEnvelope
    connect?: Enumerable<TableDataWhereUniqueInput>
  }

  export type WorkHourCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<WorkHourCreateWithoutEmployeeInput>, Enumerable<WorkHourUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<WorkHourCreateOrConnectWithoutEmployeeInput>
    createMany?: WorkHourCreateManyEmployeeInputEnvelope
    connect?: Enumerable<WorkHourWhereUniqueInput>
  }

  export type OrderItemUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutEmployeeInput>, Enumerable<OrderItemUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutEmployeeInput>
    createMany?: OrderItemCreateManyEmployeeInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type OrderPadUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<OrderPadCreateWithoutEmployeeInput>, Enumerable<OrderPadUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<OrderPadCreateOrConnectWithoutEmployeeInput>
    createMany?: OrderPadCreateManyEmployeeInputEnvelope
    connect?: Enumerable<OrderPadWhereUniqueInput>
  }

  export type TableDataUncheckedCreateNestedManyWithoutWaiterInput = {
    create?: XOR<Enumerable<TableDataCreateWithoutWaiterInput>, Enumerable<TableDataUncheckedCreateWithoutWaiterInput>>
    connectOrCreate?: Enumerable<TableDataCreateOrConnectWithoutWaiterInput>
    createMany?: TableDataCreateManyWaiterInputEnvelope
    connect?: Enumerable<TableDataWhereUniqueInput>
  }

  export type WorkHourUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<WorkHourCreateWithoutEmployeeInput>, Enumerable<WorkHourUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<WorkHourCreateOrConnectWithoutEmployeeInput>
    createMany?: WorkHourCreateManyEmployeeInputEnvelope
    connect?: Enumerable<WorkHourWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EstablishmentUpdateOneWithoutEmployeesInput = {
    create?: XOR<EstablishmentCreateWithoutEmployeesInput, EstablishmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutEmployeesInput
    upsert?: EstablishmentUpsertWithoutEmployeesInput
    connect?: EstablishmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EstablishmentUpdateWithoutEmployeesInput, EstablishmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type OrderItemUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutEmployeeInput>, Enumerable<OrderItemUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: OrderItemCreateManyEmployeeInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type OrderPadUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<OrderPadCreateWithoutEmployeeInput>, Enumerable<OrderPadUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<OrderPadCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<OrderPadUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: OrderPadCreateManyEmployeeInputEnvelope
    connect?: Enumerable<OrderPadWhereUniqueInput>
    set?: Enumerable<OrderPadWhereUniqueInput>
    disconnect?: Enumerable<OrderPadWhereUniqueInput>
    delete?: Enumerable<OrderPadWhereUniqueInput>
    update?: Enumerable<OrderPadUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<OrderPadUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<OrderPadScalarWhereInput>
  }

  export type TableDataUpdateManyWithoutWaiterInput = {
    create?: XOR<Enumerable<TableDataCreateWithoutWaiterInput>, Enumerable<TableDataUncheckedCreateWithoutWaiterInput>>
    connectOrCreate?: Enumerable<TableDataCreateOrConnectWithoutWaiterInput>
    upsert?: Enumerable<TableDataUpsertWithWhereUniqueWithoutWaiterInput>
    createMany?: TableDataCreateManyWaiterInputEnvelope
    connect?: Enumerable<TableDataWhereUniqueInput>
    set?: Enumerable<TableDataWhereUniqueInput>
    disconnect?: Enumerable<TableDataWhereUniqueInput>
    delete?: Enumerable<TableDataWhereUniqueInput>
    update?: Enumerable<TableDataUpdateWithWhereUniqueWithoutWaiterInput>
    updateMany?: Enumerable<TableDataUpdateManyWithWhereWithoutWaiterInput>
    deleteMany?: Enumerable<TableDataScalarWhereInput>
  }

  export type WorkHourUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<WorkHourCreateWithoutEmployeeInput>, Enumerable<WorkHourUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<WorkHourCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<WorkHourUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: WorkHourCreateManyEmployeeInputEnvelope
    connect?: Enumerable<WorkHourWhereUniqueInput>
    set?: Enumerable<WorkHourWhereUniqueInput>
    disconnect?: Enumerable<WorkHourWhereUniqueInput>
    delete?: Enumerable<WorkHourWhereUniqueInput>
    update?: Enumerable<WorkHourUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<WorkHourUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<WorkHourScalarWhereInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutEmployeeInput>, Enumerable<OrderItemUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: OrderItemCreateManyEmployeeInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type OrderPadUncheckedUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<OrderPadCreateWithoutEmployeeInput>, Enumerable<OrderPadUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<OrderPadCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<OrderPadUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: OrderPadCreateManyEmployeeInputEnvelope
    connect?: Enumerable<OrderPadWhereUniqueInput>
    set?: Enumerable<OrderPadWhereUniqueInput>
    disconnect?: Enumerable<OrderPadWhereUniqueInput>
    delete?: Enumerable<OrderPadWhereUniqueInput>
    update?: Enumerable<OrderPadUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<OrderPadUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<OrderPadScalarWhereInput>
  }

  export type TableDataUncheckedUpdateManyWithoutWaiterInput = {
    create?: XOR<Enumerable<TableDataCreateWithoutWaiterInput>, Enumerable<TableDataUncheckedCreateWithoutWaiterInput>>
    connectOrCreate?: Enumerable<TableDataCreateOrConnectWithoutWaiterInput>
    upsert?: Enumerable<TableDataUpsertWithWhereUniqueWithoutWaiterInput>
    createMany?: TableDataCreateManyWaiterInputEnvelope
    connect?: Enumerable<TableDataWhereUniqueInput>
    set?: Enumerable<TableDataWhereUniqueInput>
    disconnect?: Enumerable<TableDataWhereUniqueInput>
    delete?: Enumerable<TableDataWhereUniqueInput>
    update?: Enumerable<TableDataUpdateWithWhereUniqueWithoutWaiterInput>
    updateMany?: Enumerable<TableDataUpdateManyWithWhereWithoutWaiterInput>
    deleteMany?: Enumerable<TableDataScalarWhereInput>
  }

  export type WorkHourUncheckedUpdateManyWithoutEmployeeInput = {
    create?: XOR<Enumerable<WorkHourCreateWithoutEmployeeInput>, Enumerable<WorkHourUncheckedCreateWithoutEmployeeInput>>
    connectOrCreate?: Enumerable<WorkHourCreateOrConnectWithoutEmployeeInput>
    upsert?: Enumerable<WorkHourUpsertWithWhereUniqueWithoutEmployeeInput>
    createMany?: WorkHourCreateManyEmployeeInputEnvelope
    connect?: Enumerable<WorkHourWhereUniqueInput>
    set?: Enumerable<WorkHourWhereUniqueInput>
    disconnect?: Enumerable<WorkHourWhereUniqueInput>
    delete?: Enumerable<WorkHourWhereUniqueInput>
    update?: Enumerable<WorkHourUpdateWithWhereUniqueWithoutEmployeeInput>
    updateMany?: Enumerable<WorkHourUpdateManyWithWhereWithoutEmployeeInput>
    deleteMany?: Enumerable<WorkHourScalarWhereInput>
  }

  export type EstablishmentCreatediscountReasonsInput = {
    set: Enumerable<string>
  }

  export type ClientCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<ClientCreateWithoutEstablishmentInput>, Enumerable<ClientUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutEstablishmentInput>
    createMany?: ClientCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<ClientWhereUniqueInput>
  }

  export type EmployeeCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutEstablishmentInput>, Enumerable<EmployeeUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutEstablishmentInput>
    createMany?: EmployeeCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
  }

  export type ExpenseCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutEstablishmentInput>, Enumerable<ExpenseUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutEstablishmentInput>
    createMany?: ExpenseCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<ExpenseWhereUniqueInput>
  }

  export type ItemCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<ItemCreateWithoutEstablishmentInput>, Enumerable<ItemUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutEstablishmentInput>
    createMany?: ItemCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type PermissionCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutEstablishmentInput>, Enumerable<PermissionUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutEstablishmentInput>
    createMany?: PermissionCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<PermissionWhereUniqueInput>
  }

  export type TableCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<TableCreateWithoutEstablishmentInput>, Enumerable<TableUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<TableCreateOrConnectWithoutEstablishmentInput>
    createMany?: TableCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<TableWhereUniqueInput>
  }

  export type WorkDayCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<WorkDayCreateWithoutEstablishmentInput>, Enumerable<WorkDayUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<WorkDayCreateOrConnectWithoutEstablishmentInput>
    createMany?: WorkDayCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<WorkDayWhereUniqueInput>
  }

  export type ClientUncheckedCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<ClientCreateWithoutEstablishmentInput>, Enumerable<ClientUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutEstablishmentInput>
    createMany?: ClientCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<ClientWhereUniqueInput>
  }

  export type EmployeeUncheckedCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutEstablishmentInput>, Enumerable<EmployeeUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutEstablishmentInput>
    createMany?: EmployeeCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
  }

  export type ExpenseUncheckedCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutEstablishmentInput>, Enumerable<ExpenseUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutEstablishmentInput>
    createMany?: ExpenseCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<ExpenseWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<ItemCreateWithoutEstablishmentInput>, Enumerable<ItemUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutEstablishmentInput>
    createMany?: ItemCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type PermissionUncheckedCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutEstablishmentInput>, Enumerable<PermissionUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutEstablishmentInput>
    createMany?: PermissionCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<PermissionWhereUniqueInput>
  }

  export type TableUncheckedCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<TableCreateWithoutEstablishmentInput>, Enumerable<TableUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<TableCreateOrConnectWithoutEstablishmentInput>
    createMany?: TableCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<TableWhereUniqueInput>
  }

  export type WorkDayUncheckedCreateNestedManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<WorkDayCreateWithoutEstablishmentInput>, Enumerable<WorkDayUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<WorkDayCreateOrConnectWithoutEstablishmentInput>
    createMany?: WorkDayCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<WorkDayWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EstablishmentUpdatediscountReasonsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ClientUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<ClientCreateWithoutEstablishmentInput>, Enumerable<ClientUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<ClientUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: ClientCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<ClientWhereUniqueInput>
    set?: Enumerable<ClientWhereUniqueInput>
    disconnect?: Enumerable<ClientWhereUniqueInput>
    delete?: Enumerable<ClientWhereUniqueInput>
    update?: Enumerable<ClientUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<ClientUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<ClientScalarWhereInput>
  }

  export type EmployeeUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutEstablishmentInput>, Enumerable<EmployeeUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<EmployeeUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: EmployeeCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
    set?: Enumerable<EmployeeWhereUniqueInput>
    disconnect?: Enumerable<EmployeeWhereUniqueInput>
    delete?: Enumerable<EmployeeWhereUniqueInput>
    update?: Enumerable<EmployeeUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<EmployeeUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<EmployeeScalarWhereInput>
  }

  export type ExpenseUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutEstablishmentInput>, Enumerable<ExpenseUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<ExpenseUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: ExpenseCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<ExpenseWhereUniqueInput>
    set?: Enumerable<ExpenseWhereUniqueInput>
    disconnect?: Enumerable<ExpenseWhereUniqueInput>
    delete?: Enumerable<ExpenseWhereUniqueInput>
    update?: Enumerable<ExpenseUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<ExpenseUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<ExpenseScalarWhereInput>
  }

  export type ItemUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<ItemCreateWithoutEstablishmentInput>, Enumerable<ItemUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: ItemCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type PermissionUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutEstablishmentInput>, Enumerable<PermissionUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<PermissionUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: PermissionCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<PermissionWhereUniqueInput>
    set?: Enumerable<PermissionWhereUniqueInput>
    disconnect?: Enumerable<PermissionWhereUniqueInput>
    delete?: Enumerable<PermissionWhereUniqueInput>
    update?: Enumerable<PermissionUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<PermissionUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<PermissionScalarWhereInput>
  }

  export type TableUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<TableCreateWithoutEstablishmentInput>, Enumerable<TableUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<TableCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<TableUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: TableCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<TableWhereUniqueInput>
    set?: Enumerable<TableWhereUniqueInput>
    disconnect?: Enumerable<TableWhereUniqueInput>
    delete?: Enumerable<TableWhereUniqueInput>
    update?: Enumerable<TableUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<TableUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<TableScalarWhereInput>
  }

  export type WorkDayUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<WorkDayCreateWithoutEstablishmentInput>, Enumerable<WorkDayUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<WorkDayCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<WorkDayUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: WorkDayCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<WorkDayWhereUniqueInput>
    set?: Enumerable<WorkDayWhereUniqueInput>
    disconnect?: Enumerable<WorkDayWhereUniqueInput>
    delete?: Enumerable<WorkDayWhereUniqueInput>
    update?: Enumerable<WorkDayUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<WorkDayUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<WorkDayScalarWhereInput>
  }

  export type ClientUncheckedUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<ClientCreateWithoutEstablishmentInput>, Enumerable<ClientUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<ClientCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<ClientUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: ClientCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<ClientWhereUniqueInput>
    set?: Enumerable<ClientWhereUniqueInput>
    disconnect?: Enumerable<ClientWhereUniqueInput>
    delete?: Enumerable<ClientWhereUniqueInput>
    update?: Enumerable<ClientUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<ClientUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<ClientScalarWhereInput>
  }

  export type EmployeeUncheckedUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutEstablishmentInput>, Enumerable<EmployeeUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<EmployeeUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: EmployeeCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
    set?: Enumerable<EmployeeWhereUniqueInput>
    disconnect?: Enumerable<EmployeeWhereUniqueInput>
    delete?: Enumerable<EmployeeWhereUniqueInput>
    update?: Enumerable<EmployeeUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<EmployeeUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<EmployeeScalarWhereInput>
  }

  export type ExpenseUncheckedUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutEstablishmentInput>, Enumerable<ExpenseUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<ExpenseUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: ExpenseCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<ExpenseWhereUniqueInput>
    set?: Enumerable<ExpenseWhereUniqueInput>
    disconnect?: Enumerable<ExpenseWhereUniqueInput>
    delete?: Enumerable<ExpenseWhereUniqueInput>
    update?: Enumerable<ExpenseUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<ExpenseUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<ExpenseScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<ItemCreateWithoutEstablishmentInput>, Enumerable<ItemUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: ItemCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type PermissionUncheckedUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutEstablishmentInput>, Enumerable<PermissionUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<PermissionUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: PermissionCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<PermissionWhereUniqueInput>
    set?: Enumerable<PermissionWhereUniqueInput>
    disconnect?: Enumerable<PermissionWhereUniqueInput>
    delete?: Enumerable<PermissionWhereUniqueInput>
    update?: Enumerable<PermissionUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<PermissionUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<PermissionScalarWhereInput>
  }

  export type TableUncheckedUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<TableCreateWithoutEstablishmentInput>, Enumerable<TableUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<TableCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<TableUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: TableCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<TableWhereUniqueInput>
    set?: Enumerable<TableWhereUniqueInput>
    disconnect?: Enumerable<TableWhereUniqueInput>
    delete?: Enumerable<TableWhereUniqueInput>
    update?: Enumerable<TableUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<TableUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<TableScalarWhereInput>
  }

  export type WorkDayUncheckedUpdateManyWithoutEstablishmentInput = {
    create?: XOR<Enumerable<WorkDayCreateWithoutEstablishmentInput>, Enumerable<WorkDayUncheckedCreateWithoutEstablishmentInput>>
    connectOrCreate?: Enumerable<WorkDayCreateOrConnectWithoutEstablishmentInput>
    upsert?: Enumerable<WorkDayUpsertWithWhereUniqueWithoutEstablishmentInput>
    createMany?: WorkDayCreateManyEstablishmentInputEnvelope
    connect?: Enumerable<WorkDayWhereUniqueInput>
    set?: Enumerable<WorkDayWhereUniqueInput>
    disconnect?: Enumerable<WorkDayWhereUniqueInput>
    delete?: Enumerable<WorkDayWhereUniqueInput>
    update?: Enumerable<WorkDayUpdateWithWhereUniqueWithoutEstablishmentInput>
    updateMany?: Enumerable<WorkDayUpdateManyWithWhereWithoutEstablishmentInput>
    deleteMany?: Enumerable<WorkDayScalarWhereInput>
  }

  export type EstablishmentCreateManydiscountReasonsInput = {
    set: Enumerable<string>
  }

  export type EstablishmentCreateNestedOneWithoutExpensesInput = {
    create?: XOR<EstablishmentCreateWithoutExpensesInput, EstablishmentUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutExpensesInput
    connect?: EstablishmentWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutExpenseInput = {
    create?: XOR<PaymentCreateWithoutExpenseInput, PaymentUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutExpenseInput
    connect?: PaymentWhereUniqueInput
  }

  export type ExpenseItemCreateNestedManyWithoutExpenseInput = {
    create?: XOR<Enumerable<ExpenseItemCreateWithoutExpenseInput>, Enumerable<ExpenseItemUncheckedCreateWithoutExpenseInput>>
    connectOrCreate?: Enumerable<ExpenseItemCreateOrConnectWithoutExpenseInput>
    connect?: Enumerable<ExpenseItemWhereUniqueInput>
  }

  export type PaymentUncheckedCreateNestedOneWithoutExpenseInput = {
    create?: XOR<PaymentCreateWithoutExpenseInput, PaymentUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutExpenseInput
    connect?: PaymentWhereUniqueInput
  }

  export type EstablishmentUpdateOneWithoutExpensesInput = {
    create?: XOR<EstablishmentCreateWithoutExpensesInput, EstablishmentUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutExpensesInput
    upsert?: EstablishmentUpsertWithoutExpensesInput
    connect?: EstablishmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EstablishmentUpdateWithoutExpensesInput, EstablishmentUncheckedUpdateWithoutExpensesInput>
  }

  export type PaymentUpdateOneWithoutExpenseInput = {
    create?: XOR<PaymentCreateWithoutExpenseInput, PaymentUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutExpenseInput
    upsert?: PaymentUpsertWithoutExpenseInput
    connect?: PaymentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<PaymentUpdateWithoutExpenseInput, PaymentUncheckedUpdateWithoutExpenseInput>
  }

  export type ExpenseItemUpdateManyWithoutExpenseInput = {
    create?: XOR<Enumerable<ExpenseItemCreateWithoutExpenseInput>, Enumerable<ExpenseItemUncheckedCreateWithoutExpenseInput>>
    connectOrCreate?: Enumerable<ExpenseItemCreateOrConnectWithoutExpenseInput>
    upsert?: Enumerable<ExpenseItemUpsertWithWhereUniqueWithoutExpenseInput>
    connect?: Enumerable<ExpenseItemWhereUniqueInput>
    set?: Enumerable<ExpenseItemWhereUniqueInput>
    disconnect?: Enumerable<ExpenseItemWhereUniqueInput>
    delete?: Enumerable<ExpenseItemWhereUniqueInput>
    update?: Enumerable<ExpenseItemUpdateWithWhereUniqueWithoutExpenseInput>
    updateMany?: Enumerable<ExpenseItemUpdateManyWithWhereWithoutExpenseInput>
    deleteMany?: Enumerable<ExpenseItemScalarWhereInput>
  }

  export type PaymentUncheckedUpdateOneWithoutExpenseInput = {
    create?: XOR<PaymentCreateWithoutExpenseInput, PaymentUncheckedCreateWithoutExpenseInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutExpenseInput
    upsert?: PaymentUpsertWithoutExpenseInput
    connect?: PaymentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<PaymentUpdateWithoutExpenseInput, PaymentUncheckedUpdateWithoutExpenseInput>
  }

  export type ProductCreateNestedOneWithoutExpenseItemInput = {
    create?: XOR<ProductCreateWithoutExpenseItemInput, ProductUncheckedCreateWithoutExpenseItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutExpenseItemInput
    connect?: ProductWhereUniqueInput
  }

  export type ExpenseCreateNestedManyWithoutExpenseItemsInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutExpenseItemsInput>, Enumerable<ExpenseUncheckedCreateWithoutExpenseItemsInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutExpenseItemsInput>
    connect?: Enumerable<ExpenseWhereUniqueInput>
  }

  export type ProductUpdateOneWithoutExpenseItemInput = {
    create?: XOR<ProductCreateWithoutExpenseItemInput, ProductUncheckedCreateWithoutExpenseItemInput>
    connectOrCreate?: ProductCreateOrConnectWithoutExpenseItemInput
    upsert?: ProductUpsertWithoutExpenseItemInput
    connect?: ProductWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ProductUpdateWithoutExpenseItemInput, ProductUncheckedUpdateWithoutExpenseItemInput>
  }

  export type ExpenseUpdateManyWithoutExpenseItemsInput = {
    create?: XOR<Enumerable<ExpenseCreateWithoutExpenseItemsInput>, Enumerable<ExpenseUncheckedCreateWithoutExpenseItemsInput>>
    connectOrCreate?: Enumerable<ExpenseCreateOrConnectWithoutExpenseItemsInput>
    upsert?: Enumerable<ExpenseUpsertWithWhereUniqueWithoutExpenseItemsInput>
    connect?: Enumerable<ExpenseWhereUniqueInput>
    set?: Enumerable<ExpenseWhereUniqueInput>
    disconnect?: Enumerable<ExpenseWhereUniqueInput>
    delete?: Enumerable<ExpenseWhereUniqueInput>
    update?: Enumerable<ExpenseUpdateWithWhereUniqueWithoutExpenseItemsInput>
    updateMany?: Enumerable<ExpenseUpdateManyWithWhereWithoutExpenseItemsInput>
    deleteMany?: Enumerable<ExpenseScalarWhereInput>
  }

  export type WorkDayCreateNestedOneWithoutIncomesInput = {
    create?: XOR<WorkDayCreateWithoutIncomesInput, WorkDayUncheckedCreateWithoutIncomesInput>
    connectOrCreate?: WorkDayCreateOrConnectWithoutIncomesInput
    connect?: WorkDayWhereUniqueInput
  }

  export type WorkDayUpdateOneWithoutIncomesInput = {
    create?: XOR<WorkDayCreateWithoutIncomesInput, WorkDayUncheckedCreateWithoutIncomesInput>
    connectOrCreate?: WorkDayCreateOrConnectWithoutIncomesInput
    upsert?: WorkDayUpsertWithoutIncomesInput
    connect?: WorkDayWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<WorkDayUpdateWithoutIncomesInput, WorkDayUncheckedUpdateWithoutIncomesInput>
  }

  export type EstablishmentCreateNestedOneWithoutItemsInput = {
    create?: XOR<EstablishmentCreateWithoutItemsInput, EstablishmentUncheckedCreateWithoutItemsInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutItemsInput
    connect?: EstablishmentWhereUniqueInput
  }

  export type NCMCreateNestedOneWithoutItemsInput = {
    create?: XOR<NCMCreateWithoutItemsInput, NCMUncheckedCreateWithoutItemsInput>
    connectOrCreate?: NCMCreateOrConnectWithoutItemsInput
    connect?: NCMWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutItemInput>, Enumerable<OrderItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutItemInput>
    createMany?: OrderItemCreateManyItemInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type OrderItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutItemInput>, Enumerable<OrderItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutItemInput>
    createMany?: OrderItemCreateManyItemInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type EstablishmentUpdateOneWithoutItemsInput = {
    create?: XOR<EstablishmentCreateWithoutItemsInput, EstablishmentUncheckedCreateWithoutItemsInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutItemsInput
    upsert?: EstablishmentUpsertWithoutItemsInput
    connect?: EstablishmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EstablishmentUpdateWithoutItemsInput, EstablishmentUncheckedUpdateWithoutItemsInput>
  }

  export type NCMUpdateOneWithoutItemsInput = {
    create?: XOR<NCMCreateWithoutItemsInput, NCMUncheckedCreateWithoutItemsInput>
    connectOrCreate?: NCMCreateOrConnectWithoutItemsInput
    upsert?: NCMUpsertWithoutItemsInput
    connect?: NCMWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<NCMUpdateWithoutItemsInput, NCMUncheckedUpdateWithoutItemsInput>
  }

  export type OrderItemUpdateManyWithoutItemInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutItemInput>, Enumerable<OrderItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutItemInput>
    createMany?: OrderItemCreateManyItemInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutItemInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutItemInput>, Enumerable<OrderItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutItemInput>
    createMany?: OrderItemCreateManyItemInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type ItemCreateNestedManyWithoutItemNCMInput = {
    create?: XOR<Enumerable<ItemCreateWithoutItemNCMInput>, Enumerable<ItemUncheckedCreateWithoutItemNCMInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutItemNCMInput>
    createMany?: ItemCreateManyItemNCMInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutItemNCMInput = {
    create?: XOR<Enumerable<ItemCreateWithoutItemNCMInput>, Enumerable<ItemUncheckedCreateWithoutItemNCMInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutItemNCMInput>
    createMany?: ItemCreateManyItemNCMInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUpdateManyWithoutItemNCMInput = {
    create?: XOR<Enumerable<ItemCreateWithoutItemNCMInput>, Enumerable<ItemUncheckedCreateWithoutItemNCMInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutItemNCMInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutItemNCMInput>
    createMany?: ItemCreateManyItemNCMInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutItemNCMInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutItemNCMInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutItemNCMInput = {
    create?: XOR<Enumerable<ItemCreateWithoutItemNCMInput>, Enumerable<ItemUncheckedCreateWithoutItemNCMInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutItemNCMInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutItemNCMInput>
    createMany?: ItemCreateManyItemNCMInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutItemNCMInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutItemNCMInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type BillCreateNestedOneWithoutOrdersInput = {
    create?: XOR<BillCreateWithoutOrdersInput, BillUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BillCreateOrConnectWithoutOrdersInput
    connect?: BillWhereUniqueInput
  }

  export type WorkDayCreateNestedOneWithoutOrdersInput = {
    create?: XOR<WorkDayCreateWithoutOrdersInput, WorkDayUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: WorkDayCreateOrConnectWithoutOrdersInput
    connect?: WorkDayWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutModifiedOrdersInput = {
    create?: XOR<Enumerable<OrderCreateWithoutModifiedOrdersInput>, Enumerable<OrderUncheckedCreateWithoutModifiedOrdersInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutModifiedOrdersInput>
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutModifiedOrdersIdInput = {
    create?: XOR<Enumerable<OrderCreateWithoutModifiedOrdersIdInput>, Enumerable<OrderUncheckedCreateWithoutModifiedOrdersIdInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutModifiedOrdersIdInput>
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
  }

  export type BillUpdateOneWithoutOrdersInput = {
    create?: XOR<BillCreateWithoutOrdersInput, BillUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: BillCreateOrConnectWithoutOrdersInput
    upsert?: BillUpsertWithoutOrdersInput
    connect?: BillWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<BillUpdateWithoutOrdersInput, BillUncheckedUpdateWithoutOrdersInput>
  }

  export type WorkDayUpdateOneWithoutOrdersInput = {
    create?: XOR<WorkDayCreateWithoutOrdersInput, WorkDayUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: WorkDayCreateOrConnectWithoutOrdersInput
    upsert?: WorkDayUpsertWithoutOrdersInput
    connect?: WorkDayWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<WorkDayUpdateWithoutOrdersInput, WorkDayUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type OrderUpdateManyWithoutModifiedOrdersInput = {
    create?: XOR<Enumerable<OrderCreateWithoutModifiedOrdersInput>, Enumerable<OrderUncheckedCreateWithoutModifiedOrdersInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutModifiedOrdersInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutModifiedOrdersInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutModifiedOrdersInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutModifiedOrdersInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderUpdateManyWithoutModifiedOrdersIdInput = {
    create?: XOR<Enumerable<OrderCreateWithoutModifiedOrdersIdInput>, Enumerable<OrderUncheckedCreateWithoutModifiedOrdersIdInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutModifiedOrdersIdInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutModifiedOrdersIdInput>
    connect?: Enumerable<OrderWhereUniqueInput>
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutModifiedOrdersIdInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutModifiedOrdersIdInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    create?: XOR<Enumerable<OrderItemCreateWithoutOrderInput>, Enumerable<OrderItemUncheckedCreateWithoutOrderInput>>
    connectOrCreate?: Enumerable<OrderItemCreateOrConnectWithoutOrderInput>
    upsert?: Enumerable<OrderItemUpsertWithWhereUniqueWithoutOrderInput>
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: Enumerable<OrderItemWhereUniqueInput>
    set?: Enumerable<OrderItemWhereUniqueInput>
    disconnect?: Enumerable<OrderItemWhereUniqueInput>
    delete?: Enumerable<OrderItemWhereUniqueInput>
    update?: Enumerable<OrderItemUpdateWithWhereUniqueWithoutOrderInput>
    updateMany?: Enumerable<OrderItemUpdateManyWithWhereWithoutOrderInput>
    deleteMany?: Enumerable<OrderItemScalarWhereInput>
  }

  export type EmployeeCreateNestedOneWithoutItemsOrderedInput = {
    create?: XOR<EmployeeCreateWithoutItemsOrderedInput, EmployeeUncheckedCreateWithoutItemsOrderedInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutItemsOrderedInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutOrderItemInput = {
    create?: XOR<ItemCreateWithoutOrderItemInput, ItemUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ItemCreateOrConnectWithoutOrderItemInput
    connect?: ItemWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type EmployeeUpdateOneWithoutItemsOrderedInput = {
    create?: XOR<EmployeeCreateWithoutItemsOrderedInput, EmployeeUncheckedCreateWithoutItemsOrderedInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutItemsOrderedInput
    upsert?: EmployeeUpsertWithoutItemsOrderedInput
    connect?: EmployeeWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EmployeeUpdateWithoutItemsOrderedInput, EmployeeUncheckedUpdateWithoutItemsOrderedInput>
  }

  export type ItemUpdateOneWithoutOrderItemInput = {
    create?: XOR<ItemCreateWithoutOrderItemInput, ItemUncheckedCreateWithoutOrderItemInput>
    connectOrCreate?: ItemCreateOrConnectWithoutOrderItemInput
    upsert?: ItemUpsertWithoutOrderItemInput
    connect?: ItemWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ItemUpdateWithoutOrderItemInput, ItemUncheckedUpdateWithoutOrderItemInput>
  }

  export type OrderUpdateOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderUpsertWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type EmployeeCreateNestedOneWithoutOrderPadsInput = {
    create?: XOR<EmployeeCreateWithoutOrderPadsInput, EmployeeUncheckedCreateWithoutOrderPadsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOrderPadsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type WorkDayCreateNestedOneWithoutOrderPadsInput = {
    create?: XOR<WorkDayCreateWithoutOrderPadsInput, WorkDayUncheckedCreateWithoutOrderPadsInput>
    connectOrCreate?: WorkDayCreateOrConnectWithoutOrderPadsInput
    connect?: WorkDayWhereUniqueInput
  }

  export type EmployeeUpdateOneWithoutOrderPadsInput = {
    create?: XOR<EmployeeCreateWithoutOrderPadsInput, EmployeeUncheckedCreateWithoutOrderPadsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOrderPadsInput
    upsert?: EmployeeUpsertWithoutOrderPadsInput
    connect?: EmployeeWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EmployeeUpdateWithoutOrderPadsInput, EmployeeUncheckedUpdateWithoutOrderPadsInput>
  }

  export type WorkDayUpdateOneWithoutOrderPadsInput = {
    create?: XOR<WorkDayCreateWithoutOrderPadsInput, WorkDayUncheckedCreateWithoutOrderPadsInput>
    connectOrCreate?: WorkDayCreateOrConnectWithoutOrderPadsInput
    upsert?: WorkDayUpsertWithoutOrderPadsInput
    connect?: WorkDayWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<WorkDayUpdateWithoutOrderPadsInput, WorkDayUncheckedUpdateWithoutOrderPadsInput>
  }

  export type BillCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BillCreateWithoutPaymentsInput, BillUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillCreateOrConnectWithoutPaymentsInput
    connect?: BillWhereUniqueInput
  }

  export type CheckDataCreateNestedOneWithoutPaymentInput = {
    create?: XOR<CheckDataCreateWithoutPaymentInput, CheckDataUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: CheckDataCreateOrConnectWithoutPaymentInput
    connect?: CheckDataWhereUniqueInput
  }

  export type ExpenseCreateNestedOneWithoutPaymentInput = {
    create?: XOR<ExpenseCreateWithoutPaymentInput, ExpenseUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutPaymentInput
    connect?: ExpenseWhereUniqueInput
  }

  export type BillUpdateOneWithoutPaymentsInput = {
    create?: XOR<BillCreateWithoutPaymentsInput, BillUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BillCreateOrConnectWithoutPaymentsInput
    upsert?: BillUpsertWithoutPaymentsInput
    connect?: BillWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<BillUpdateWithoutPaymentsInput, BillUncheckedUpdateWithoutPaymentsInput>
  }

  export type CheckDataUpdateOneWithoutPaymentInput = {
    create?: XOR<CheckDataCreateWithoutPaymentInput, CheckDataUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: CheckDataCreateOrConnectWithoutPaymentInput
    upsert?: CheckDataUpsertWithoutPaymentInput
    connect?: CheckDataWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CheckDataUpdateWithoutPaymentInput, CheckDataUncheckedUpdateWithoutPaymentInput>
  }

  export type ExpenseUpdateOneWithoutPaymentInput = {
    create?: XOR<ExpenseCreateWithoutPaymentInput, ExpenseUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ExpenseCreateOrConnectWithoutPaymentInput
    upsert?: ExpenseUpsertWithoutPaymentInput
    connect?: ExpenseWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ExpenseUpdateWithoutPaymentInput, ExpenseUncheckedUpdateWithoutPaymentInput>
  }

  export type EstablishmentCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<EstablishmentCreateWithoutPermissionsInput, EstablishmentUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutPermissionsInput
    connect?: EstablishmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: UserRole
  }

  export type EstablishmentUpdateOneWithoutPermissionsInput = {
    create?: XOR<EstablishmentCreateWithoutPermissionsInput, EstablishmentUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutPermissionsInput
    upsert?: EstablishmentUpsertWithoutPermissionsInput
    connect?: EstablishmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EstablishmentUpdateWithoutPermissionsInput, EstablishmentUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserUpdateOneWithoutPermissionsInput = {
    create?: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPermissionsInput
    upsert?: UserUpsertWithoutPermissionsInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
  }

  export type ExpenseItemCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ExpenseItemCreateWithoutProductInput>, Enumerable<ExpenseItemUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ExpenseItemCreateOrConnectWithoutProductInput>
    createMany?: ExpenseItemCreateManyProductInputEnvelope
    connect?: Enumerable<ExpenseItemWhereUniqueInput>
  }

  export type ExpenseItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<ExpenseItemCreateWithoutProductInput>, Enumerable<ExpenseItemUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ExpenseItemCreateOrConnectWithoutProductInput>
    createMany?: ExpenseItemCreateManyProductInputEnvelope
    connect?: Enumerable<ExpenseItemWhereUniqueInput>
  }

  export type ExpenseItemUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<ExpenseItemCreateWithoutProductInput>, Enumerable<ExpenseItemUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ExpenseItemCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ExpenseItemUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ExpenseItemCreateManyProductInputEnvelope
    connect?: Enumerable<ExpenseItemWhereUniqueInput>
    set?: Enumerable<ExpenseItemWhereUniqueInput>
    disconnect?: Enumerable<ExpenseItemWhereUniqueInput>
    delete?: Enumerable<ExpenseItemWhereUniqueInput>
    update?: Enumerable<ExpenseItemUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ExpenseItemUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ExpenseItemScalarWhereInput>
  }

  export type ExpenseItemUncheckedUpdateManyWithoutProductInput = {
    create?: XOR<Enumerable<ExpenseItemCreateWithoutProductInput>, Enumerable<ExpenseItemUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<ExpenseItemCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<ExpenseItemUpsertWithWhereUniqueWithoutProductInput>
    createMany?: ExpenseItemCreateManyProductInputEnvelope
    connect?: Enumerable<ExpenseItemWhereUniqueInput>
    set?: Enumerable<ExpenseItemWhereUniqueInput>
    disconnect?: Enumerable<ExpenseItemWhereUniqueInput>
    delete?: Enumerable<ExpenseItemWhereUniqueInput>
    update?: Enumerable<ExpenseItemUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<ExpenseItemUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<ExpenseItemScalarWhereInput>
  }

  export type EstablishmentCreateNestedOneWithoutTablesInput = {
    create?: XOR<EstablishmentCreateWithoutTablesInput, EstablishmentUncheckedCreateWithoutTablesInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutTablesInput
    connect?: EstablishmentWhereUniqueInput
  }

  export type TableDataCreateNestedManyWithoutTableInput = {
    create?: XOR<Enumerable<TableDataCreateWithoutTableInput>, Enumerable<TableDataUncheckedCreateWithoutTableInput>>
    connectOrCreate?: Enumerable<TableDataCreateOrConnectWithoutTableInput>
    createMany?: TableDataCreateManyTableInputEnvelope
    connect?: Enumerable<TableDataWhereUniqueInput>
  }

  export type TableDataUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<Enumerable<TableDataCreateWithoutTableInput>, Enumerable<TableDataUncheckedCreateWithoutTableInput>>
    connectOrCreate?: Enumerable<TableDataCreateOrConnectWithoutTableInput>
    createMany?: TableDataCreateManyTableInputEnvelope
    connect?: Enumerable<TableDataWhereUniqueInput>
  }

  export type EstablishmentUpdateOneWithoutTablesInput = {
    create?: XOR<EstablishmentCreateWithoutTablesInput, EstablishmentUncheckedCreateWithoutTablesInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutTablesInput
    upsert?: EstablishmentUpsertWithoutTablesInput
    connect?: EstablishmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EstablishmentUpdateWithoutTablesInput, EstablishmentUncheckedUpdateWithoutTablesInput>
  }

  export type TableDataUpdateManyWithoutTableInput = {
    create?: XOR<Enumerable<TableDataCreateWithoutTableInput>, Enumerable<TableDataUncheckedCreateWithoutTableInput>>
    connectOrCreate?: Enumerable<TableDataCreateOrConnectWithoutTableInput>
    upsert?: Enumerable<TableDataUpsertWithWhereUniqueWithoutTableInput>
    createMany?: TableDataCreateManyTableInputEnvelope
    connect?: Enumerable<TableDataWhereUniqueInput>
    set?: Enumerable<TableDataWhereUniqueInput>
    disconnect?: Enumerable<TableDataWhereUniqueInput>
    delete?: Enumerable<TableDataWhereUniqueInput>
    update?: Enumerable<TableDataUpdateWithWhereUniqueWithoutTableInput>
    updateMany?: Enumerable<TableDataUpdateManyWithWhereWithoutTableInput>
    deleteMany?: Enumerable<TableDataScalarWhereInput>
  }

  export type TableDataUncheckedUpdateManyWithoutTableInput = {
    create?: XOR<Enumerable<TableDataCreateWithoutTableInput>, Enumerable<TableDataUncheckedCreateWithoutTableInput>>
    connectOrCreate?: Enumerable<TableDataCreateOrConnectWithoutTableInput>
    upsert?: Enumerable<TableDataUpsertWithWhereUniqueWithoutTableInput>
    createMany?: TableDataCreateManyTableInputEnvelope
    connect?: Enumerable<TableDataWhereUniqueInput>
    set?: Enumerable<TableDataWhereUniqueInput>
    disconnect?: Enumerable<TableDataWhereUniqueInput>
    delete?: Enumerable<TableDataWhereUniqueInput>
    update?: Enumerable<TableDataUpdateWithWhereUniqueWithoutTableInput>
    updateMany?: Enumerable<TableDataUpdateManyWithWhereWithoutTableInput>
    deleteMany?: Enumerable<TableDataScalarWhereInput>
  }

  export type TableCreateNestedOneWithoutDataInput = {
    create?: XOR<TableCreateWithoutDataInput, TableUncheckedCreateWithoutDataInput>
    connectOrCreate?: TableCreateOrConnectWithoutDataInput
    connect?: TableWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutTablesInput = {
    create?: XOR<EmployeeCreateWithoutTablesInput, EmployeeUncheckedCreateWithoutTablesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTablesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type WorkDayCreateNestedOneWithoutTablesInput = {
    create?: XOR<WorkDayCreateWithoutTablesInput, WorkDayUncheckedCreateWithoutTablesInput>
    connectOrCreate?: WorkDayCreateOrConnectWithoutTablesInput
    connect?: WorkDayWhereUniqueInput
  }

  export type BillCreateNestedManyWithoutTableDataInput = {
    create?: XOR<Enumerable<BillCreateWithoutTableDataInput>, Enumerable<BillUncheckedCreateWithoutTableDataInput>>
    connectOrCreate?: Enumerable<BillCreateOrConnectWithoutTableDataInput>
    createMany?: BillCreateManyTableDataInputEnvelope
    connect?: Enumerable<BillWhereUniqueInput>
  }

  export type BillUncheckedCreateNestedManyWithoutTableDataInput = {
    create?: XOR<Enumerable<BillCreateWithoutTableDataInput>, Enumerable<BillUncheckedCreateWithoutTableDataInput>>
    connectOrCreate?: Enumerable<BillCreateOrConnectWithoutTableDataInput>
    createMany?: BillCreateManyTableDataInputEnvelope
    connect?: Enumerable<BillWhereUniqueInput>
  }

  export type TableUpdateOneWithoutDataInput = {
    create?: XOR<TableCreateWithoutDataInput, TableUncheckedCreateWithoutDataInput>
    connectOrCreate?: TableCreateOrConnectWithoutDataInput
    upsert?: TableUpsertWithoutDataInput
    connect?: TableWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TableUpdateWithoutDataInput, TableUncheckedUpdateWithoutDataInput>
  }

  export type EmployeeUpdateOneWithoutTablesInput = {
    create?: XOR<EmployeeCreateWithoutTablesInput, EmployeeUncheckedCreateWithoutTablesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTablesInput
    upsert?: EmployeeUpsertWithoutTablesInput
    connect?: EmployeeWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EmployeeUpdateWithoutTablesInput, EmployeeUncheckedUpdateWithoutTablesInput>
  }

  export type WorkDayUpdateOneWithoutTablesInput = {
    create?: XOR<WorkDayCreateWithoutTablesInput, WorkDayUncheckedCreateWithoutTablesInput>
    connectOrCreate?: WorkDayCreateOrConnectWithoutTablesInput
    upsert?: WorkDayUpsertWithoutTablesInput
    connect?: WorkDayWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<WorkDayUpdateWithoutTablesInput, WorkDayUncheckedUpdateWithoutTablesInput>
  }

  export type BillUpdateManyWithoutTableDataInput = {
    create?: XOR<Enumerable<BillCreateWithoutTableDataInput>, Enumerable<BillUncheckedCreateWithoutTableDataInput>>
    connectOrCreate?: Enumerable<BillCreateOrConnectWithoutTableDataInput>
    upsert?: Enumerable<BillUpsertWithWhereUniqueWithoutTableDataInput>
    createMany?: BillCreateManyTableDataInputEnvelope
    connect?: Enumerable<BillWhereUniqueInput>
    set?: Enumerable<BillWhereUniqueInput>
    disconnect?: Enumerable<BillWhereUniqueInput>
    delete?: Enumerable<BillWhereUniqueInput>
    update?: Enumerable<BillUpdateWithWhereUniqueWithoutTableDataInput>
    updateMany?: Enumerable<BillUpdateManyWithWhereWithoutTableDataInput>
    deleteMany?: Enumerable<BillScalarWhereInput>
  }

  export type BillUncheckedUpdateManyWithoutTableDataInput = {
    create?: XOR<Enumerable<BillCreateWithoutTableDataInput>, Enumerable<BillUncheckedCreateWithoutTableDataInput>>
    connectOrCreate?: Enumerable<BillCreateOrConnectWithoutTableDataInput>
    upsert?: Enumerable<BillUpsertWithWhereUniqueWithoutTableDataInput>
    createMany?: BillCreateManyTableDataInputEnvelope
    connect?: Enumerable<BillWhereUniqueInput>
    set?: Enumerable<BillWhereUniqueInput>
    disconnect?: Enumerable<BillWhereUniqueInput>
    delete?: Enumerable<BillWhereUniqueInput>
    update?: Enumerable<BillUpdateWithWhereUniqueWithoutTableDataInput>
    updateMany?: Enumerable<BillUpdateManyWithWhereWithoutTableDataInput>
    deleteMany?: Enumerable<BillScalarWhereInput>
  }

  export type PermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutUserInput>, Enumerable<PermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutUserInput>
    createMany?: PermissionCreateManyUserInputEnvelope
    connect?: Enumerable<PermissionWhereUniqueInput>
  }

  export type WorkDayCreateNestedManyWithoutUserResponsibleInput = {
    create?: XOR<Enumerable<WorkDayCreateWithoutUserResponsibleInput>, Enumerable<WorkDayUncheckedCreateWithoutUserResponsibleInput>>
    connectOrCreate?: Enumerable<WorkDayCreateOrConnectWithoutUserResponsibleInput>
    createMany?: WorkDayCreateManyUserResponsibleInputEnvelope
    connect?: Enumerable<WorkDayWhereUniqueInput>
  }

  export type PermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutUserInput>, Enumerable<PermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutUserInput>
    createMany?: PermissionCreateManyUserInputEnvelope
    connect?: Enumerable<PermissionWhereUniqueInput>
  }

  export type WorkDayUncheckedCreateNestedManyWithoutUserResponsibleInput = {
    create?: XOR<Enumerable<WorkDayCreateWithoutUserResponsibleInput>, Enumerable<WorkDayUncheckedCreateWithoutUserResponsibleInput>>
    connectOrCreate?: Enumerable<WorkDayCreateOrConnectWithoutUserResponsibleInput>
    createMany?: WorkDayCreateManyUserResponsibleInputEnvelope
    connect?: Enumerable<WorkDayWhereUniqueInput>
  }

  export type PermissionUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutUserInput>, Enumerable<PermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PermissionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PermissionCreateManyUserInputEnvelope
    connect?: Enumerable<PermissionWhereUniqueInput>
    set?: Enumerable<PermissionWhereUniqueInput>
    disconnect?: Enumerable<PermissionWhereUniqueInput>
    delete?: Enumerable<PermissionWhereUniqueInput>
    update?: Enumerable<PermissionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PermissionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PermissionScalarWhereInput>
  }

  export type WorkDayUpdateManyWithoutUserResponsibleInput = {
    create?: XOR<Enumerable<WorkDayCreateWithoutUserResponsibleInput>, Enumerable<WorkDayUncheckedCreateWithoutUserResponsibleInput>>
    connectOrCreate?: Enumerable<WorkDayCreateOrConnectWithoutUserResponsibleInput>
    upsert?: Enumerable<WorkDayUpsertWithWhereUniqueWithoutUserResponsibleInput>
    createMany?: WorkDayCreateManyUserResponsibleInputEnvelope
    connect?: Enumerable<WorkDayWhereUniqueInput>
    set?: Enumerable<WorkDayWhereUniqueInput>
    disconnect?: Enumerable<WorkDayWhereUniqueInput>
    delete?: Enumerable<WorkDayWhereUniqueInput>
    update?: Enumerable<WorkDayUpdateWithWhereUniqueWithoutUserResponsibleInput>
    updateMany?: Enumerable<WorkDayUpdateManyWithWhereWithoutUserResponsibleInput>
    deleteMany?: Enumerable<WorkDayScalarWhereInput>
  }

  export type PermissionUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutUserInput>, Enumerable<PermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PermissionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PermissionCreateManyUserInputEnvelope
    connect?: Enumerable<PermissionWhereUniqueInput>
    set?: Enumerable<PermissionWhereUniqueInput>
    disconnect?: Enumerable<PermissionWhereUniqueInput>
    delete?: Enumerable<PermissionWhereUniqueInput>
    update?: Enumerable<PermissionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PermissionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PermissionScalarWhereInput>
  }

  export type WorkDayUncheckedUpdateManyWithoutUserResponsibleInput = {
    create?: XOR<Enumerable<WorkDayCreateWithoutUserResponsibleInput>, Enumerable<WorkDayUncheckedCreateWithoutUserResponsibleInput>>
    connectOrCreate?: Enumerable<WorkDayCreateOrConnectWithoutUserResponsibleInput>
    upsert?: Enumerable<WorkDayUpsertWithWhereUniqueWithoutUserResponsibleInput>
    createMany?: WorkDayCreateManyUserResponsibleInputEnvelope
    connect?: Enumerable<WorkDayWhereUniqueInput>
    set?: Enumerable<WorkDayWhereUniqueInput>
    disconnect?: Enumerable<WorkDayWhereUniqueInput>
    delete?: Enumerable<WorkDayWhereUniqueInput>
    update?: Enumerable<WorkDayUpdateWithWhereUniqueWithoutUserResponsibleInput>
    updateMany?: Enumerable<WorkDayUpdateManyWithWhereWithoutUserResponsibleInput>
    deleteMany?: Enumerable<WorkDayScalarWhereInput>
  }

  export type EstablishmentCreateNestedOneWithoutWorkingDaysInput = {
    create?: XOR<EstablishmentCreateWithoutWorkingDaysInput, EstablishmentUncheckedCreateWithoutWorkingDaysInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutWorkingDaysInput
    connect?: EstablishmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResponsibleWorkDaysInput = {
    create?: XOR<UserCreateWithoutResponsibleWorkDaysInput, UserUncheckedCreateWithoutResponsibleWorkDaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponsibleWorkDaysInput
    connect?: UserWhereUniqueInput
  }

  export type BillCreateNestedManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<BillCreateWithoutWorkDayInput>, Enumerable<BillUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<BillCreateOrConnectWithoutWorkDayInput>
    createMany?: BillCreateManyWorkDayInputEnvelope
    connect?: Enumerable<BillWhereUniqueInput>
  }

  export type IncomeCreateNestedManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<IncomeCreateWithoutWorkDayInput>, Enumerable<IncomeUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<IncomeCreateOrConnectWithoutWorkDayInput>
    createMany?: IncomeCreateManyWorkDayInputEnvelope
    connect?: Enumerable<IncomeWhereUniqueInput>
  }

  export type OrderCreateNestedManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<OrderCreateWithoutWorkDayInput>, Enumerable<OrderUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutWorkDayInput>
    createMany?: OrderCreateManyWorkDayInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderPadCreateNestedManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<OrderPadCreateWithoutWorkDayInput>, Enumerable<OrderPadUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<OrderPadCreateOrConnectWithoutWorkDayInput>
    createMany?: OrderPadCreateManyWorkDayInputEnvelope
    connect?: Enumerable<OrderPadWhereUniqueInput>
  }

  export type TableDataCreateNestedManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<TableDataCreateWithoutWorkDayInput>, Enumerable<TableDataUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<TableDataCreateOrConnectWithoutWorkDayInput>
    createMany?: TableDataCreateManyWorkDayInputEnvelope
    connect?: Enumerable<TableDataWhereUniqueInput>
  }

  export type BillUncheckedCreateNestedManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<BillCreateWithoutWorkDayInput>, Enumerable<BillUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<BillCreateOrConnectWithoutWorkDayInput>
    createMany?: BillCreateManyWorkDayInputEnvelope
    connect?: Enumerable<BillWhereUniqueInput>
  }

  export type IncomeUncheckedCreateNestedManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<IncomeCreateWithoutWorkDayInput>, Enumerable<IncomeUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<IncomeCreateOrConnectWithoutWorkDayInput>
    createMany?: IncomeCreateManyWorkDayInputEnvelope
    connect?: Enumerable<IncomeWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<OrderCreateWithoutWorkDayInput>, Enumerable<OrderUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutWorkDayInput>
    createMany?: OrderCreateManyWorkDayInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
  }

  export type OrderPadUncheckedCreateNestedManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<OrderPadCreateWithoutWorkDayInput>, Enumerable<OrderPadUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<OrderPadCreateOrConnectWithoutWorkDayInput>
    createMany?: OrderPadCreateManyWorkDayInputEnvelope
    connect?: Enumerable<OrderPadWhereUniqueInput>
  }

  export type TableDataUncheckedCreateNestedManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<TableDataCreateWithoutWorkDayInput>, Enumerable<TableDataUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<TableDataCreateOrConnectWithoutWorkDayInput>
    createMany?: TableDataCreateManyWorkDayInputEnvelope
    connect?: Enumerable<TableDataWhereUniqueInput>
  }

  export type EstablishmentUpdateOneWithoutWorkingDaysInput = {
    create?: XOR<EstablishmentCreateWithoutWorkingDaysInput, EstablishmentUncheckedCreateWithoutWorkingDaysInput>
    connectOrCreate?: EstablishmentCreateOrConnectWithoutWorkingDaysInput
    upsert?: EstablishmentUpsertWithoutWorkingDaysInput
    connect?: EstablishmentWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EstablishmentUpdateWithoutWorkingDaysInput, EstablishmentUncheckedUpdateWithoutWorkingDaysInput>
  }

  export type UserUpdateOneWithoutResponsibleWorkDaysInput = {
    create?: XOR<UserCreateWithoutResponsibleWorkDaysInput, UserUncheckedCreateWithoutResponsibleWorkDaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponsibleWorkDaysInput
    upsert?: UserUpsertWithoutResponsibleWorkDaysInput
    connect?: UserWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<UserUpdateWithoutResponsibleWorkDaysInput, UserUncheckedUpdateWithoutResponsibleWorkDaysInput>
  }

  export type BillUpdateManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<BillCreateWithoutWorkDayInput>, Enumerable<BillUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<BillCreateOrConnectWithoutWorkDayInput>
    upsert?: Enumerable<BillUpsertWithWhereUniqueWithoutWorkDayInput>
    createMany?: BillCreateManyWorkDayInputEnvelope
    connect?: Enumerable<BillWhereUniqueInput>
    set?: Enumerable<BillWhereUniqueInput>
    disconnect?: Enumerable<BillWhereUniqueInput>
    delete?: Enumerable<BillWhereUniqueInput>
    update?: Enumerable<BillUpdateWithWhereUniqueWithoutWorkDayInput>
    updateMany?: Enumerable<BillUpdateManyWithWhereWithoutWorkDayInput>
    deleteMany?: Enumerable<BillScalarWhereInput>
  }

  export type IncomeUpdateManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<IncomeCreateWithoutWorkDayInput>, Enumerable<IncomeUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<IncomeCreateOrConnectWithoutWorkDayInput>
    upsert?: Enumerable<IncomeUpsertWithWhereUniqueWithoutWorkDayInput>
    createMany?: IncomeCreateManyWorkDayInputEnvelope
    connect?: Enumerable<IncomeWhereUniqueInput>
    set?: Enumerable<IncomeWhereUniqueInput>
    disconnect?: Enumerable<IncomeWhereUniqueInput>
    delete?: Enumerable<IncomeWhereUniqueInput>
    update?: Enumerable<IncomeUpdateWithWhereUniqueWithoutWorkDayInput>
    updateMany?: Enumerable<IncomeUpdateManyWithWhereWithoutWorkDayInput>
    deleteMany?: Enumerable<IncomeScalarWhereInput>
  }

  export type OrderUpdateManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<OrderCreateWithoutWorkDayInput>, Enumerable<OrderUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutWorkDayInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutWorkDayInput>
    createMany?: OrderCreateManyWorkDayInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutWorkDayInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutWorkDayInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderPadUpdateManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<OrderPadCreateWithoutWorkDayInput>, Enumerable<OrderPadUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<OrderPadCreateOrConnectWithoutWorkDayInput>
    upsert?: Enumerable<OrderPadUpsertWithWhereUniqueWithoutWorkDayInput>
    createMany?: OrderPadCreateManyWorkDayInputEnvelope
    connect?: Enumerable<OrderPadWhereUniqueInput>
    set?: Enumerable<OrderPadWhereUniqueInput>
    disconnect?: Enumerable<OrderPadWhereUniqueInput>
    delete?: Enumerable<OrderPadWhereUniqueInput>
    update?: Enumerable<OrderPadUpdateWithWhereUniqueWithoutWorkDayInput>
    updateMany?: Enumerable<OrderPadUpdateManyWithWhereWithoutWorkDayInput>
    deleteMany?: Enumerable<OrderPadScalarWhereInput>
  }

  export type TableDataUpdateManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<TableDataCreateWithoutWorkDayInput>, Enumerable<TableDataUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<TableDataCreateOrConnectWithoutWorkDayInput>
    upsert?: Enumerable<TableDataUpsertWithWhereUniqueWithoutWorkDayInput>
    createMany?: TableDataCreateManyWorkDayInputEnvelope
    connect?: Enumerable<TableDataWhereUniqueInput>
    set?: Enumerable<TableDataWhereUniqueInput>
    disconnect?: Enumerable<TableDataWhereUniqueInput>
    delete?: Enumerable<TableDataWhereUniqueInput>
    update?: Enumerable<TableDataUpdateWithWhereUniqueWithoutWorkDayInput>
    updateMany?: Enumerable<TableDataUpdateManyWithWhereWithoutWorkDayInput>
    deleteMany?: Enumerable<TableDataScalarWhereInput>
  }

  export type BillUncheckedUpdateManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<BillCreateWithoutWorkDayInput>, Enumerable<BillUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<BillCreateOrConnectWithoutWorkDayInput>
    upsert?: Enumerable<BillUpsertWithWhereUniqueWithoutWorkDayInput>
    createMany?: BillCreateManyWorkDayInputEnvelope
    connect?: Enumerable<BillWhereUniqueInput>
    set?: Enumerable<BillWhereUniqueInput>
    disconnect?: Enumerable<BillWhereUniqueInput>
    delete?: Enumerable<BillWhereUniqueInput>
    update?: Enumerable<BillUpdateWithWhereUniqueWithoutWorkDayInput>
    updateMany?: Enumerable<BillUpdateManyWithWhereWithoutWorkDayInput>
    deleteMany?: Enumerable<BillScalarWhereInput>
  }

  export type IncomeUncheckedUpdateManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<IncomeCreateWithoutWorkDayInput>, Enumerable<IncomeUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<IncomeCreateOrConnectWithoutWorkDayInput>
    upsert?: Enumerable<IncomeUpsertWithWhereUniqueWithoutWorkDayInput>
    createMany?: IncomeCreateManyWorkDayInputEnvelope
    connect?: Enumerable<IncomeWhereUniqueInput>
    set?: Enumerable<IncomeWhereUniqueInput>
    disconnect?: Enumerable<IncomeWhereUniqueInput>
    delete?: Enumerable<IncomeWhereUniqueInput>
    update?: Enumerable<IncomeUpdateWithWhereUniqueWithoutWorkDayInput>
    updateMany?: Enumerable<IncomeUpdateManyWithWhereWithoutWorkDayInput>
    deleteMany?: Enumerable<IncomeScalarWhereInput>
  }

  export type OrderUncheckedUpdateManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<OrderCreateWithoutWorkDayInput>, Enumerable<OrderUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<OrderCreateOrConnectWithoutWorkDayInput>
    upsert?: Enumerable<OrderUpsertWithWhereUniqueWithoutWorkDayInput>
    createMany?: OrderCreateManyWorkDayInputEnvelope
    connect?: Enumerable<OrderWhereUniqueInput>
    set?: Enumerable<OrderWhereUniqueInput>
    disconnect?: Enumerable<OrderWhereUniqueInput>
    delete?: Enumerable<OrderWhereUniqueInput>
    update?: Enumerable<OrderUpdateWithWhereUniqueWithoutWorkDayInput>
    updateMany?: Enumerable<OrderUpdateManyWithWhereWithoutWorkDayInput>
    deleteMany?: Enumerable<OrderScalarWhereInput>
  }

  export type OrderPadUncheckedUpdateManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<OrderPadCreateWithoutWorkDayInput>, Enumerable<OrderPadUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<OrderPadCreateOrConnectWithoutWorkDayInput>
    upsert?: Enumerable<OrderPadUpsertWithWhereUniqueWithoutWorkDayInput>
    createMany?: OrderPadCreateManyWorkDayInputEnvelope
    connect?: Enumerable<OrderPadWhereUniqueInput>
    set?: Enumerable<OrderPadWhereUniqueInput>
    disconnect?: Enumerable<OrderPadWhereUniqueInput>
    delete?: Enumerable<OrderPadWhereUniqueInput>
    update?: Enumerable<OrderPadUpdateWithWhereUniqueWithoutWorkDayInput>
    updateMany?: Enumerable<OrderPadUpdateManyWithWhereWithoutWorkDayInput>
    deleteMany?: Enumerable<OrderPadScalarWhereInput>
  }

  export type TableDataUncheckedUpdateManyWithoutWorkDayInput = {
    create?: XOR<Enumerable<TableDataCreateWithoutWorkDayInput>, Enumerable<TableDataUncheckedCreateWithoutWorkDayInput>>
    connectOrCreate?: Enumerable<TableDataCreateOrConnectWithoutWorkDayInput>
    upsert?: Enumerable<TableDataUpsertWithWhereUniqueWithoutWorkDayInput>
    createMany?: TableDataCreateManyWorkDayInputEnvelope
    connect?: Enumerable<TableDataWhereUniqueInput>
    set?: Enumerable<TableDataWhereUniqueInput>
    disconnect?: Enumerable<TableDataWhereUniqueInput>
    delete?: Enumerable<TableDataWhereUniqueInput>
    update?: Enumerable<TableDataUpdateWithWhereUniqueWithoutWorkDayInput>
    updateMany?: Enumerable<TableDataUpdateManyWithWhereWithoutWorkDayInput>
    deleteMany?: Enumerable<TableDataScalarWhereInput>
  }

  export type EmployeeCreateNestedOneWithoutWorkHoursInput = {
    create?: XOR<EmployeeCreateWithoutWorkHoursInput, EmployeeUncheckedCreateWithoutWorkHoursInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkHoursInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumWeekDayFieldUpdateOperationsInput = {
    set?: WeekDay
  }

  export type EmployeeUpdateOneWithoutWorkHoursInput = {
    create?: XOR<EmployeeCreateWithoutWorkHoursInput, EmployeeUncheckedCreateWithoutWorkHoursInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkHoursInput
    upsert?: EmployeeUpsertWithoutWorkHoursInput
    connect?: EmployeeWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<EmployeeUpdateWithoutWorkHoursInput, EmployeeUncheckedUpdateWithoutWorkHoursInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumBillStatusFilter = {
    equals?: BillStatus
    in?: Enumerable<BillStatus>
    notIn?: Enumerable<BillStatus>
    not?: NestedEnumBillStatusFilter | BillStatus
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringFilter
    _max?: NestedStringFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumBillStatusWithAggregatesFilter = {
    equals?: BillStatus
    in?: Enumerable<BillStatus>
    notIn?: Enumerable<BillStatus>
    not?: NestedEnumBillStatusWithAggregatesFilter | BillStatus
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumBillStatusFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumBillStatusFilter
    _max?: NestedEnumBillStatusFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumBillStatusFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatNullableFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedStringNullableFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntNullableFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedIntFilter
    _min?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedIntFilter
    _max?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedBoolFilter
    _max?: NestedBoolFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedBoolFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _avg?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedFloatFilter
    _max?: NestedFloatFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedFloatFilter
  }

  export type NestedEnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumUserRoleFilter
  }

  export type NestedEnumWeekDayFilter = {
    equals?: WeekDay
    in?: Enumerable<WeekDay>
    notIn?: Enumerable<WeekDay>
    not?: NestedEnumWeekDayFilter | WeekDay
  }

  export type NestedEnumWeekDayWithAggregatesFilter = {
    equals?: WeekDay
    in?: Enumerable<WeekDay>
    notIn?: Enumerable<WeekDay>
    not?: NestedEnumWeekDayWithAggregatesFilter | WeekDay
    _count?: NestedIntFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    count?: NestedIntFilter
    _min?: NestedEnumWeekDayFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    min?: NestedEnumWeekDayFilter
    _max?: NestedEnumWeekDayFilter
    /**
     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.
     * 
    **/
    max?: NestedEnumWeekDayFilter
  }

  export type TableDataCreateWithoutBillsInput = {
    id?: string
    totalOccupations: number
    table?: TableCreateNestedOneWithoutDataInput
    waiter?: EmployeeCreateNestedOneWithoutTablesInput
    workDay?: WorkDayCreateNestedOneWithoutTablesInput
  }

  export type TableDataUncheckedCreateWithoutBillsInput = {
    id?: string
    totalOccupations: number
    workDayId?: string | null
    tableId?: string | null
    waiterId?: string | null
  }

  export type TableDataCreateOrConnectWithoutBillsInput = {
    where: TableDataWhereUniqueInput
    create: XOR<TableDataCreateWithoutBillsInput, TableDataUncheckedCreateWithoutBillsInput>
  }

  export type WorkDayCreateWithoutBillsInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishment?: EstablishmentCreateNestedOneWithoutWorkingDaysInput
    userResponsible?: UserCreateNestedOneWithoutResponsibleWorkDaysInput
    incomes?: IncomeCreateNestedManyWithoutWorkDayInput
    orders?: OrderCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadCreateNestedManyWithoutWorkDayInput
    tables?: TableDataCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedCreateWithoutBillsInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishmentId?: string | null
    userResponsibleId?: string | null
    incomes?: IncomeUncheckedCreateNestedManyWithoutWorkDayInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedCreateNestedManyWithoutWorkDayInput
    tables?: TableDataUncheckedCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayCreateOrConnectWithoutBillsInput = {
    where: WorkDayWhereUniqueInput
    create: XOR<WorkDayCreateWithoutBillsInput, WorkDayUncheckedCreateWithoutBillsInput>
  }

  export type OrderCreateWithoutBillInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    workDay?: WorkDayCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    modifiedOrdersId?: OrderCreateNestedManyWithoutModifiedOrdersInput
    modifiedOrders?: OrderCreateNestedManyWithoutModifiedOrdersIdInput
  }

  export type OrderUncheckedCreateWithoutBillInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    workDayId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutBillInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutBillInput, OrderUncheckedCreateWithoutBillInput>
  }

  export type OrderCreateManyBillInputEnvelope = {
    data: Enumerable<OrderCreateManyBillInput>
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutBillInput = {
    id?: string
    createdAt?: Date | string
    value: number
    paymentType: string
    paymentTypeOption?: string | null
    isActive: boolean
    checkData?: CheckDataCreateNestedOneWithoutPaymentInput
    expense?: ExpenseCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutBillInput = {
    id?: string
    createdAt?: Date | string
    value: number
    paymentType: string
    paymentTypeOption?: string | null
    isActive: boolean
    expenseId?: string | null
    checkDataId?: string | null
  }

  export type PaymentCreateOrConnectWithoutBillInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBillInput, PaymentUncheckedCreateWithoutBillInput>
  }

  export type PaymentCreateManyBillInputEnvelope = {
    data: Enumerable<PaymentCreateManyBillInput>
    skipDuplicates?: boolean
  }

  export type BillCreateWithoutReopenBillsInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    tableData?: TableDataCreateNestedOneWithoutBillsInput
    workDay?: WorkDayCreateNestedOneWithoutBillsInput
    orders?: OrderCreateNestedManyWithoutBillInput
    payments?: PaymentCreateNestedManyWithoutBillInput
    reopenBillsId?: BillCreateNestedManyWithoutReopenBillsInput
  }

  export type BillUncheckedCreateWithoutReopenBillsInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    workDayId?: string | null
    tableDataId?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutBillInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutReopenBillsInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutReopenBillsInput, BillUncheckedCreateWithoutReopenBillsInput>
  }

  export type BillCreateWithoutReopenBillsIdInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    tableData?: TableDataCreateNestedOneWithoutBillsInput
    workDay?: WorkDayCreateNestedOneWithoutBillsInput
    orders?: OrderCreateNestedManyWithoutBillInput
    payments?: PaymentCreateNestedManyWithoutBillInput
    reopenBills?: BillCreateNestedManyWithoutReopenBillsIdInput
  }

  export type BillUncheckedCreateWithoutReopenBillsIdInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    workDayId?: string | null
    tableDataId?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutBillInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutReopenBillsIdInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutReopenBillsIdInput, BillUncheckedCreateWithoutReopenBillsIdInput>
  }

  export type TableDataUpsertWithoutBillsInput = {
    update: XOR<TableDataUpdateWithoutBillsInput, TableDataUncheckedUpdateWithoutBillsInput>
    create: XOR<TableDataCreateWithoutBillsInput, TableDataUncheckedCreateWithoutBillsInput>
  }

  export type TableDataUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    table?: TableUpdateOneWithoutDataInput
    waiter?: EmployeeUpdateOneWithoutTablesInput
    workDay?: WorkDayUpdateOneWithoutTablesInput
  }

  export type TableDataUncheckedUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    waiterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkDayUpsertWithoutBillsInput = {
    update: XOR<WorkDayUpdateWithoutBillsInput, WorkDayUncheckedUpdateWithoutBillsInput>
    create: XOR<WorkDayCreateWithoutBillsInput, WorkDayUncheckedCreateWithoutBillsInput>
  }

  export type WorkDayUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishment?: EstablishmentUpdateOneWithoutWorkingDaysInput
    userResponsible?: UserUpdateOneWithoutResponsibleWorkDaysInput
    incomes?: IncomeUpdateManyWithoutWorkDayInput
    orders?: OrderUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUpdateManyWithoutWorkDayInput
    tables?: TableDataUpdateManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedUpdateWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    userResponsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    incomes?: IncomeUncheckedUpdateManyWithoutWorkDayInput
    orders?: OrderUncheckedUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedUpdateManyWithoutWorkDayInput
    tables?: TableDataUncheckedUpdateManyWithoutWorkDayInput
  }

  export type OrderUpsertWithWhereUniqueWithoutBillInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutBillInput, OrderUncheckedUpdateWithoutBillInput>
    create: XOR<OrderCreateWithoutBillInput, OrderUncheckedCreateWithoutBillInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutBillInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutBillInput, OrderUncheckedUpdateWithoutBillInput>
  }

  export type OrderUpdateManyWithWhereWithoutBillInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type OrderScalarWhereInput = {
    AND?: Enumerable<OrderScalarWhereInput>
    OR?: Enumerable<OrderScalarWhereInput>
    NOT?: Enumerable<OrderScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    block?: IntFilter | number
    orderId?: IntFilter | number
    cancelled?: BoolNullableFilter | boolean | null
    cancelationJustification?: StringNullableFilter | string | null
    wasModified?: BoolNullableFilter | boolean | null
    isEmployeeOrder?: BoolNullableFilter | boolean | null
    reuse?: BoolNullableFilter | boolean | null
    isToGo?: BoolNullableFilter | boolean | null
    toGoReference?: StringNullableFilter | string | null
    workDayId?: StringNullableFilter | string | null
    billId?: StringNullableFilter | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutBillInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBillInput, PaymentUncheckedUpdateWithoutBillInput>
    create: XOR<PaymentCreateWithoutBillInput, PaymentUncheckedCreateWithoutBillInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBillInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBillInput, PaymentUncheckedUpdateWithoutBillInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBillInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentsInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: Enumerable<PaymentScalarWhereInput>
    OR?: Enumerable<PaymentScalarWhereInput>
    NOT?: Enumerable<PaymentScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    value?: FloatFilter | number
    paymentType?: StringFilter | string
    paymentTypeOption?: StringNullableFilter | string | null
    isActive?: BoolFilter | boolean
    expenseId?: StringNullableFilter | string | null
    checkDataId?: StringNullableFilter | string | null
    billId?: StringNullableFilter | string | null
  }

  export type BillUpsertWithWhereUniqueWithoutReopenBillsInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutReopenBillsInput, BillUncheckedUpdateWithoutReopenBillsInput>
    create: XOR<BillCreateWithoutReopenBillsInput, BillUncheckedCreateWithoutReopenBillsInput>
  }

  export type BillUpdateWithWhereUniqueWithoutReopenBillsInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutReopenBillsInput, BillUncheckedUpdateWithoutReopenBillsInput>
  }

  export type BillUpdateManyWithWhereWithoutReopenBillsInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutReopenBillsIdInput>
  }

  export type BillScalarWhereInput = {
    AND?: Enumerable<BillScalarWhereInput>
    OR?: Enumerable<BillScalarWhereInput>
    NOT?: Enumerable<BillScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    closedAt?: DateTimeNullableFilter | Date | string | null
    status?: EnumBillStatusFilter | BillStatus
    discount?: FloatNullableFilter | number | null
    discountReason?: StringNullableFilter | string | null
    value?: FloatNullableFilter | number | null
    valueAfterDiscount?: FloatNullableFilter | number | null
    wasReopen?: BoolNullableFilter | boolean | null
    registered?: BoolNullableFilter | boolean | null
    workDayId?: StringNullableFilter | string | null
    tableDataId?: StringNullableFilter | string | null
  }

  export type BillUpsertWithWhereUniqueWithoutReopenBillsIdInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutReopenBillsIdInput, BillUncheckedUpdateWithoutReopenBillsIdInput>
    create: XOR<BillCreateWithoutReopenBillsIdInput, BillUncheckedCreateWithoutReopenBillsIdInput>
  }

  export type BillUpdateWithWhereUniqueWithoutReopenBillsIdInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutReopenBillsIdInput, BillUncheckedUpdateWithoutReopenBillsIdInput>
  }

  export type BillUpdateManyWithWhereWithoutReopenBillsIdInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutReopenBillsInput>
  }

  export type PaymentCreateWithoutCheckDataInput = {
    id?: string
    createdAt?: Date | string
    value: number
    paymentType: string
    paymentTypeOption?: string | null
    isActive: boolean
    bill?: BillCreateNestedOneWithoutPaymentsInput
    expense?: ExpenseCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutCheckDataInput = {
    id?: string
    createdAt?: Date | string
    value: number
    paymentType: string
    paymentTypeOption?: string | null
    isActive: boolean
    expenseId?: string | null
    billId?: string | null
  }

  export type PaymentCreateOrConnectWithoutCheckDataInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCheckDataInput, PaymentUncheckedCreateWithoutCheckDataInput>
  }

  export type PaymentUpsertWithoutCheckDataInput = {
    update: XOR<PaymentUpdateWithoutCheckDataInput, PaymentUncheckedUpdateWithoutCheckDataInput>
    create: XOR<PaymentCreateWithoutCheckDataInput, PaymentUncheckedCreateWithoutCheckDataInput>
  }

  export type PaymentUpdateWithoutCheckDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentTypeOption?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bill?: BillUpdateOneWithoutPaymentsInput
    expense?: ExpenseUpdateOneWithoutPaymentInput
  }

  export type PaymentUncheckedUpdateWithoutCheckDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentTypeOption?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EstablishmentCreateWithoutClientsInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    employees?: EmployeeCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseCreateNestedManyWithoutEstablishmentInput
    items?: ItemCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionCreateNestedManyWithoutEstablishmentInput
    tables?: TableCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedCreateWithoutClientsInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    employees?: EmployeeUncheckedCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEstablishmentInput
    items?: ItemUncheckedCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutEstablishmentInput
    tables?: TableUncheckedCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentCreateOrConnectWithoutClientsInput = {
    where: EstablishmentWhereUniqueInput
    create: XOR<EstablishmentCreateWithoutClientsInput, EstablishmentUncheckedCreateWithoutClientsInput>
  }

  export type EstablishmentUpsertWithoutClientsInput = {
    update: XOR<EstablishmentUpdateWithoutClientsInput, EstablishmentUncheckedUpdateWithoutClientsInput>
    create: XOR<EstablishmentCreateWithoutClientsInput, EstablishmentUncheckedCreateWithoutClientsInput>
  }

  export type EstablishmentUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    employees?: EmployeeUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUpdateManyWithoutEstablishmentInput
    items?: ItemUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUpdateManyWithoutEstablishmentInput
    tables?: TableUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUpdateManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    employees?: EmployeeUncheckedUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEstablishmentInput
    items?: ItemUncheckedUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedUpdateManyWithoutEstablishmentInput
    tables?: TableUncheckedUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedUpdateManyWithoutEstablishmentInput
  }

  export type EstablishmentCreateWithoutEmployeesInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseCreateNestedManyWithoutEstablishmentInput
    items?: ItemCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionCreateNestedManyWithoutEstablishmentInput
    tables?: TableCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedCreateWithoutEmployeesInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEstablishmentInput
    items?: ItemUncheckedCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutEstablishmentInput
    tables?: TableUncheckedCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentCreateOrConnectWithoutEmployeesInput = {
    where: EstablishmentWhereUniqueInput
    create: XOR<EstablishmentCreateWithoutEmployeesInput, EstablishmentUncheckedCreateWithoutEmployeesInput>
  }

  export type OrderItemCreateWithoutEmployeeInput = {
    id?: string
    quantity: number
    item?: ItemCreateNestedOneWithoutOrderItemInput
    order?: OrderCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutEmployeeInput = {
    id?: string
    quantity: number
    orderId?: string | null
    itemId?: string | null
  }

  export type OrderItemCreateOrConnectWithoutEmployeeInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutEmployeeInput, OrderItemUncheckedCreateWithoutEmployeeInput>
  }

  export type OrderItemCreateManyEmployeeInputEnvelope = {
    data: Enumerable<OrderItemCreateManyEmployeeInput>
    skipDuplicates?: boolean
  }

  export type OrderPadCreateWithoutEmployeeInput = {
    id?: string
    block: number
    firstOrderId: number
    lastOrderId?: number | null
    used: boolean
    workDay?: WorkDayCreateNestedOneWithoutOrderPadsInput
  }

  export type OrderPadUncheckedCreateWithoutEmployeeInput = {
    id?: string
    block: number
    firstOrderId: number
    lastOrderId?: number | null
    used: boolean
    workDayId?: string | null
  }

  export type OrderPadCreateOrConnectWithoutEmployeeInput = {
    where: OrderPadWhereUniqueInput
    create: XOR<OrderPadCreateWithoutEmployeeInput, OrderPadUncheckedCreateWithoutEmployeeInput>
  }

  export type OrderPadCreateManyEmployeeInputEnvelope = {
    data: Enumerable<OrderPadCreateManyEmployeeInput>
    skipDuplicates?: boolean
  }

  export type TableDataCreateWithoutWaiterInput = {
    id?: string
    totalOccupations: number
    table?: TableCreateNestedOneWithoutDataInput
    workDay?: WorkDayCreateNestedOneWithoutTablesInput
    bills?: BillCreateNestedManyWithoutTableDataInput
  }

  export type TableDataUncheckedCreateWithoutWaiterInput = {
    id?: string
    totalOccupations: number
    workDayId?: string | null
    tableId?: string | null
    bills?: BillUncheckedCreateNestedManyWithoutTableDataInput
  }

  export type TableDataCreateOrConnectWithoutWaiterInput = {
    where: TableDataWhereUniqueInput
    create: XOR<TableDataCreateWithoutWaiterInput, TableDataUncheckedCreateWithoutWaiterInput>
  }

  export type TableDataCreateManyWaiterInputEnvelope = {
    data: Enumerable<TableDataCreateManyWaiterInput>
    skipDuplicates?: boolean
  }

  export type WorkHourCreateWithoutEmployeeInput = {
    id?: string
    weekday: WeekDay
    startTime?: string | null
    endTime?: string | null
    isDayOff?: boolean | null
  }

  export type WorkHourUncheckedCreateWithoutEmployeeInput = {
    id?: string
    weekday: WeekDay
    startTime?: string | null
    endTime?: string | null
    isDayOff?: boolean | null
  }

  export type WorkHourCreateOrConnectWithoutEmployeeInput = {
    where: WorkHourWhereUniqueInput
    create: XOR<WorkHourCreateWithoutEmployeeInput, WorkHourUncheckedCreateWithoutEmployeeInput>
  }

  export type WorkHourCreateManyEmployeeInputEnvelope = {
    data: Enumerable<WorkHourCreateManyEmployeeInput>
    skipDuplicates?: boolean
  }

  export type EstablishmentUpsertWithoutEmployeesInput = {
    update: XOR<EstablishmentUpdateWithoutEmployeesInput, EstablishmentUncheckedUpdateWithoutEmployeesInput>
    create: XOR<EstablishmentCreateWithoutEmployeesInput, EstablishmentUncheckedCreateWithoutEmployeesInput>
  }

  export type EstablishmentUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUpdateManyWithoutEstablishmentInput
    items?: ItemUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUpdateManyWithoutEstablishmentInput
    tables?: TableUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUpdateManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEstablishmentInput
    items?: ItemUncheckedUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedUpdateManyWithoutEstablishmentInput
    tables?: TableUncheckedUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedUpdateManyWithoutEstablishmentInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutEmployeeInput, OrderItemUncheckedUpdateWithoutEmployeeInput>
    create: XOR<OrderItemCreateWithoutEmployeeInput, OrderItemUncheckedCreateWithoutEmployeeInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutEmployeeInput, OrderItemUncheckedUpdateWithoutEmployeeInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutEmployeeInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutItemsOrderedInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: Enumerable<OrderItemScalarWhereInput>
    OR?: Enumerable<OrderItemScalarWhereInput>
    NOT?: Enumerable<OrderItemScalarWhereInput>
    id?: StringFilter | string
    quantity?: IntFilter | number
    orderId?: StringNullableFilter | string | null
    employeeId?: StringNullableFilter | string | null
    itemId?: StringNullableFilter | string | null
  }

  export type OrderPadUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: OrderPadWhereUniqueInput
    update: XOR<OrderPadUpdateWithoutEmployeeInput, OrderPadUncheckedUpdateWithoutEmployeeInput>
    create: XOR<OrderPadCreateWithoutEmployeeInput, OrderPadUncheckedCreateWithoutEmployeeInput>
  }

  export type OrderPadUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: OrderPadWhereUniqueInput
    data: XOR<OrderPadUpdateWithoutEmployeeInput, OrderPadUncheckedUpdateWithoutEmployeeInput>
  }

  export type OrderPadUpdateManyWithWhereWithoutEmployeeInput = {
    where: OrderPadScalarWhereInput
    data: XOR<OrderPadUpdateManyMutationInput, OrderPadUncheckedUpdateManyWithoutOrderPadsInput>
  }

  export type OrderPadScalarWhereInput = {
    AND?: Enumerable<OrderPadScalarWhereInput>
    OR?: Enumerable<OrderPadScalarWhereInput>
    NOT?: Enumerable<OrderPadScalarWhereInput>
    id?: StringFilter | string
    block?: IntFilter | number
    firstOrderId?: IntFilter | number
    lastOrderId?: IntNullableFilter | number | null
    used?: BoolFilter | boolean
    workDayId?: StringNullableFilter | string | null
    employeeId?: StringNullableFilter | string | null
  }

  export type TableDataUpsertWithWhereUniqueWithoutWaiterInput = {
    where: TableDataWhereUniqueInput
    update: XOR<TableDataUpdateWithoutWaiterInput, TableDataUncheckedUpdateWithoutWaiterInput>
    create: XOR<TableDataCreateWithoutWaiterInput, TableDataUncheckedCreateWithoutWaiterInput>
  }

  export type TableDataUpdateWithWhereUniqueWithoutWaiterInput = {
    where: TableDataWhereUniqueInput
    data: XOR<TableDataUpdateWithoutWaiterInput, TableDataUncheckedUpdateWithoutWaiterInput>
  }

  export type TableDataUpdateManyWithWhereWithoutWaiterInput = {
    where: TableDataScalarWhereInput
    data: XOR<TableDataUpdateManyMutationInput, TableDataUncheckedUpdateManyWithoutTablesInput>
  }

  export type TableDataScalarWhereInput = {
    AND?: Enumerable<TableDataScalarWhereInput>
    OR?: Enumerable<TableDataScalarWhereInput>
    NOT?: Enumerable<TableDataScalarWhereInput>
    id?: StringFilter | string
    totalOccupations?: IntFilter | number
    workDayId?: StringNullableFilter | string | null
    tableId?: StringNullableFilter | string | null
    waiterId?: StringNullableFilter | string | null
  }

  export type WorkHourUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: WorkHourWhereUniqueInput
    update: XOR<WorkHourUpdateWithoutEmployeeInput, WorkHourUncheckedUpdateWithoutEmployeeInput>
    create: XOR<WorkHourCreateWithoutEmployeeInput, WorkHourUncheckedCreateWithoutEmployeeInput>
  }

  export type WorkHourUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: WorkHourWhereUniqueInput
    data: XOR<WorkHourUpdateWithoutEmployeeInput, WorkHourUncheckedUpdateWithoutEmployeeInput>
  }

  export type WorkHourUpdateManyWithWhereWithoutEmployeeInput = {
    where: WorkHourScalarWhereInput
    data: XOR<WorkHourUpdateManyMutationInput, WorkHourUncheckedUpdateManyWithoutWorkHoursInput>
  }

  export type WorkHourScalarWhereInput = {
    AND?: Enumerable<WorkHourScalarWhereInput>
    OR?: Enumerable<WorkHourScalarWhereInput>
    NOT?: Enumerable<WorkHourScalarWhereInput>
    id?: StringFilter | string
    weekday?: EnumWeekDayFilter | WeekDay
    startTime?: StringNullableFilter | string | null
    endTime?: StringNullableFilter | string | null
    isDayOff?: BoolNullableFilter | boolean | null
    employeeId?: StringNullableFilter | string | null
  }

  export type ClientCreateWithoutEstablishmentInput = {
    id?: string
    name: string
    address: string
    complement?: string | null
    postCode: string
    telephoneNumber: string
    distanceKm: string
    distanceTime: string
  }

  export type ClientUncheckedCreateWithoutEstablishmentInput = {
    id?: string
    name: string
    address: string
    complement?: string | null
    postCode: string
    telephoneNumber: string
    distanceKm: string
    distanceTime: string
  }

  export type ClientCreateOrConnectWithoutEstablishmentInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutEstablishmentInput, ClientUncheckedCreateWithoutEstablishmentInput>
  }

  export type ClientCreateManyEstablishmentInputEnvelope = {
    data: Enumerable<ClientCreateManyEstablishmentInput>
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutEstablishmentInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    itemsOrdered?: OrderItemCreateNestedManyWithoutEmployeeInput
    orderPads?: OrderPadCreateNestedManyWithoutEmployeeInput
    tables?: TableDataCreateNestedManyWithoutWaiterInput
    workHours?: WorkHourCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEstablishmentInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    itemsOrdered?: OrderItemUncheckedCreateNestedManyWithoutEmployeeInput
    orderPads?: OrderPadUncheckedCreateNestedManyWithoutEmployeeInput
    tables?: TableDataUncheckedCreateNestedManyWithoutWaiterInput
    workHours?: WorkHourUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEstablishmentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEstablishmentInput, EmployeeUncheckedCreateWithoutEstablishmentInput>
  }

  export type EmployeeCreateManyEstablishmentInputEnvelope = {
    data: Enumerable<EmployeeCreateManyEstablishmentInput>
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutEstablishmentInput = {
    id?: string
    createdAt?: Date | string
    NFE: boolean
    NFEReference?: string | null
    date: Date | string
    executionDate: Date | string
    payment?: PaymentCreateNestedOneWithoutExpenseInput
    expenseItems?: ExpenseItemCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutEstablishmentInput = {
    id?: string
    createdAt?: Date | string
    NFE: boolean
    NFEReference?: string | null
    date: Date | string
    executionDate: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseCreateOrConnectWithoutEstablishmentInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutEstablishmentInput, ExpenseUncheckedCreateWithoutEstablishmentInput>
  }

  export type ExpenseCreateManyEstablishmentInputEnvelope = {
    data: Enumerable<ExpenseCreateManyEstablishmentInput>
    skipDuplicates?: boolean
  }

  export type ItemCreateWithoutEstablishmentInput = {
    id?: string
    itemId: string
    name: string
    price: number
    priceToGo?: number | null
    employeePrice?: number | null
    category: string
    canTakeToGo?: boolean | null
    isActive: boolean
    hasTaxSubstitution?: boolean | null
    itemNCM?: NCMCreateNestedOneWithoutItemsInput
    orderItem?: OrderItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutEstablishmentInput = {
    id?: string
    itemId: string
    name: string
    price: number
    priceToGo?: number | null
    employeePrice?: number | null
    category: string
    canTakeToGo?: boolean | null
    isActive: boolean
    hasTaxSubstitution?: boolean | null
    itemNCMId?: string | null
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutEstablishmentInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutEstablishmentInput, ItemUncheckedCreateWithoutEstablishmentInput>
  }

  export type ItemCreateManyEstablishmentInputEnvelope = {
    data: Enumerable<ItemCreateManyEstablishmentInput>
    skipDuplicates?: boolean
  }

  export type PermissionCreateWithoutEstablishmentInput = {
    id?: string
    createdAt?: Date | string
    role: UserRole
    user?: UserCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateWithoutEstablishmentInput = {
    id?: string
    createdAt?: Date | string
    role: UserRole
    userId?: string | null
  }

  export type PermissionCreateOrConnectWithoutEstablishmentInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutEstablishmentInput, PermissionUncheckedCreateWithoutEstablishmentInput>
  }

  export type PermissionCreateManyEstablishmentInputEnvelope = {
    data: Enumerable<PermissionCreateManyEstablishmentInput>
    skipDuplicates?: boolean
  }

  export type TableCreateWithoutEstablishmentInput = {
    id?: string
    tableNumber: number
    data?: TableDataCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutEstablishmentInput = {
    id?: string
    tableNumber: number
    data?: TableDataUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutEstablishmentInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutEstablishmentInput, TableUncheckedCreateWithoutEstablishmentInput>
  }

  export type TableCreateManyEstablishmentInputEnvelope = {
    data: Enumerable<TableCreateManyEstablishmentInput>
    skipDuplicates?: boolean
  }

  export type WorkDayCreateWithoutEstablishmentInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    userResponsible?: UserCreateNestedOneWithoutResponsibleWorkDaysInput
    bills?: BillCreateNestedManyWithoutWorkDayInput
    incomes?: IncomeCreateNestedManyWithoutWorkDayInput
    orders?: OrderCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadCreateNestedManyWithoutWorkDayInput
    tables?: TableDataCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedCreateWithoutEstablishmentInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    userResponsibleId?: string | null
    bills?: BillUncheckedCreateNestedManyWithoutWorkDayInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutWorkDayInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedCreateNestedManyWithoutWorkDayInput
    tables?: TableDataUncheckedCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayCreateOrConnectWithoutEstablishmentInput = {
    where: WorkDayWhereUniqueInput
    create: XOR<WorkDayCreateWithoutEstablishmentInput, WorkDayUncheckedCreateWithoutEstablishmentInput>
  }

  export type WorkDayCreateManyEstablishmentInputEnvelope = {
    data: Enumerable<WorkDayCreateManyEstablishmentInput>
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithWhereUniqueWithoutEstablishmentInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutEstablishmentInput, ClientUncheckedUpdateWithoutEstablishmentInput>
    create: XOR<ClientCreateWithoutEstablishmentInput, ClientUncheckedCreateWithoutEstablishmentInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutEstablishmentInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutEstablishmentInput, ClientUncheckedUpdateWithoutEstablishmentInput>
  }

  export type ClientUpdateManyWithWhereWithoutEstablishmentInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutClientsInput>
  }

  export type ClientScalarWhereInput = {
    AND?: Enumerable<ClientScalarWhereInput>
    OR?: Enumerable<ClientScalarWhereInput>
    NOT?: Enumerable<ClientScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    address?: StringFilter | string
    complement?: StringNullableFilter | string | null
    postCode?: StringFilter | string
    telephoneNumber?: StringFilter | string
    distanceKm?: StringFilter | string
    distanceTime?: StringFilter | string
    establishmentId?: StringNullableFilter | string | null
  }

  export type EmployeeUpsertWithWhereUniqueWithoutEstablishmentInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutEstablishmentInput, EmployeeUncheckedUpdateWithoutEstablishmentInput>
    create: XOR<EmployeeCreateWithoutEstablishmentInput, EmployeeUncheckedCreateWithoutEstablishmentInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutEstablishmentInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutEstablishmentInput, EmployeeUncheckedUpdateWithoutEstablishmentInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutEstablishmentInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutEmployeesInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: Enumerable<EmployeeScalarWhereInput>
    OR?: Enumerable<EmployeeScalarWhereInput>
    NOT?: Enumerable<EmployeeScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    employeeId?: IntFilter | number
    name?: StringFilter | string
    role?: StringFilter | string
    admissionDate?: DateTimeNullableFilter | Date | string | null
    terminationDate?: DateTimeNullableFilter | Date | string | null
    isActive?: BoolFilter | boolean
    establishmentId?: StringNullableFilter | string | null
  }

  export type ExpenseUpsertWithWhereUniqueWithoutEstablishmentInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutEstablishmentInput, ExpenseUncheckedUpdateWithoutEstablishmentInput>
    create: XOR<ExpenseCreateWithoutEstablishmentInput, ExpenseUncheckedCreateWithoutEstablishmentInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutEstablishmentInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutEstablishmentInput, ExpenseUncheckedUpdateWithoutEstablishmentInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutEstablishmentInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutExpensesInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: Enumerable<ExpenseScalarWhereInput>
    OR?: Enumerable<ExpenseScalarWhereInput>
    NOT?: Enumerable<ExpenseScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    NFE?: BoolFilter | boolean
    NFEReference?: StringNullableFilter | string | null
    date?: DateTimeFilter | Date | string
    executionDate?: DateTimeFilter | Date | string
    establishmentId?: StringNullableFilter | string | null
  }

  export type ItemUpsertWithWhereUniqueWithoutEstablishmentInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutEstablishmentInput, ItemUncheckedUpdateWithoutEstablishmentInput>
    create: XOR<ItemCreateWithoutEstablishmentInput, ItemUncheckedCreateWithoutEstablishmentInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutEstablishmentInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutEstablishmentInput, ItemUncheckedUpdateWithoutEstablishmentInput>
  }

  export type ItemUpdateManyWithWhereWithoutEstablishmentInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type ItemScalarWhereInput = {
    AND?: Enumerable<ItemScalarWhereInput>
    OR?: Enumerable<ItemScalarWhereInput>
    NOT?: Enumerable<ItemScalarWhereInput>
    id?: StringFilter | string
    itemId?: StringFilter | string
    name?: StringFilter | string
    price?: FloatFilter | number
    priceToGo?: FloatNullableFilter | number | null
    employeePrice?: FloatNullableFilter | number | null
    category?: StringFilter | string
    canTakeToGo?: BoolNullableFilter | boolean | null
    isActive?: BoolFilter | boolean
    hasTaxSubstitution?: BoolNullableFilter | boolean | null
    establishmentId?: StringNullableFilter | string | null
    itemNCMId?: StringNullableFilter | string | null
  }

  export type PermissionUpsertWithWhereUniqueWithoutEstablishmentInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutEstablishmentInput, PermissionUncheckedUpdateWithoutEstablishmentInput>
    create: XOR<PermissionCreateWithoutEstablishmentInput, PermissionUncheckedCreateWithoutEstablishmentInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutEstablishmentInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutEstablishmentInput, PermissionUncheckedUpdateWithoutEstablishmentInput>
  }

  export type PermissionUpdateManyWithWhereWithoutEstablishmentInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: Enumerable<PermissionScalarWhereInput>
    OR?: Enumerable<PermissionScalarWhereInput>
    NOT?: Enumerable<PermissionScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    role?: EnumUserRoleFilter | UserRole
    userId?: StringNullableFilter | string | null
    establishmentId?: StringNullableFilter | string | null
  }

  export type TableUpsertWithWhereUniqueWithoutEstablishmentInput = {
    where: TableWhereUniqueInput
    update: XOR<TableUpdateWithoutEstablishmentInput, TableUncheckedUpdateWithoutEstablishmentInput>
    create: XOR<TableCreateWithoutEstablishmentInput, TableUncheckedCreateWithoutEstablishmentInput>
  }

  export type TableUpdateWithWhereUniqueWithoutEstablishmentInput = {
    where: TableWhereUniqueInput
    data: XOR<TableUpdateWithoutEstablishmentInput, TableUncheckedUpdateWithoutEstablishmentInput>
  }

  export type TableUpdateManyWithWhereWithoutEstablishmentInput = {
    where: TableScalarWhereInput
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyWithoutTablesInput>
  }

  export type TableScalarWhereInput = {
    AND?: Enumerable<TableScalarWhereInput>
    OR?: Enumerable<TableScalarWhereInput>
    NOT?: Enumerable<TableScalarWhereInput>
    id?: StringFilter | string
    tableNumber?: IntFilter | number
    establishmentId?: StringNullableFilter | string | null
  }

  export type WorkDayUpsertWithWhereUniqueWithoutEstablishmentInput = {
    where: WorkDayWhereUniqueInput
    update: XOR<WorkDayUpdateWithoutEstablishmentInput, WorkDayUncheckedUpdateWithoutEstablishmentInput>
    create: XOR<WorkDayCreateWithoutEstablishmentInput, WorkDayUncheckedCreateWithoutEstablishmentInput>
  }

  export type WorkDayUpdateWithWhereUniqueWithoutEstablishmentInput = {
    where: WorkDayWhereUniqueInput
    data: XOR<WorkDayUpdateWithoutEstablishmentInput, WorkDayUncheckedUpdateWithoutEstablishmentInput>
  }

  export type WorkDayUpdateManyWithWhereWithoutEstablishmentInput = {
    where: WorkDayScalarWhereInput
    data: XOR<WorkDayUpdateManyMutationInput, WorkDayUncheckedUpdateManyWithoutWorkingDaysInput>
  }

  export type WorkDayScalarWhereInput = {
    AND?: Enumerable<WorkDayScalarWhereInput>
    OR?: Enumerable<WorkDayScalarWhereInput>
    NOT?: Enumerable<WorkDayScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    isCurrent?: BoolFilter | boolean
    openDate?: DateTimeFilter | Date | string
    closeDate?: DateTimeNullableFilter | Date | string | null
    establishmentId?: StringNullableFilter | string | null
    userResponsibleId?: StringNullableFilter | string | null
  }

  export type EstablishmentCreateWithoutExpensesInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientCreateNestedManyWithoutEstablishmentInput
    employees?: EmployeeCreateNestedManyWithoutEstablishmentInput
    items?: ItemCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionCreateNestedManyWithoutEstablishmentInput
    tables?: TableCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedCreateWithoutExpensesInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedCreateNestedManyWithoutEstablishmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutEstablishmentInput
    items?: ItemUncheckedCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutEstablishmentInput
    tables?: TableUncheckedCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentCreateOrConnectWithoutExpensesInput = {
    where: EstablishmentWhereUniqueInput
    create: XOR<EstablishmentCreateWithoutExpensesInput, EstablishmentUncheckedCreateWithoutExpensesInput>
  }

  export type PaymentCreateWithoutExpenseInput = {
    id?: string
    createdAt?: Date | string
    value: number
    paymentType: string
    paymentTypeOption?: string | null
    isActive: boolean
    bill?: BillCreateNestedOneWithoutPaymentsInput
    checkData?: CheckDataCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutExpenseInput = {
    id?: string
    createdAt?: Date | string
    value: number
    paymentType: string
    paymentTypeOption?: string | null
    isActive: boolean
    checkDataId?: string | null
    billId?: string | null
  }

  export type PaymentCreateOrConnectWithoutExpenseInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutExpenseInput, PaymentUncheckedCreateWithoutExpenseInput>
  }

  export type ExpenseItemCreateWithoutExpenseInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    value: number
    details?: string | null
    product?: ProductCreateNestedOneWithoutExpenseItemInput
  }

  export type ExpenseItemUncheckedCreateWithoutExpenseInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    value: number
    details?: string | null
    productId?: string | null
  }

  export type ExpenseItemCreateOrConnectWithoutExpenseInput = {
    where: ExpenseItemWhereUniqueInput
    create: XOR<ExpenseItemCreateWithoutExpenseInput, ExpenseItemUncheckedCreateWithoutExpenseInput>
  }

  export type EstablishmentUpsertWithoutExpensesInput = {
    update: XOR<EstablishmentUpdateWithoutExpensesInput, EstablishmentUncheckedUpdateWithoutExpensesInput>
    create: XOR<EstablishmentCreateWithoutExpensesInput, EstablishmentUncheckedCreateWithoutExpensesInput>
  }

  export type EstablishmentUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUpdateManyWithoutEstablishmentInput
    employees?: EmployeeUpdateManyWithoutEstablishmentInput
    items?: ItemUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUpdateManyWithoutEstablishmentInput
    tables?: TableUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUpdateManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedUpdateManyWithoutEstablishmentInput
    employees?: EmployeeUncheckedUpdateManyWithoutEstablishmentInput
    items?: ItemUncheckedUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedUpdateManyWithoutEstablishmentInput
    tables?: TableUncheckedUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedUpdateManyWithoutEstablishmentInput
  }

  export type PaymentUpsertWithoutExpenseInput = {
    update: XOR<PaymentUpdateWithoutExpenseInput, PaymentUncheckedUpdateWithoutExpenseInput>
    create: XOR<PaymentCreateWithoutExpenseInput, PaymentUncheckedCreateWithoutExpenseInput>
  }

  export type PaymentUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentTypeOption?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    bill?: BillUpdateOneWithoutPaymentsInput
    checkData?: CheckDataUpdateOneWithoutPaymentInput
  }

  export type PaymentUncheckedUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentTypeOption?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    checkDataId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseItemUpsertWithWhereUniqueWithoutExpenseInput = {
    where: ExpenseItemWhereUniqueInput
    update: XOR<ExpenseItemUpdateWithoutExpenseInput, ExpenseItemUncheckedUpdateWithoutExpenseInput>
    create: XOR<ExpenseItemCreateWithoutExpenseInput, ExpenseItemUncheckedCreateWithoutExpenseInput>
  }

  export type ExpenseItemUpdateWithWhereUniqueWithoutExpenseInput = {
    where: ExpenseItemWhereUniqueInput
    data: XOR<ExpenseItemUpdateWithoutExpenseInput, ExpenseItemUncheckedUpdateWithoutExpenseInput>
  }

  export type ExpenseItemUpdateManyWithWhereWithoutExpenseInput = {
    where: ExpenseItemScalarWhereInput
    data: XOR<ExpenseItemUpdateManyMutationInput, ExpenseItemUncheckedUpdateManyWithoutExpenseItemsInput>
  }

  export type ExpenseItemScalarWhereInput = {
    AND?: Enumerable<ExpenseItemScalarWhereInput>
    OR?: Enumerable<ExpenseItemScalarWhereInput>
    NOT?: Enumerable<ExpenseItemScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    quantity?: FloatFilter | number
    value?: FloatFilter | number
    details?: StringNullableFilter | string | null
    productId?: StringNullableFilter | string | null
  }

  export type ProductCreateWithoutExpenseItemInput = {
    id?: string
    name: string
    category: string
    supplier: string
    brand?: string | null
    unit: string
  }

  export type ProductUncheckedCreateWithoutExpenseItemInput = {
    id?: string
    name: string
    category: string
    supplier: string
    brand?: string | null
    unit: string
  }

  export type ProductCreateOrConnectWithoutExpenseItemInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutExpenseItemInput, ProductUncheckedCreateWithoutExpenseItemInput>
  }

  export type ExpenseCreateWithoutExpenseItemsInput = {
    id?: string
    createdAt?: Date | string
    NFE: boolean
    NFEReference?: string | null
    date: Date | string
    executionDate: Date | string
    establishment?: EstablishmentCreateNestedOneWithoutExpensesInput
    payment?: PaymentCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutExpenseItemsInput = {
    id?: string
    createdAt?: Date | string
    NFE: boolean
    NFEReference?: string | null
    date: Date | string
    executionDate: Date | string
    establishmentId?: string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutExpenseInput
  }

  export type ExpenseCreateOrConnectWithoutExpenseItemsInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutExpenseItemsInput, ExpenseUncheckedCreateWithoutExpenseItemsInput>
  }

  export type ProductUpsertWithoutExpenseItemInput = {
    update: XOR<ProductUpdateWithoutExpenseItemInput, ProductUncheckedUpdateWithoutExpenseItemInput>
    create: XOR<ProductCreateWithoutExpenseItemInput, ProductUncheckedCreateWithoutExpenseItemInput>
  }

  export type ProductUpdateWithoutExpenseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUncheckedUpdateWithoutExpenseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    supplier?: StringFieldUpdateOperationsInput | string
    brand?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseUpsertWithWhereUniqueWithoutExpenseItemsInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutExpenseItemsInput, ExpenseUncheckedUpdateWithoutExpenseItemsInput>
    create: XOR<ExpenseCreateWithoutExpenseItemsInput, ExpenseUncheckedCreateWithoutExpenseItemsInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutExpenseItemsInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutExpenseItemsInput, ExpenseUncheckedUpdateWithoutExpenseItemsInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutExpenseItemsInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutExpenseInput>
  }

  export type WorkDayCreateWithoutIncomesInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishment?: EstablishmentCreateNestedOneWithoutWorkingDaysInput
    userResponsible?: UserCreateNestedOneWithoutResponsibleWorkDaysInput
    bills?: BillCreateNestedManyWithoutWorkDayInput
    orders?: OrderCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadCreateNestedManyWithoutWorkDayInput
    tables?: TableDataCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedCreateWithoutIncomesInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishmentId?: string | null
    userResponsibleId?: string | null
    bills?: BillUncheckedCreateNestedManyWithoutWorkDayInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedCreateNestedManyWithoutWorkDayInput
    tables?: TableDataUncheckedCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayCreateOrConnectWithoutIncomesInput = {
    where: WorkDayWhereUniqueInput
    create: XOR<WorkDayCreateWithoutIncomesInput, WorkDayUncheckedCreateWithoutIncomesInput>
  }

  export type WorkDayUpsertWithoutIncomesInput = {
    update: XOR<WorkDayUpdateWithoutIncomesInput, WorkDayUncheckedUpdateWithoutIncomesInput>
    create: XOR<WorkDayCreateWithoutIncomesInput, WorkDayUncheckedCreateWithoutIncomesInput>
  }

  export type WorkDayUpdateWithoutIncomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishment?: EstablishmentUpdateOneWithoutWorkingDaysInput
    userResponsible?: UserUpdateOneWithoutResponsibleWorkDaysInput
    bills?: BillUpdateManyWithoutWorkDayInput
    orders?: OrderUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUpdateManyWithoutWorkDayInput
    tables?: TableDataUpdateManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedUpdateWithoutIncomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    userResponsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    bills?: BillUncheckedUpdateManyWithoutWorkDayInput
    orders?: OrderUncheckedUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedUpdateManyWithoutWorkDayInput
    tables?: TableDataUncheckedUpdateManyWithoutWorkDayInput
  }

  export type EstablishmentCreateWithoutItemsInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientCreateNestedManyWithoutEstablishmentInput
    employees?: EmployeeCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionCreateNestedManyWithoutEstablishmentInput
    tables?: TableCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedCreateWithoutItemsInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedCreateNestedManyWithoutEstablishmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutEstablishmentInput
    tables?: TableUncheckedCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentCreateOrConnectWithoutItemsInput = {
    where: EstablishmentWhereUniqueInput
    create: XOR<EstablishmentCreateWithoutItemsInput, EstablishmentUncheckedCreateWithoutItemsInput>
  }

  export type NCMCreateWithoutItemsInput = {
    id?: string
    identifier: string
    description?: string | null
  }

  export type NCMUncheckedCreateWithoutItemsInput = {
    id?: string
    identifier: string
    description?: string | null
  }

  export type NCMCreateOrConnectWithoutItemsInput = {
    where: NCMWhereUniqueInput
    create: XOR<NCMCreateWithoutItemsInput, NCMUncheckedCreateWithoutItemsInput>
  }

  export type OrderItemCreateWithoutItemInput = {
    id?: string
    quantity: number
    employee?: EmployeeCreateNestedOneWithoutItemsOrderedInput
    order?: OrderCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutItemInput = {
    id?: string
    quantity: number
    orderId?: string | null
    employeeId?: string | null
  }

  export type OrderItemCreateOrConnectWithoutItemInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutItemInput, OrderItemUncheckedCreateWithoutItemInput>
  }

  export type OrderItemCreateManyItemInputEnvelope = {
    data: Enumerable<OrderItemCreateManyItemInput>
    skipDuplicates?: boolean
  }

  export type EstablishmentUpsertWithoutItemsInput = {
    update: XOR<EstablishmentUpdateWithoutItemsInput, EstablishmentUncheckedUpdateWithoutItemsInput>
    create: XOR<EstablishmentCreateWithoutItemsInput, EstablishmentUncheckedCreateWithoutItemsInput>
  }

  export type EstablishmentUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUpdateManyWithoutEstablishmentInput
    employees?: EmployeeUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUpdateManyWithoutEstablishmentInput
    tables?: TableUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUpdateManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedUpdateManyWithoutEstablishmentInput
    employees?: EmployeeUncheckedUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedUpdateManyWithoutEstablishmentInput
    tables?: TableUncheckedUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedUpdateManyWithoutEstablishmentInput
  }

  export type NCMUpsertWithoutItemsInput = {
    update: XOR<NCMUpdateWithoutItemsInput, NCMUncheckedUpdateWithoutItemsInput>
    create: XOR<NCMCreateWithoutItemsInput, NCMUncheckedCreateWithoutItemsInput>
  }

  export type NCMUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NCMUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUpsertWithWhereUniqueWithoutItemInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutItemInput, OrderItemUncheckedUpdateWithoutItemInput>
    create: XOR<OrderItemCreateWithoutItemInput, OrderItemUncheckedCreateWithoutItemInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutItemInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutItemInput, OrderItemUncheckedUpdateWithoutItemInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutItemInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderItemInput>
  }

  export type ItemCreateWithoutItemNCMInput = {
    id?: string
    itemId: string
    name: string
    price: number
    priceToGo?: number | null
    employeePrice?: number | null
    category: string
    canTakeToGo?: boolean | null
    isActive: boolean
    hasTaxSubstitution?: boolean | null
    establishment?: EstablishmentCreateNestedOneWithoutItemsInput
    orderItem?: OrderItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutItemNCMInput = {
    id?: string
    itemId: string
    name: string
    price: number
    priceToGo?: number | null
    employeePrice?: number | null
    category: string
    canTakeToGo?: boolean | null
    isActive: boolean
    hasTaxSubstitution?: boolean | null
    establishmentId?: string | null
    orderItem?: OrderItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutItemNCMInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItemNCMInput, ItemUncheckedCreateWithoutItemNCMInput>
  }

  export type ItemCreateManyItemNCMInputEnvelope = {
    data: Enumerable<ItemCreateManyItemNCMInput>
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutItemNCMInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutItemNCMInput, ItemUncheckedUpdateWithoutItemNCMInput>
    create: XOR<ItemCreateWithoutItemNCMInput, ItemUncheckedCreateWithoutItemNCMInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutItemNCMInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutItemNCMInput, ItemUncheckedUpdateWithoutItemNCMInput>
  }

  export type ItemUpdateManyWithWhereWithoutItemNCMInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type BillCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    tableData?: TableDataCreateNestedOneWithoutBillsInput
    workDay?: WorkDayCreateNestedOneWithoutBillsInput
    payments?: PaymentCreateNestedManyWithoutBillInput
    reopenBillsId?: BillCreateNestedManyWithoutReopenBillsInput
    reopenBills?: BillCreateNestedManyWithoutReopenBillsIdInput
  }

  export type BillUncheckedCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    workDayId?: string | null
    tableDataId?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutOrdersInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutOrdersInput, BillUncheckedCreateWithoutOrdersInput>
  }

  export type WorkDayCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishment?: EstablishmentCreateNestedOneWithoutWorkingDaysInput
    userResponsible?: UserCreateNestedOneWithoutResponsibleWorkDaysInput
    bills?: BillCreateNestedManyWithoutWorkDayInput
    incomes?: IncomeCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadCreateNestedManyWithoutWorkDayInput
    tables?: TableDataCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishmentId?: string | null
    userResponsibleId?: string | null
    bills?: BillUncheckedCreateNestedManyWithoutWorkDayInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedCreateNestedManyWithoutWorkDayInput
    tables?: TableDataUncheckedCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayCreateOrConnectWithoutOrdersInput = {
    where: WorkDayWhereUniqueInput
    create: XOR<WorkDayCreateWithoutOrdersInput, WorkDayUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity: number
    employee?: EmployeeCreateNestedOneWithoutItemsOrderedInput
    item?: ItemCreateNestedOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    quantity: number
    employeeId?: string | null
    itemId?: string | null
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: Enumerable<OrderItemCreateManyOrderInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutModifiedOrdersInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    bill?: BillCreateNestedOneWithoutOrdersInput
    workDay?: WorkDayCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    modifiedOrdersId?: OrderCreateNestedManyWithoutModifiedOrdersInput
  }

  export type OrderUncheckedCreateWithoutModifiedOrdersInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    workDayId?: string | null
    billId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutModifiedOrdersInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutModifiedOrdersInput, OrderUncheckedCreateWithoutModifiedOrdersInput>
  }

  export type OrderCreateWithoutModifiedOrdersIdInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    bill?: BillCreateNestedOneWithoutOrdersInput
    workDay?: WorkDayCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    modifiedOrders?: OrderCreateNestedManyWithoutModifiedOrdersIdInput
  }

  export type OrderUncheckedCreateWithoutModifiedOrdersIdInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    workDayId?: string | null
    billId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutModifiedOrdersIdInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutModifiedOrdersIdInput, OrderUncheckedCreateWithoutModifiedOrdersIdInput>
  }

  export type BillUpsertWithoutOrdersInput = {
    update: XOR<BillUpdateWithoutOrdersInput, BillUncheckedUpdateWithoutOrdersInput>
    create: XOR<BillCreateWithoutOrdersInput, BillUncheckedCreateWithoutOrdersInput>
  }

  export type BillUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tableData?: TableDataUpdateOneWithoutBillsInput
    workDay?: WorkDayUpdateOneWithoutBillsInput
    payments?: PaymentUpdateManyWithoutBillInput
    reopenBillsId?: BillUpdateManyWithoutReopenBillsInput
    reopenBills?: BillUpdateManyWithoutReopenBillsIdInput
  }

  export type BillUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableDataId?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutBillInput
  }

  export type WorkDayUpsertWithoutOrdersInput = {
    update: XOR<WorkDayUpdateWithoutOrdersInput, WorkDayUncheckedUpdateWithoutOrdersInput>
    create: XOR<WorkDayCreateWithoutOrdersInput, WorkDayUncheckedCreateWithoutOrdersInput>
  }

  export type WorkDayUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishment?: EstablishmentUpdateOneWithoutWorkingDaysInput
    userResponsible?: UserUpdateOneWithoutResponsibleWorkDaysInput
    bills?: BillUpdateManyWithoutWorkDayInput
    incomes?: IncomeUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUpdateManyWithoutWorkDayInput
    tables?: TableDataUpdateManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    userResponsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    bills?: BillUncheckedUpdateManyWithoutWorkDayInput
    incomes?: IncomeUncheckedUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedUpdateManyWithoutWorkDayInput
    tables?: TableDataUncheckedUpdateManyWithoutWorkDayInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderItemsInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutModifiedOrdersInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutModifiedOrdersInput, OrderUncheckedUpdateWithoutModifiedOrdersInput>
    create: XOR<OrderCreateWithoutModifiedOrdersInput, OrderUncheckedCreateWithoutModifiedOrdersInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutModifiedOrdersInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutModifiedOrdersInput, OrderUncheckedUpdateWithoutModifiedOrdersInput>
  }

  export type OrderUpdateManyWithWhereWithoutModifiedOrdersInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutModifiedOrdersIdInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutModifiedOrdersIdInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutModifiedOrdersIdInput, OrderUncheckedUpdateWithoutModifiedOrdersIdInput>
    create: XOR<OrderCreateWithoutModifiedOrdersIdInput, OrderUncheckedCreateWithoutModifiedOrdersIdInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutModifiedOrdersIdInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutModifiedOrdersIdInput, OrderUncheckedUpdateWithoutModifiedOrdersIdInput>
  }

  export type OrderUpdateManyWithWhereWithoutModifiedOrdersIdInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutModifiedOrdersInput>
  }

  export type EmployeeCreateWithoutItemsOrderedInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    establishment?: EstablishmentCreateNestedOneWithoutEmployeesInput
    orderPads?: OrderPadCreateNestedManyWithoutEmployeeInput
    tables?: TableDataCreateNestedManyWithoutWaiterInput
    workHours?: WorkHourCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutItemsOrderedInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    establishmentId?: string | null
    orderPads?: OrderPadUncheckedCreateNestedManyWithoutEmployeeInput
    tables?: TableDataUncheckedCreateNestedManyWithoutWaiterInput
    workHours?: WorkHourUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutItemsOrderedInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutItemsOrderedInput, EmployeeUncheckedCreateWithoutItemsOrderedInput>
  }

  export type ItemCreateWithoutOrderItemInput = {
    id?: string
    itemId: string
    name: string
    price: number
    priceToGo?: number | null
    employeePrice?: number | null
    category: string
    canTakeToGo?: boolean | null
    isActive: boolean
    hasTaxSubstitution?: boolean | null
    establishment?: EstablishmentCreateNestedOneWithoutItemsInput
    itemNCM?: NCMCreateNestedOneWithoutItemsInput
  }

  export type ItemUncheckedCreateWithoutOrderItemInput = {
    id?: string
    itemId: string
    name: string
    price: number
    priceToGo?: number | null
    employeePrice?: number | null
    category: string
    canTakeToGo?: boolean | null
    isActive: boolean
    hasTaxSubstitution?: boolean | null
    establishmentId?: string | null
    itemNCMId?: string | null
  }

  export type ItemCreateOrConnectWithoutOrderItemInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutOrderItemInput, ItemUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderCreateWithoutOrderItemsInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    bill?: BillCreateNestedOneWithoutOrdersInput
    workDay?: WorkDayCreateNestedOneWithoutOrdersInput
    modifiedOrdersId?: OrderCreateNestedManyWithoutModifiedOrdersInput
    modifiedOrders?: OrderCreateNestedManyWithoutModifiedOrdersIdInput
  }

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    workDayId?: string | null
    billId?: string | null
  }

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type EmployeeUpsertWithoutItemsOrderedInput = {
    update: XOR<EmployeeUpdateWithoutItemsOrderedInput, EmployeeUncheckedUpdateWithoutItemsOrderedInput>
    create: XOR<EmployeeCreateWithoutItemsOrderedInput, EmployeeUncheckedCreateWithoutItemsOrderedInput>
  }

  export type EmployeeUpdateWithoutItemsOrderedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishment?: EstablishmentUpdateOneWithoutEmployeesInput
    orderPads?: OrderPadUpdateManyWithoutEmployeeInput
    tables?: TableDataUpdateManyWithoutWaiterInput
    workHours?: WorkHourUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutItemsOrderedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderPads?: OrderPadUncheckedUpdateManyWithoutEmployeeInput
    tables?: TableDataUncheckedUpdateManyWithoutWaiterInput
    workHours?: WorkHourUncheckedUpdateManyWithoutEmployeeInput
  }

  export type ItemUpsertWithoutOrderItemInput = {
    update: XOR<ItemUpdateWithoutOrderItemInput, ItemUncheckedUpdateWithoutOrderItemInput>
    create: XOR<ItemCreateWithoutOrderItemInput, ItemUncheckedCreateWithoutOrderItemInput>
  }

  export type ItemUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceToGo?: NullableFloatFieldUpdateOperationsInput | number | null
    employeePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    canTakeToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasTaxSubstitution?: NullableBoolFieldUpdateOperationsInput | boolean | null
    establishment?: EstablishmentUpdateOneWithoutItemsInput
    itemNCM?: NCMUpdateOneWithoutItemsInput
  }

  export type ItemUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceToGo?: NullableFloatFieldUpdateOperationsInput | number | null
    employeePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    canTakeToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasTaxSubstitution?: NullableBoolFieldUpdateOperationsInput | boolean | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemNCMId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    bill?: BillUpdateOneWithoutOrdersInput
    workDay?: WorkDayUpdateOneWithoutOrdersInput
    modifiedOrdersId?: OrderUpdateManyWithoutModifiedOrdersInput
    modifiedOrders?: OrderUpdateManyWithoutModifiedOrdersIdInput
  }

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeCreateWithoutOrderPadsInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    establishment?: EstablishmentCreateNestedOneWithoutEmployeesInput
    itemsOrdered?: OrderItemCreateNestedManyWithoutEmployeeInput
    tables?: TableDataCreateNestedManyWithoutWaiterInput
    workHours?: WorkHourCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutOrderPadsInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    establishmentId?: string | null
    itemsOrdered?: OrderItemUncheckedCreateNestedManyWithoutEmployeeInput
    tables?: TableDataUncheckedCreateNestedManyWithoutWaiterInput
    workHours?: WorkHourUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutOrderPadsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutOrderPadsInput, EmployeeUncheckedCreateWithoutOrderPadsInput>
  }

  export type WorkDayCreateWithoutOrderPadsInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishment?: EstablishmentCreateNestedOneWithoutWorkingDaysInput
    userResponsible?: UserCreateNestedOneWithoutResponsibleWorkDaysInput
    bills?: BillCreateNestedManyWithoutWorkDayInput
    incomes?: IncomeCreateNestedManyWithoutWorkDayInput
    orders?: OrderCreateNestedManyWithoutWorkDayInput
    tables?: TableDataCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedCreateWithoutOrderPadsInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishmentId?: string | null
    userResponsibleId?: string | null
    bills?: BillUncheckedCreateNestedManyWithoutWorkDayInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutWorkDayInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkDayInput
    tables?: TableDataUncheckedCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayCreateOrConnectWithoutOrderPadsInput = {
    where: WorkDayWhereUniqueInput
    create: XOR<WorkDayCreateWithoutOrderPadsInput, WorkDayUncheckedCreateWithoutOrderPadsInput>
  }

  export type EmployeeUpsertWithoutOrderPadsInput = {
    update: XOR<EmployeeUpdateWithoutOrderPadsInput, EmployeeUncheckedUpdateWithoutOrderPadsInput>
    create: XOR<EmployeeCreateWithoutOrderPadsInput, EmployeeUncheckedCreateWithoutOrderPadsInput>
  }

  export type EmployeeUpdateWithoutOrderPadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishment?: EstablishmentUpdateOneWithoutEmployeesInput
    itemsOrdered?: OrderItemUpdateManyWithoutEmployeeInput
    tables?: TableDataUpdateManyWithoutWaiterInput
    workHours?: WorkHourUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutOrderPadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemsOrdered?: OrderItemUncheckedUpdateManyWithoutEmployeeInput
    tables?: TableDataUncheckedUpdateManyWithoutWaiterInput
    workHours?: WorkHourUncheckedUpdateManyWithoutEmployeeInput
  }

  export type WorkDayUpsertWithoutOrderPadsInput = {
    update: XOR<WorkDayUpdateWithoutOrderPadsInput, WorkDayUncheckedUpdateWithoutOrderPadsInput>
    create: XOR<WorkDayCreateWithoutOrderPadsInput, WorkDayUncheckedCreateWithoutOrderPadsInput>
  }

  export type WorkDayUpdateWithoutOrderPadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishment?: EstablishmentUpdateOneWithoutWorkingDaysInput
    userResponsible?: UserUpdateOneWithoutResponsibleWorkDaysInput
    bills?: BillUpdateManyWithoutWorkDayInput
    incomes?: IncomeUpdateManyWithoutWorkDayInput
    orders?: OrderUpdateManyWithoutWorkDayInput
    tables?: TableDataUpdateManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedUpdateWithoutOrderPadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    userResponsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    bills?: BillUncheckedUpdateManyWithoutWorkDayInput
    incomes?: IncomeUncheckedUpdateManyWithoutWorkDayInput
    orders?: OrderUncheckedUpdateManyWithoutWorkDayInput
    tables?: TableDataUncheckedUpdateManyWithoutWorkDayInput
  }

  export type BillCreateWithoutPaymentsInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    tableData?: TableDataCreateNestedOneWithoutBillsInput
    workDay?: WorkDayCreateNestedOneWithoutBillsInput
    orders?: OrderCreateNestedManyWithoutBillInput
    reopenBillsId?: BillCreateNestedManyWithoutReopenBillsInput
    reopenBills?: BillCreateNestedManyWithoutReopenBillsIdInput
  }

  export type BillUncheckedCreateWithoutPaymentsInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    workDayId?: string | null
    tableDataId?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutPaymentsInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutPaymentsInput, BillUncheckedCreateWithoutPaymentsInput>
  }

  export type CheckDataCreateWithoutPaymentInput = {
    id?: string
    checkbookId?: string | null
    compensationNumber?: number | null
    bankNumber?: number | null
  }

  export type CheckDataUncheckedCreateWithoutPaymentInput = {
    id?: string
    checkbookId?: string | null
    compensationNumber?: number | null
    bankNumber?: number | null
  }

  export type CheckDataCreateOrConnectWithoutPaymentInput = {
    where: CheckDataWhereUniqueInput
    create: XOR<CheckDataCreateWithoutPaymentInput, CheckDataUncheckedCreateWithoutPaymentInput>
  }

  export type ExpenseCreateWithoutPaymentInput = {
    id?: string
    createdAt?: Date | string
    NFE: boolean
    NFEReference?: string | null
    date: Date | string
    executionDate: Date | string
    establishment?: EstablishmentCreateNestedOneWithoutExpensesInput
    expenseItems?: ExpenseItemCreateNestedManyWithoutExpenseInput
  }

  export type ExpenseUncheckedCreateWithoutPaymentInput = {
    id?: string
    createdAt?: Date | string
    NFE: boolean
    NFEReference?: string | null
    date: Date | string
    executionDate: Date | string
    establishmentId?: string | null
  }

  export type ExpenseCreateOrConnectWithoutPaymentInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutPaymentInput, ExpenseUncheckedCreateWithoutPaymentInput>
  }

  export type BillUpsertWithoutPaymentsInput = {
    update: XOR<BillUpdateWithoutPaymentsInput, BillUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BillCreateWithoutPaymentsInput, BillUncheckedCreateWithoutPaymentsInput>
  }

  export type BillUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tableData?: TableDataUpdateOneWithoutBillsInput
    workDay?: WorkDayUpdateOneWithoutBillsInput
    orders?: OrderUpdateManyWithoutBillInput
    reopenBillsId?: BillUpdateManyWithoutReopenBillsInput
    reopenBills?: BillUpdateManyWithoutReopenBillsIdInput
  }

  export type BillUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableDataId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutBillInput
  }

  export type CheckDataUpsertWithoutPaymentInput = {
    update: XOR<CheckDataUpdateWithoutPaymentInput, CheckDataUncheckedUpdateWithoutPaymentInput>
    create: XOR<CheckDataCreateWithoutPaymentInput, CheckDataUncheckedCreateWithoutPaymentInput>
  }

  export type CheckDataUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkbookId?: NullableStringFieldUpdateOperationsInput | string | null
    compensationNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bankNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CheckDataUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkbookId?: NullableStringFieldUpdateOperationsInput | string | null
    compensationNumber?: NullableIntFieldUpdateOperationsInput | number | null
    bankNumber?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseUpsertWithoutPaymentInput = {
    update: XOR<ExpenseUpdateWithoutPaymentInput, ExpenseUncheckedUpdateWithoutPaymentInput>
    create: XOR<ExpenseCreateWithoutPaymentInput, ExpenseUncheckedCreateWithoutPaymentInput>
  }

  export type ExpenseUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NFE?: BoolFieldUpdateOperationsInput | boolean
    NFEReference?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    establishment?: EstablishmentUpdateOneWithoutExpensesInput
    expenseItems?: ExpenseItemUpdateManyWithoutExpenseInput
  }

  export type ExpenseUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NFE?: BoolFieldUpdateOperationsInput | boolean
    NFEReference?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EstablishmentCreateWithoutPermissionsInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientCreateNestedManyWithoutEstablishmentInput
    employees?: EmployeeCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseCreateNestedManyWithoutEstablishmentInput
    items?: ItemCreateNestedManyWithoutEstablishmentInput
    tables?: TableCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedCreateWithoutPermissionsInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedCreateNestedManyWithoutEstablishmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEstablishmentInput
    items?: ItemUncheckedCreateNestedManyWithoutEstablishmentInput
    tables?: TableUncheckedCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentCreateOrConnectWithoutPermissionsInput = {
    where: EstablishmentWhereUniqueInput
    create: XOR<EstablishmentCreateWithoutPermissionsInput, EstablishmentUncheckedCreateWithoutPermissionsInput>
  }

  export type UserCreateWithoutPermissionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    password?: string | null
    responsibleWorkDays?: WorkDayCreateNestedManyWithoutUserResponsibleInput
  }

  export type UserUncheckedCreateWithoutPermissionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    password?: string | null
    responsibleWorkDays?: WorkDayUncheckedCreateNestedManyWithoutUserResponsibleInput
  }

  export type UserCreateOrConnectWithoutPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
  }

  export type EstablishmentUpsertWithoutPermissionsInput = {
    update: XOR<EstablishmentUpdateWithoutPermissionsInput, EstablishmentUncheckedUpdateWithoutPermissionsInput>
    create: XOR<EstablishmentCreateWithoutPermissionsInput, EstablishmentUncheckedCreateWithoutPermissionsInput>
  }

  export type EstablishmentUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUpdateManyWithoutEstablishmentInput
    employees?: EmployeeUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUpdateManyWithoutEstablishmentInput
    items?: ItemUpdateManyWithoutEstablishmentInput
    tables?: TableUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUpdateManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedUpdateManyWithoutEstablishmentInput
    employees?: EmployeeUncheckedUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEstablishmentInput
    items?: ItemUncheckedUpdateManyWithoutEstablishmentInput
    tables?: TableUncheckedUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedUpdateManyWithoutEstablishmentInput
  }

  export type UserUpsertWithoutPermissionsInput = {
    update: XOR<UserUpdateWithoutPermissionsInput, UserUncheckedUpdateWithoutPermissionsInput>
    create: XOR<UserCreateWithoutPermissionsInput, UserUncheckedCreateWithoutPermissionsInput>
  }

  export type UserUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleWorkDays?: WorkDayUpdateManyWithoutUserResponsibleInput
  }

  export type UserUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    responsibleWorkDays?: WorkDayUncheckedUpdateManyWithoutUserResponsibleInput
  }

  export type ExpenseItemCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    value: number
    details?: string | null
    Expense?: ExpenseCreateNestedManyWithoutExpenseItemsInput
  }

  export type ExpenseItemUncheckedCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    value: number
    details?: string | null
  }

  export type ExpenseItemCreateOrConnectWithoutProductInput = {
    where: ExpenseItemWhereUniqueInput
    create: XOR<ExpenseItemCreateWithoutProductInput, ExpenseItemUncheckedCreateWithoutProductInput>
  }

  export type ExpenseItemCreateManyProductInputEnvelope = {
    data: Enumerable<ExpenseItemCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type ExpenseItemUpsertWithWhereUniqueWithoutProductInput = {
    where: ExpenseItemWhereUniqueInput
    update: XOR<ExpenseItemUpdateWithoutProductInput, ExpenseItemUncheckedUpdateWithoutProductInput>
    create: XOR<ExpenseItemCreateWithoutProductInput, ExpenseItemUncheckedCreateWithoutProductInput>
  }

  export type ExpenseItemUpdateWithWhereUniqueWithoutProductInput = {
    where: ExpenseItemWhereUniqueInput
    data: XOR<ExpenseItemUpdateWithoutProductInput, ExpenseItemUncheckedUpdateWithoutProductInput>
  }

  export type ExpenseItemUpdateManyWithWhereWithoutProductInput = {
    where: ExpenseItemScalarWhereInput
    data: XOR<ExpenseItemUpdateManyMutationInput, ExpenseItemUncheckedUpdateManyWithoutExpenseItemInput>
  }

  export type EstablishmentCreateWithoutTablesInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientCreateNestedManyWithoutEstablishmentInput
    employees?: EmployeeCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseCreateNestedManyWithoutEstablishmentInput
    items?: ItemCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedCreateWithoutTablesInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedCreateNestedManyWithoutEstablishmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEstablishmentInput
    items?: ItemUncheckedCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentCreateOrConnectWithoutTablesInput = {
    where: EstablishmentWhereUniqueInput
    create: XOR<EstablishmentCreateWithoutTablesInput, EstablishmentUncheckedCreateWithoutTablesInput>
  }

  export type TableDataCreateWithoutTableInput = {
    id?: string
    totalOccupations: number
    waiter?: EmployeeCreateNestedOneWithoutTablesInput
    workDay?: WorkDayCreateNestedOneWithoutTablesInput
    bills?: BillCreateNestedManyWithoutTableDataInput
  }

  export type TableDataUncheckedCreateWithoutTableInput = {
    id?: string
    totalOccupations: number
    workDayId?: string | null
    waiterId?: string | null
    bills?: BillUncheckedCreateNestedManyWithoutTableDataInput
  }

  export type TableDataCreateOrConnectWithoutTableInput = {
    where: TableDataWhereUniqueInput
    create: XOR<TableDataCreateWithoutTableInput, TableDataUncheckedCreateWithoutTableInput>
  }

  export type TableDataCreateManyTableInputEnvelope = {
    data: Enumerable<TableDataCreateManyTableInput>
    skipDuplicates?: boolean
  }

  export type EstablishmentUpsertWithoutTablesInput = {
    update: XOR<EstablishmentUpdateWithoutTablesInput, EstablishmentUncheckedUpdateWithoutTablesInput>
    create: XOR<EstablishmentCreateWithoutTablesInput, EstablishmentUncheckedCreateWithoutTablesInput>
  }

  export type EstablishmentUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUpdateManyWithoutEstablishmentInput
    employees?: EmployeeUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUpdateManyWithoutEstablishmentInput
    items?: ItemUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUpdateManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedUpdateManyWithoutEstablishmentInput
    employees?: EmployeeUncheckedUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEstablishmentInput
    items?: ItemUncheckedUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedUpdateManyWithoutEstablishmentInput
    workingDays?: WorkDayUncheckedUpdateManyWithoutEstablishmentInput
  }

  export type TableDataUpsertWithWhereUniqueWithoutTableInput = {
    where: TableDataWhereUniqueInput
    update: XOR<TableDataUpdateWithoutTableInput, TableDataUncheckedUpdateWithoutTableInput>
    create: XOR<TableDataCreateWithoutTableInput, TableDataUncheckedCreateWithoutTableInput>
  }

  export type TableDataUpdateWithWhereUniqueWithoutTableInput = {
    where: TableDataWhereUniqueInput
    data: XOR<TableDataUpdateWithoutTableInput, TableDataUncheckedUpdateWithoutTableInput>
  }

  export type TableDataUpdateManyWithWhereWithoutTableInput = {
    where: TableDataScalarWhereInput
    data: XOR<TableDataUpdateManyMutationInput, TableDataUncheckedUpdateManyWithoutDataInput>
  }

  export type TableCreateWithoutDataInput = {
    id?: string
    tableNumber: number
    establishment?: EstablishmentCreateNestedOneWithoutTablesInput
  }

  export type TableUncheckedCreateWithoutDataInput = {
    id?: string
    tableNumber: number
    establishmentId?: string | null
  }

  export type TableCreateOrConnectWithoutDataInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutDataInput, TableUncheckedCreateWithoutDataInput>
  }

  export type EmployeeCreateWithoutTablesInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    establishment?: EstablishmentCreateNestedOneWithoutEmployeesInput
    itemsOrdered?: OrderItemCreateNestedManyWithoutEmployeeInput
    orderPads?: OrderPadCreateNestedManyWithoutEmployeeInput
    workHours?: WorkHourCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTablesInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    establishmentId?: string | null
    itemsOrdered?: OrderItemUncheckedCreateNestedManyWithoutEmployeeInput
    orderPads?: OrderPadUncheckedCreateNestedManyWithoutEmployeeInput
    workHours?: WorkHourUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTablesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTablesInput, EmployeeUncheckedCreateWithoutTablesInput>
  }

  export type WorkDayCreateWithoutTablesInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishment?: EstablishmentCreateNestedOneWithoutWorkingDaysInput
    userResponsible?: UserCreateNestedOneWithoutResponsibleWorkDaysInput
    bills?: BillCreateNestedManyWithoutWorkDayInput
    incomes?: IncomeCreateNestedManyWithoutWorkDayInput
    orders?: OrderCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedCreateWithoutTablesInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishmentId?: string | null
    userResponsibleId?: string | null
    bills?: BillUncheckedCreateNestedManyWithoutWorkDayInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutWorkDayInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayCreateOrConnectWithoutTablesInput = {
    where: WorkDayWhereUniqueInput
    create: XOR<WorkDayCreateWithoutTablesInput, WorkDayUncheckedCreateWithoutTablesInput>
  }

  export type BillCreateWithoutTableDataInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    workDay?: WorkDayCreateNestedOneWithoutBillsInput
    orders?: OrderCreateNestedManyWithoutBillInput
    payments?: PaymentCreateNestedManyWithoutBillInput
    reopenBillsId?: BillCreateNestedManyWithoutReopenBillsInput
    reopenBills?: BillCreateNestedManyWithoutReopenBillsIdInput
  }

  export type BillUncheckedCreateWithoutTableDataInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    workDayId?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutBillInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutTableDataInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutTableDataInput, BillUncheckedCreateWithoutTableDataInput>
  }

  export type BillCreateManyTableDataInputEnvelope = {
    data: Enumerable<BillCreateManyTableDataInput>
    skipDuplicates?: boolean
  }

  export type TableUpsertWithoutDataInput = {
    update: XOR<TableUpdateWithoutDataInput, TableUncheckedUpdateWithoutDataInput>
    create: XOR<TableCreateWithoutDataInput, TableUncheckedCreateWithoutDataInput>
  }

  export type TableUpdateWithoutDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableNumber?: IntFieldUpdateOperationsInput | number
    establishment?: EstablishmentUpdateOneWithoutTablesInput
  }

  export type TableUncheckedUpdateWithoutDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableNumber?: IntFieldUpdateOperationsInput | number
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeUpsertWithoutTablesInput = {
    update: XOR<EmployeeUpdateWithoutTablesInput, EmployeeUncheckedUpdateWithoutTablesInput>
    create: XOR<EmployeeCreateWithoutTablesInput, EmployeeUncheckedCreateWithoutTablesInput>
  }

  export type EmployeeUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishment?: EstablishmentUpdateOneWithoutEmployeesInput
    itemsOrdered?: OrderItemUpdateManyWithoutEmployeeInput
    orderPads?: OrderPadUpdateManyWithoutEmployeeInput
    workHours?: WorkHourUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemsOrdered?: OrderItemUncheckedUpdateManyWithoutEmployeeInput
    orderPads?: OrderPadUncheckedUpdateManyWithoutEmployeeInput
    workHours?: WorkHourUncheckedUpdateManyWithoutEmployeeInput
  }

  export type WorkDayUpsertWithoutTablesInput = {
    update: XOR<WorkDayUpdateWithoutTablesInput, WorkDayUncheckedUpdateWithoutTablesInput>
    create: XOR<WorkDayCreateWithoutTablesInput, WorkDayUncheckedCreateWithoutTablesInput>
  }

  export type WorkDayUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishment?: EstablishmentUpdateOneWithoutWorkingDaysInput
    userResponsible?: UserUpdateOneWithoutResponsibleWorkDaysInput
    bills?: BillUpdateManyWithoutWorkDayInput
    incomes?: IncomeUpdateManyWithoutWorkDayInput
    orders?: OrderUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUpdateManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    userResponsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    bills?: BillUncheckedUpdateManyWithoutWorkDayInput
    incomes?: IncomeUncheckedUpdateManyWithoutWorkDayInput
    orders?: OrderUncheckedUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedUpdateManyWithoutWorkDayInput
  }

  export type BillUpsertWithWhereUniqueWithoutTableDataInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutTableDataInput, BillUncheckedUpdateWithoutTableDataInput>
    create: XOR<BillCreateWithoutTableDataInput, BillUncheckedCreateWithoutTableDataInput>
  }

  export type BillUpdateWithWhereUniqueWithoutTableDataInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutTableDataInput, BillUncheckedUpdateWithoutTableDataInput>
  }

  export type BillUpdateManyWithWhereWithoutTableDataInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutBillsInput>
  }

  export type PermissionCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    role: UserRole
    establishment?: EstablishmentCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    role: UserRole
    establishmentId?: string | null
  }

  export type PermissionCreateOrConnectWithoutUserInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutUserInput, PermissionUncheckedCreateWithoutUserInput>
  }

  export type PermissionCreateManyUserInputEnvelope = {
    data: Enumerable<PermissionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type WorkDayCreateWithoutUserResponsibleInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishment?: EstablishmentCreateNestedOneWithoutWorkingDaysInput
    bills?: BillCreateNestedManyWithoutWorkDayInput
    incomes?: IncomeCreateNestedManyWithoutWorkDayInput
    orders?: OrderCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadCreateNestedManyWithoutWorkDayInput
    tables?: TableDataCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedCreateWithoutUserResponsibleInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishmentId?: string | null
    bills?: BillUncheckedCreateNestedManyWithoutWorkDayInput
    incomes?: IncomeUncheckedCreateNestedManyWithoutWorkDayInput
    orders?: OrderUncheckedCreateNestedManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedCreateNestedManyWithoutWorkDayInput
    tables?: TableDataUncheckedCreateNestedManyWithoutWorkDayInput
  }

  export type WorkDayCreateOrConnectWithoutUserResponsibleInput = {
    where: WorkDayWhereUniqueInput
    create: XOR<WorkDayCreateWithoutUserResponsibleInput, WorkDayUncheckedCreateWithoutUserResponsibleInput>
  }

  export type WorkDayCreateManyUserResponsibleInputEnvelope = {
    data: Enumerable<WorkDayCreateManyUserResponsibleInput>
    skipDuplicates?: boolean
  }

  export type PermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutUserInput, PermissionUncheckedUpdateWithoutUserInput>
    create: XOR<PermissionCreateWithoutUserInput, PermissionUncheckedCreateWithoutUserInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutUserInput, PermissionUncheckedUpdateWithoutUserInput>
  }

  export type PermissionUpdateManyWithWhereWithoutUserInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type WorkDayUpsertWithWhereUniqueWithoutUserResponsibleInput = {
    where: WorkDayWhereUniqueInput
    update: XOR<WorkDayUpdateWithoutUserResponsibleInput, WorkDayUncheckedUpdateWithoutUserResponsibleInput>
    create: XOR<WorkDayCreateWithoutUserResponsibleInput, WorkDayUncheckedCreateWithoutUserResponsibleInput>
  }

  export type WorkDayUpdateWithWhereUniqueWithoutUserResponsibleInput = {
    where: WorkDayWhereUniqueInput
    data: XOR<WorkDayUpdateWithoutUserResponsibleInput, WorkDayUncheckedUpdateWithoutUserResponsibleInput>
  }

  export type WorkDayUpdateManyWithWhereWithoutUserResponsibleInput = {
    where: WorkDayScalarWhereInput
    data: XOR<WorkDayUpdateManyMutationInput, WorkDayUncheckedUpdateManyWithoutResponsibleWorkDaysInput>
  }

  export type EstablishmentCreateWithoutWorkingDaysInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientCreateNestedManyWithoutEstablishmentInput
    employees?: EmployeeCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseCreateNestedManyWithoutEstablishmentInput
    items?: ItemCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionCreateNestedManyWithoutEstablishmentInput
    tables?: TableCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedCreateWithoutWorkingDaysInput = {
    id?: string
    createdAt?: Date | string
    name: string
    lat?: number
    long?: number
    restaurantId: string
    valueInCashRegister: number
    maximumInCashRegister: number
    incomeMaxReference: number
    isOpen: boolean
    totalInvoices?: number | null
    discountReasons?: EstablishmentCreatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedCreateNestedManyWithoutEstablishmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutEstablishmentInput
    items?: ItemUncheckedCreateNestedManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutEstablishmentInput
    tables?: TableUncheckedCreateNestedManyWithoutEstablishmentInput
  }

  export type EstablishmentCreateOrConnectWithoutWorkingDaysInput = {
    where: EstablishmentWhereUniqueInput
    create: XOR<EstablishmentCreateWithoutWorkingDaysInput, EstablishmentUncheckedCreateWithoutWorkingDaysInput>
  }

  export type UserCreateWithoutResponsibleWorkDaysInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    password?: string | null
    permissions?: PermissionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResponsibleWorkDaysInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    email?: string | null
    password?: string | null
    permissions?: PermissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResponsibleWorkDaysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResponsibleWorkDaysInput, UserUncheckedCreateWithoutResponsibleWorkDaysInput>
  }

  export type BillCreateWithoutWorkDayInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    tableData?: TableDataCreateNestedOneWithoutBillsInput
    orders?: OrderCreateNestedManyWithoutBillInput
    payments?: PaymentCreateNestedManyWithoutBillInput
    reopenBillsId?: BillCreateNestedManyWithoutReopenBillsInput
    reopenBills?: BillCreateNestedManyWithoutReopenBillsIdInput
  }

  export type BillUncheckedCreateWithoutWorkDayInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    tableDataId?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutBillInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBillInput
  }

  export type BillCreateOrConnectWithoutWorkDayInput = {
    where: BillWhereUniqueInput
    create: XOR<BillCreateWithoutWorkDayInput, BillUncheckedCreateWithoutWorkDayInput>
  }

  export type BillCreateManyWorkDayInputEnvelope = {
    data: Enumerable<BillCreateManyWorkDayInput>
    skipDuplicates?: boolean
  }

  export type IncomeCreateWithoutWorkDayInput = {
    id?: string
    createdAt?: Date | string
    reference: string
    value: number
    type?: string | null
  }

  export type IncomeUncheckedCreateWithoutWorkDayInput = {
    id?: string
    createdAt?: Date | string
    reference: string
    value: number
    type?: string | null
  }

  export type IncomeCreateOrConnectWithoutWorkDayInput = {
    where: IncomeWhereUniqueInput
    create: XOR<IncomeCreateWithoutWorkDayInput, IncomeUncheckedCreateWithoutWorkDayInput>
  }

  export type IncomeCreateManyWorkDayInputEnvelope = {
    data: Enumerable<IncomeCreateManyWorkDayInput>
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutWorkDayInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    bill?: BillCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    modifiedOrdersId?: OrderCreateNestedManyWithoutModifiedOrdersInput
    modifiedOrders?: OrderCreateNestedManyWithoutModifiedOrdersIdInput
  }

  export type OrderUncheckedCreateWithoutWorkDayInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    billId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutWorkDayInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutWorkDayInput, OrderUncheckedCreateWithoutWorkDayInput>
  }

  export type OrderCreateManyWorkDayInputEnvelope = {
    data: Enumerable<OrderCreateManyWorkDayInput>
    skipDuplicates?: boolean
  }

  export type OrderPadCreateWithoutWorkDayInput = {
    id?: string
    block: number
    firstOrderId: number
    lastOrderId?: number | null
    used: boolean
    employee?: EmployeeCreateNestedOneWithoutOrderPadsInput
  }

  export type OrderPadUncheckedCreateWithoutWorkDayInput = {
    id?: string
    block: number
    firstOrderId: number
    lastOrderId?: number | null
    used: boolean
    employeeId?: string | null
  }

  export type OrderPadCreateOrConnectWithoutWorkDayInput = {
    where: OrderPadWhereUniqueInput
    create: XOR<OrderPadCreateWithoutWorkDayInput, OrderPadUncheckedCreateWithoutWorkDayInput>
  }

  export type OrderPadCreateManyWorkDayInputEnvelope = {
    data: Enumerable<OrderPadCreateManyWorkDayInput>
    skipDuplicates?: boolean
  }

  export type TableDataCreateWithoutWorkDayInput = {
    id?: string
    totalOccupations: number
    table?: TableCreateNestedOneWithoutDataInput
    waiter?: EmployeeCreateNestedOneWithoutTablesInput
    bills?: BillCreateNestedManyWithoutTableDataInput
  }

  export type TableDataUncheckedCreateWithoutWorkDayInput = {
    id?: string
    totalOccupations: number
    tableId?: string | null
    waiterId?: string | null
    bills?: BillUncheckedCreateNestedManyWithoutTableDataInput
  }

  export type TableDataCreateOrConnectWithoutWorkDayInput = {
    where: TableDataWhereUniqueInput
    create: XOR<TableDataCreateWithoutWorkDayInput, TableDataUncheckedCreateWithoutWorkDayInput>
  }

  export type TableDataCreateManyWorkDayInputEnvelope = {
    data: Enumerable<TableDataCreateManyWorkDayInput>
    skipDuplicates?: boolean
  }

  export type EstablishmentUpsertWithoutWorkingDaysInput = {
    update: XOR<EstablishmentUpdateWithoutWorkingDaysInput, EstablishmentUncheckedUpdateWithoutWorkingDaysInput>
    create: XOR<EstablishmentCreateWithoutWorkingDaysInput, EstablishmentUncheckedCreateWithoutWorkingDaysInput>
  }

  export type EstablishmentUpdateWithoutWorkingDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUpdateManyWithoutEstablishmentInput
    employees?: EmployeeUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUpdateManyWithoutEstablishmentInput
    items?: ItemUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUpdateManyWithoutEstablishmentInput
    tables?: TableUpdateManyWithoutEstablishmentInput
  }

  export type EstablishmentUncheckedUpdateWithoutWorkingDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    long?: FloatFieldUpdateOperationsInput | number
    restaurantId?: StringFieldUpdateOperationsInput | string
    valueInCashRegister?: FloatFieldUpdateOperationsInput | number
    maximumInCashRegister?: FloatFieldUpdateOperationsInput | number
    incomeMaxReference?: IntFieldUpdateOperationsInput | number
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    totalInvoices?: NullableIntFieldUpdateOperationsInput | number | null
    discountReasons?: EstablishmentUpdatediscountReasonsInput | Enumerable<string>
    clients?: ClientUncheckedUpdateManyWithoutEstablishmentInput
    employees?: EmployeeUncheckedUpdateManyWithoutEstablishmentInput
    expenses?: ExpenseUncheckedUpdateManyWithoutEstablishmentInput
    items?: ItemUncheckedUpdateManyWithoutEstablishmentInput
    permissions?: PermissionUncheckedUpdateManyWithoutEstablishmentInput
    tables?: TableUncheckedUpdateManyWithoutEstablishmentInput
  }

  export type UserUpsertWithoutResponsibleWorkDaysInput = {
    update: XOR<UserUpdateWithoutResponsibleWorkDaysInput, UserUncheckedUpdateWithoutResponsibleWorkDaysInput>
    create: XOR<UserCreateWithoutResponsibleWorkDaysInput, UserUncheckedCreateWithoutResponsibleWorkDaysInput>
  }

  export type UserUpdateWithoutResponsibleWorkDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: PermissionUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutResponsibleWorkDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: PermissionUncheckedUpdateManyWithoutUserInput
  }

  export type BillUpsertWithWhereUniqueWithoutWorkDayInput = {
    where: BillWhereUniqueInput
    update: XOR<BillUpdateWithoutWorkDayInput, BillUncheckedUpdateWithoutWorkDayInput>
    create: XOR<BillCreateWithoutWorkDayInput, BillUncheckedCreateWithoutWorkDayInput>
  }

  export type BillUpdateWithWhereUniqueWithoutWorkDayInput = {
    where: BillWhereUniqueInput
    data: XOR<BillUpdateWithoutWorkDayInput, BillUncheckedUpdateWithoutWorkDayInput>
  }

  export type BillUpdateManyWithWhereWithoutWorkDayInput = {
    where: BillScalarWhereInput
    data: XOR<BillUpdateManyMutationInput, BillUncheckedUpdateManyWithoutBillsInput>
  }

  export type IncomeUpsertWithWhereUniqueWithoutWorkDayInput = {
    where: IncomeWhereUniqueInput
    update: XOR<IncomeUpdateWithoutWorkDayInput, IncomeUncheckedUpdateWithoutWorkDayInput>
    create: XOR<IncomeCreateWithoutWorkDayInput, IncomeUncheckedCreateWithoutWorkDayInput>
  }

  export type IncomeUpdateWithWhereUniqueWithoutWorkDayInput = {
    where: IncomeWhereUniqueInput
    data: XOR<IncomeUpdateWithoutWorkDayInput, IncomeUncheckedUpdateWithoutWorkDayInput>
  }

  export type IncomeUpdateManyWithWhereWithoutWorkDayInput = {
    where: IncomeScalarWhereInput
    data: XOR<IncomeUpdateManyMutationInput, IncomeUncheckedUpdateManyWithoutIncomesInput>
  }

  export type IncomeScalarWhereInput = {
    AND?: Enumerable<IncomeScalarWhereInput>
    OR?: Enumerable<IncomeScalarWhereInput>
    NOT?: Enumerable<IncomeScalarWhereInput>
    id?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    reference?: StringFilter | string
    value?: FloatFilter | number
    type?: StringNullableFilter | string | null
    workDayId?: StringNullableFilter | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutWorkDayInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutWorkDayInput, OrderUncheckedUpdateWithoutWorkDayInput>
    create: XOR<OrderCreateWithoutWorkDayInput, OrderUncheckedCreateWithoutWorkDayInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutWorkDayInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutWorkDayInput, OrderUncheckedUpdateWithoutWorkDayInput>
  }

  export type OrderUpdateManyWithWhereWithoutWorkDayInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrdersInput>
  }

  export type OrderPadUpsertWithWhereUniqueWithoutWorkDayInput = {
    where: OrderPadWhereUniqueInput
    update: XOR<OrderPadUpdateWithoutWorkDayInput, OrderPadUncheckedUpdateWithoutWorkDayInput>
    create: XOR<OrderPadCreateWithoutWorkDayInput, OrderPadUncheckedCreateWithoutWorkDayInput>
  }

  export type OrderPadUpdateWithWhereUniqueWithoutWorkDayInput = {
    where: OrderPadWhereUniqueInput
    data: XOR<OrderPadUpdateWithoutWorkDayInput, OrderPadUncheckedUpdateWithoutWorkDayInput>
  }

  export type OrderPadUpdateManyWithWhereWithoutWorkDayInput = {
    where: OrderPadScalarWhereInput
    data: XOR<OrderPadUpdateManyMutationInput, OrderPadUncheckedUpdateManyWithoutOrderPadsInput>
  }

  export type TableDataUpsertWithWhereUniqueWithoutWorkDayInput = {
    where: TableDataWhereUniqueInput
    update: XOR<TableDataUpdateWithoutWorkDayInput, TableDataUncheckedUpdateWithoutWorkDayInput>
    create: XOR<TableDataCreateWithoutWorkDayInput, TableDataUncheckedCreateWithoutWorkDayInput>
  }

  export type TableDataUpdateWithWhereUniqueWithoutWorkDayInput = {
    where: TableDataWhereUniqueInput
    data: XOR<TableDataUpdateWithoutWorkDayInput, TableDataUncheckedUpdateWithoutWorkDayInput>
  }

  export type TableDataUpdateManyWithWhereWithoutWorkDayInput = {
    where: TableDataScalarWhereInput
    data: XOR<TableDataUpdateManyMutationInput, TableDataUncheckedUpdateManyWithoutTablesInput>
  }

  export type EmployeeCreateWithoutWorkHoursInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    establishment?: EstablishmentCreateNestedOneWithoutEmployeesInput
    itemsOrdered?: OrderItemCreateNestedManyWithoutEmployeeInput
    orderPads?: OrderPadCreateNestedManyWithoutEmployeeInput
    tables?: TableDataCreateNestedManyWithoutWaiterInput
  }

  export type EmployeeUncheckedCreateWithoutWorkHoursInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
    establishmentId?: string | null
    itemsOrdered?: OrderItemUncheckedCreateNestedManyWithoutEmployeeInput
    orderPads?: OrderPadUncheckedCreateNestedManyWithoutEmployeeInput
    tables?: TableDataUncheckedCreateNestedManyWithoutWaiterInput
  }

  export type EmployeeCreateOrConnectWithoutWorkHoursInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWorkHoursInput, EmployeeUncheckedCreateWithoutWorkHoursInput>
  }

  export type EmployeeUpsertWithoutWorkHoursInput = {
    update: XOR<EmployeeUpdateWithoutWorkHoursInput, EmployeeUncheckedUpdateWithoutWorkHoursInput>
    create: XOR<EmployeeCreateWithoutWorkHoursInput, EmployeeUncheckedCreateWithoutWorkHoursInput>
  }

  export type EmployeeUpdateWithoutWorkHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishment?: EstablishmentUpdateOneWithoutEmployeesInput
    itemsOrdered?: OrderItemUpdateManyWithoutEmployeeInput
    orderPads?: OrderPadUpdateManyWithoutEmployeeInput
    tables?: TableDataUpdateManyWithoutWaiterInput
  }

  export type EmployeeUncheckedUpdateWithoutWorkHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemsOrdered?: OrderItemUncheckedUpdateManyWithoutEmployeeInput
    orderPads?: OrderPadUncheckedUpdateManyWithoutEmployeeInput
    tables?: TableDataUncheckedUpdateManyWithoutWaiterInput
  }

  export type OrderCreateManyBillInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    workDayId?: string | null
  }

  export type PaymentCreateManyBillInput = {
    id?: string
    createdAt?: Date | string
    value: number
    paymentType: string
    paymentTypeOption?: string | null
    isActive: boolean
    expenseId?: string | null
    checkDataId?: string | null
  }

  export type OrderUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    workDay?: WorkDayUpdateOneWithoutOrdersInput
    orderItems?: OrderItemUpdateManyWithoutOrderInput
    modifiedOrdersId?: OrderUpdateManyWithoutModifiedOrdersInput
    modifiedOrders?: OrderUpdateManyWithoutModifiedOrdersIdInput
  }

  export type OrderUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderInput
  }

  export type OrderUncheckedUpdateManyWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentTypeOption?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    checkData?: CheckDataUpdateOneWithoutPaymentInput
    expense?: ExpenseUpdateOneWithoutPaymentInput
  }

  export type PaymentUncheckedUpdateWithoutBillInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentTypeOption?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    checkDataId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    paymentType?: StringFieldUpdateOperationsInput | string
    paymentTypeOption?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expenseId?: NullableStringFieldUpdateOperationsInput | string | null
    checkDataId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillUpdateWithoutReopenBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tableData?: TableDataUpdateOneWithoutBillsInput
    workDay?: WorkDayUpdateOneWithoutBillsInput
    orders?: OrderUpdateManyWithoutBillInput
    payments?: PaymentUpdateManyWithoutBillInput
    reopenBillsId?: BillUpdateManyWithoutReopenBillsInput
  }

  export type BillUncheckedUpdateWithoutReopenBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableDataId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutBillInput
    payments?: PaymentUncheckedUpdateManyWithoutBillInput
  }

  export type BillUncheckedUpdateManyWithoutReopenBillsIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableDataId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillUpdateWithoutReopenBillsIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tableData?: TableDataUpdateOneWithoutBillsInput
    workDay?: WorkDayUpdateOneWithoutBillsInput
    orders?: OrderUpdateManyWithoutBillInput
    payments?: PaymentUpdateManyWithoutBillInput
    reopenBills?: BillUpdateManyWithoutReopenBillsIdInput
  }

  export type BillUncheckedUpdateWithoutReopenBillsIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableDataId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutBillInput
    payments?: PaymentUncheckedUpdateManyWithoutBillInput
  }

  export type BillUncheckedUpdateManyWithoutReopenBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableDataId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyEmployeeInput = {
    id?: string
    quantity: number
    orderId?: string | null
    itemId?: string | null
  }

  export type OrderPadCreateManyEmployeeInput = {
    id?: string
    block: number
    firstOrderId: number
    lastOrderId?: number | null
    used: boolean
    workDayId?: string | null
  }

  export type TableDataCreateManyWaiterInput = {
    id?: string
    totalOccupations: number
    workDayId?: string | null
    tableId?: string | null
  }

  export type WorkHourCreateManyEmployeeInput = {
    id?: string
    weekday: WeekDay
    startTime?: string | null
    endTime?: string | null
    isDayOff?: boolean | null
  }

  export type OrderItemUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    item?: ItemUpdateOneWithoutOrderItemInput
    order?: OrderUpdateOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutItemsOrderedInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderPadUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    block?: IntFieldUpdateOperationsInput | number
    firstOrderId?: IntFieldUpdateOperationsInput | number
    lastOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    used?: BoolFieldUpdateOperationsInput | boolean
    workDay?: WorkDayUpdateOneWithoutOrderPadsInput
  }

  export type OrderPadUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    block?: IntFieldUpdateOperationsInput | number
    firstOrderId?: IntFieldUpdateOperationsInput | number
    lastOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    used?: BoolFieldUpdateOperationsInput | boolean
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderPadUncheckedUpdateManyWithoutOrderPadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    block?: IntFieldUpdateOperationsInput | number
    firstOrderId?: IntFieldUpdateOperationsInput | number
    lastOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    used?: BoolFieldUpdateOperationsInput | boolean
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableDataUpdateWithoutWaiterInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    table?: TableUpdateOneWithoutDataInput
    workDay?: WorkDayUpdateOneWithoutTablesInput
    bills?: BillUpdateManyWithoutTableDataInput
  }

  export type TableDataUncheckedUpdateWithoutWaiterInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    bills?: BillUncheckedUpdateManyWithoutTableDataInput
  }

  export type TableDataUncheckedUpdateManyWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkHourUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekday?: EnumWeekDayFieldUpdateOperationsInput | WeekDay
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isDayOff?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type WorkHourUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekday?: EnumWeekDayFieldUpdateOperationsInput | WeekDay
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isDayOff?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type WorkHourUncheckedUpdateManyWithoutWorkHoursInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekday?: EnumWeekDayFieldUpdateOperationsInput | WeekDay
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    isDayOff?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ClientCreateManyEstablishmentInput = {
    id?: string
    name: string
    address: string
    complement?: string | null
    postCode: string
    telephoneNumber: string
    distanceKm: string
    distanceTime: string
  }

  export type EmployeeCreateManyEstablishmentInput = {
    id?: string
    createdAt?: Date | string
    employeeId: number
    name: string
    role: string
    admissionDate?: Date | string | null
    terminationDate?: Date | string | null
    isActive: boolean
  }

  export type ExpenseCreateManyEstablishmentInput = {
    id?: string
    createdAt?: Date | string
    NFE: boolean
    NFEReference?: string | null
    date: Date | string
    executionDate: Date | string
  }

  export type ItemCreateManyEstablishmentInput = {
    id?: string
    itemId: string
    name: string
    price: number
    priceToGo?: number | null
    employeePrice?: number | null
    category: string
    canTakeToGo?: boolean | null
    isActive: boolean
    hasTaxSubstitution?: boolean | null
    itemNCMId?: string | null
  }

  export type PermissionCreateManyEstablishmentInput = {
    id?: string
    createdAt?: Date | string
    role: UserRole
    userId?: string | null
  }

  export type TableCreateManyEstablishmentInput = {
    id?: string
    tableNumber: number
  }

  export type WorkDayCreateManyEstablishmentInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    userResponsibleId?: string | null
  }

  export type ClientUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    postCode?: StringFieldUpdateOperationsInput | string
    telephoneNumber?: StringFieldUpdateOperationsInput | string
    distanceKm?: StringFieldUpdateOperationsInput | string
    distanceTime?: StringFieldUpdateOperationsInput | string
  }

  export type ClientUncheckedUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    postCode?: StringFieldUpdateOperationsInput | string
    telephoneNumber?: StringFieldUpdateOperationsInput | string
    distanceKm?: StringFieldUpdateOperationsInput | string
    distanceTime?: StringFieldUpdateOperationsInput | string
  }

  export type ClientUncheckedUpdateManyWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    postCode?: StringFieldUpdateOperationsInput | string
    telephoneNumber?: StringFieldUpdateOperationsInput | string
    distanceKm?: StringFieldUpdateOperationsInput | string
    distanceTime?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    itemsOrdered?: OrderItemUpdateManyWithoutEmployeeInput
    orderPads?: OrderPadUpdateManyWithoutEmployeeInput
    tables?: TableDataUpdateManyWithoutWaiterInput
    workHours?: WorkHourUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    itemsOrdered?: OrderItemUncheckedUpdateManyWithoutEmployeeInput
    orderPads?: OrderPadUncheckedUpdateManyWithoutEmployeeInput
    tables?: TableDataUncheckedUpdateManyWithoutWaiterInput
    workHours?: WorkHourUncheckedUpdateManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedUpdateManyWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    admissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExpenseUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NFE?: BoolFieldUpdateOperationsInput | boolean
    NFEReference?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneWithoutExpenseInput
    expenseItems?: ExpenseItemUpdateManyWithoutExpenseInput
  }

  export type ExpenseUncheckedUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NFE?: BoolFieldUpdateOperationsInput | boolean
    NFEReference?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutExpenseInput
  }

  export type ExpenseUncheckedUpdateManyWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NFE?: BoolFieldUpdateOperationsInput | boolean
    NFEReference?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceToGo?: NullableFloatFieldUpdateOperationsInput | number | null
    employeePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    canTakeToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasTaxSubstitution?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemNCM?: NCMUpdateOneWithoutItemsInput
    orderItem?: OrderItemUpdateManyWithoutItemInput
  }

  export type ItemUncheckedUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceToGo?: NullableFloatFieldUpdateOperationsInput | number | null
    employeePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    canTakeToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasTaxSubstitution?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemNCMId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItem?: OrderItemUncheckedUpdateManyWithoutItemInput
  }

  export type ItemUncheckedUpdateManyWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceToGo?: NullableFloatFieldUpdateOperationsInput | number | null
    employeePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    canTakeToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasTaxSubstitution?: NullableBoolFieldUpdateOperationsInput | boolean | null
    itemNCMId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    user?: UserUpdateOneWithoutPermissionsInput
  }

  export type PermissionUncheckedUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateManyWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableNumber?: IntFieldUpdateOperationsInput | number
    data?: TableDataUpdateManyWithoutTableInput
  }

  export type TableUncheckedUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableNumber?: IntFieldUpdateOperationsInput | number
    data?: TableDataUncheckedUpdateManyWithoutTableInput
  }

  export type TableUncheckedUpdateManyWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableNumber?: IntFieldUpdateOperationsInput | number
  }

  export type WorkDayUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userResponsible?: UserUpdateOneWithoutResponsibleWorkDaysInput
    bills?: BillUpdateManyWithoutWorkDayInput
    incomes?: IncomeUpdateManyWithoutWorkDayInput
    orders?: OrderUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUpdateManyWithoutWorkDayInput
    tables?: TableDataUpdateManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedUpdateWithoutEstablishmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userResponsibleId?: NullableStringFieldUpdateOperationsInput | string | null
    bills?: BillUncheckedUpdateManyWithoutWorkDayInput
    incomes?: IncomeUncheckedUpdateManyWithoutWorkDayInput
    orders?: OrderUncheckedUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedUpdateManyWithoutWorkDayInput
    tables?: TableDataUncheckedUpdateManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedUpdateManyWithoutWorkingDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userResponsibleId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseItemUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: FloatFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneWithoutExpenseItemInput
  }

  export type ExpenseItemUncheckedUpdateWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: FloatFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseItemUncheckedUpdateManyWithoutExpenseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: FloatFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseUpdateWithoutExpenseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NFE?: BoolFieldUpdateOperationsInput | boolean
    NFEReference?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    establishment?: EstablishmentUpdateOneWithoutExpensesInput
    payment?: PaymentUpdateOneWithoutExpenseInput
  }

  export type ExpenseUncheckedUpdateWithoutExpenseItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NFE?: BoolFieldUpdateOperationsInput | boolean
    NFEReference?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: PaymentUncheckedUpdateOneWithoutExpenseInput
  }

  export type ExpenseUncheckedUpdateManyWithoutExpenseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NFE?: BoolFieldUpdateOperationsInput | boolean
    NFEReference?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    executionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyItemInput = {
    id?: string
    quantity: number
    orderId?: string | null
    employeeId?: string | null
  }

  export type OrderItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    employee?: EmployeeUpdateOneWithoutItemsOrderedInput
    order?: OrderUpdateOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemCreateManyItemNCMInput = {
    id?: string
    itemId: string
    name: string
    price: number
    priceToGo?: number | null
    employeePrice?: number | null
    category: string
    canTakeToGo?: boolean | null
    isActive: boolean
    hasTaxSubstitution?: boolean | null
    establishmentId?: string | null
  }

  export type ItemUpdateWithoutItemNCMInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceToGo?: NullableFloatFieldUpdateOperationsInput | number | null
    employeePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    canTakeToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasTaxSubstitution?: NullableBoolFieldUpdateOperationsInput | boolean | null
    establishment?: EstablishmentUpdateOneWithoutItemsInput
    orderItem?: OrderItemUpdateManyWithoutItemInput
  }

  export type ItemUncheckedUpdateWithoutItemNCMInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceToGo?: NullableFloatFieldUpdateOperationsInput | number | null
    employeePrice?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: StringFieldUpdateOperationsInput | string
    canTakeToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasTaxSubstitution?: NullableBoolFieldUpdateOperationsInput | boolean | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItem?: OrderItemUncheckedUpdateManyWithoutItemInput
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    quantity: number
    employeeId?: string | null
    itemId?: string | null
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    employee?: EmployeeUpdateOneWithoutItemsOrderedInput
    item?: ItemUpdateOneWithoutOrderItemInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutModifiedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    bill?: BillUpdateOneWithoutOrdersInput
    workDay?: WorkDayUpdateOneWithoutOrdersInput
    orderItems?: OrderItemUpdateManyWithoutOrderInput
    modifiedOrdersId?: OrderUpdateManyWithoutModifiedOrdersInput
  }

  export type OrderUncheckedUpdateWithoutModifiedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderInput
  }

  export type OrderUncheckedUpdateManyWithoutModifiedOrdersIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutModifiedOrdersIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    bill?: BillUpdateOneWithoutOrdersInput
    workDay?: WorkDayUpdateOneWithoutOrdersInput
    orderItems?: OrderItemUpdateManyWithoutOrderInput
    modifiedOrders?: OrderUpdateManyWithoutModifiedOrdersIdInput
  }

  export type OrderUncheckedUpdateWithoutModifiedOrdersIdInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderInput
  }

  export type OrderUncheckedUpdateManyWithoutModifiedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseItemCreateManyProductInput = {
    id?: string
    createdAt?: Date | string
    quantity: number
    value: number
    details?: string | null
  }

  export type ExpenseItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: FloatFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
    Expense?: ExpenseUpdateManyWithoutExpenseItemsInput
  }

  export type ExpenseItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: FloatFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExpenseItemUncheckedUpdateManyWithoutExpenseItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: FloatFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableDataCreateManyTableInput = {
    id?: string
    totalOccupations: number
    workDayId?: string | null
    waiterId?: string | null
  }

  export type TableDataUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    waiter?: EmployeeUpdateOneWithoutTablesInput
    workDay?: WorkDayUpdateOneWithoutTablesInput
    bills?: BillUpdateManyWithoutTableDataInput
  }

  export type TableDataUncheckedUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    waiterId?: NullableStringFieldUpdateOperationsInput | string | null
    bills?: BillUncheckedUpdateManyWithoutTableDataInput
  }

  export type TableDataUncheckedUpdateManyWithoutDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    waiterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillCreateManyTableDataInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    workDayId?: string | null
  }

  export type BillUpdateWithoutTableDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workDay?: WorkDayUpdateOneWithoutBillsInput
    orders?: OrderUpdateManyWithoutBillInput
    payments?: PaymentUpdateManyWithoutBillInput
    reopenBillsId?: BillUpdateManyWithoutReopenBillsInput
    reopenBills?: BillUpdateManyWithoutReopenBillsIdInput
  }

  export type BillUncheckedUpdateWithoutTableDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutBillInput
    payments?: PaymentUncheckedUpdateManyWithoutBillInput
  }

  export type BillUncheckedUpdateManyWithoutBillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workDayId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    role: UserRole
    establishmentId?: string | null
  }

  export type WorkDayCreateManyUserResponsibleInput = {
    id?: string
    createdAt?: Date | string
    isCurrent: boolean
    openDate: Date | string
    closeDate?: Date | string | null
    establishmentId?: string | null
  }

  export type PermissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    establishment?: EstablishmentUpdateOneWithoutPermissionsInput
  }

  export type PermissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkDayUpdateWithoutUserResponsibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishment?: EstablishmentUpdateOneWithoutWorkingDaysInput
    bills?: BillUpdateManyWithoutWorkDayInput
    incomes?: IncomeUpdateManyWithoutWorkDayInput
    orders?: OrderUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUpdateManyWithoutWorkDayInput
    tables?: TableDataUpdateManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedUpdateWithoutUserResponsibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
    bills?: BillUncheckedUpdateManyWithoutWorkDayInput
    incomes?: IncomeUncheckedUpdateManyWithoutWorkDayInput
    orders?: OrderUncheckedUpdateManyWithoutWorkDayInput
    orderPads?: OrderPadUncheckedUpdateManyWithoutWorkDayInput
    tables?: TableDataUncheckedUpdateManyWithoutWorkDayInput
  }

  export type WorkDayUncheckedUpdateManyWithoutResponsibleWorkDaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    openDate?: DateTimeFieldUpdateOperationsInput | Date | string
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    establishmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BillCreateManyWorkDayInput = {
    id?: string
    createdAt?: Date | string
    closedAt?: Date | string | null
    status: BillStatus
    discount?: number | null
    discountReason?: string | null
    value?: number | null
    valueAfterDiscount?: number | null
    wasReopen?: boolean | null
    registered?: boolean | null
    tableDataId?: string | null
  }

  export type IncomeCreateManyWorkDayInput = {
    id?: string
    createdAt?: Date | string
    reference: string
    value: number
    type?: string | null
  }

  export type OrderCreateManyWorkDayInput = {
    id?: string
    createdAt?: Date | string
    block: number
    orderId: number
    cancelled?: boolean | null
    cancelationJustification?: string | null
    wasModified?: boolean | null
    isEmployeeOrder?: boolean | null
    reuse?: boolean | null
    isToGo?: boolean | null
    toGoReference?: string | null
    billId?: string | null
  }

  export type OrderPadCreateManyWorkDayInput = {
    id?: string
    block: number
    firstOrderId: number
    lastOrderId?: number | null
    used: boolean
    employeeId?: string | null
  }

  export type TableDataCreateManyWorkDayInput = {
    id?: string
    totalOccupations: number
    tableId?: string | null
    waiterId?: string | null
  }

  export type BillUpdateWithoutWorkDayInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tableData?: TableDataUpdateOneWithoutBillsInput
    orders?: OrderUpdateManyWithoutBillInput
    payments?: PaymentUpdateManyWithoutBillInput
    reopenBillsId?: BillUpdateManyWithoutReopenBillsInput
    reopenBills?: BillUpdateManyWithoutReopenBillsIdInput
  }

  export type BillUncheckedUpdateWithoutWorkDayInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBillStatusFieldUpdateOperationsInput | BillStatus
    discount?: NullableFloatFieldUpdateOperationsInput | number | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    valueAfterDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    wasReopen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    registered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tableDataId?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutBillInput
    payments?: PaymentUncheckedUpdateManyWithoutBillInput
  }

  export type IncomeUpdateWithoutWorkDayInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncomeUncheckedUpdateWithoutWorkDayInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncomeUncheckedUpdateManyWithoutIncomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reference?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutWorkDayInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    bill?: BillUpdateOneWithoutOrdersInput
    orderItems?: OrderItemUpdateManyWithoutOrderInput
    modifiedOrdersId?: OrderUpdateManyWithoutModifiedOrdersInput
    modifiedOrders?: OrderUpdateManyWithoutModifiedOrdersIdInput
  }

  export type OrderUncheckedUpdateWithoutWorkDayInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    block?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    cancelled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cancelationJustification?: NullableStringFieldUpdateOperationsInput | string | null
    wasModified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isEmployeeOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reuse?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isToGo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    toGoReference?: NullableStringFieldUpdateOperationsInput | string | null
    billId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderInput
  }

  export type OrderPadUpdateWithoutWorkDayInput = {
    id?: StringFieldUpdateOperationsInput | string
    block?: IntFieldUpdateOperationsInput | number
    firstOrderId?: IntFieldUpdateOperationsInput | number
    lastOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    used?: BoolFieldUpdateOperationsInput | boolean
    employee?: EmployeeUpdateOneWithoutOrderPadsInput
  }

  export type OrderPadUncheckedUpdateWithoutWorkDayInput = {
    id?: StringFieldUpdateOperationsInput | string
    block?: IntFieldUpdateOperationsInput | number
    firstOrderId?: IntFieldUpdateOperationsInput | number
    lastOrderId?: NullableIntFieldUpdateOperationsInput | number | null
    used?: BoolFieldUpdateOperationsInput | boolean
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableDataUpdateWithoutWorkDayInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    table?: TableUpdateOneWithoutDataInput
    waiter?: EmployeeUpdateOneWithoutTablesInput
    bills?: BillUpdateManyWithoutTableDataInput
  }

  export type TableDataUncheckedUpdateWithoutWorkDayInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalOccupations?: IntFieldUpdateOperationsInput | number
    tableId?: NullableStringFieldUpdateOperationsInput | string | null
    waiterId?: NullableStringFieldUpdateOperationsInput | string | null
    bills?: BillUncheckedUpdateManyWithoutTableDataInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}