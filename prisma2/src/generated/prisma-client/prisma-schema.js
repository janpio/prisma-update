module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.12). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBill {
  count: Int!
}

type AggregateCheckData {
  count: Int!
}

type AggregateClient {
  count: Int!
}

type AggregateEmployee {
  count: Int!
}

type AggregateEstablishment {
  count: Int!
}

type AggregateExpense {
  count: Int!
}

type AggregateExpenseItem {
  count: Int!
}

type AggregateIncome {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregateNCM {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregateOrderItem {
  count: Int!
}

type AggregateOrderPad {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregatePermission {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateTable {
  count: Int!
}

type AggregateTableData {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateWorkDay {
  count: Int!
}

type AggregateWorkHour {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Bill {
  createdAt: DateTime!
  closedAt: DateTime
  id: ID!
  workDay: WorkDay!
  tableData: TableData!
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
  status: BillStatus!
  discount: Float
  discountReason: String
  value: Float
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
  wasReopen: Boolean
  reopenBills(where: BillWhereInput, orderBy: BillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bill!]
  registered: Boolean
}

type BillConnection {
  pageInfo: PageInfo!
  edges: [BillEdge]!
  aggregate: AggregateBill!
}

input BillCreateInput {
  closedAt: DateTime
  id: ID
  workDay: WorkDayCreateOneWithoutBillsInput!
  tableData: TableDataCreateOneWithoutBillsInput!
  orders: OrderCreateManyWithoutBillInput
  status: BillStatus!
  discount: Float
  discountReason: String
  value: Float
  payments: PaymentCreateManyWithoutBillInput
  wasReopen: Boolean
  reopenBills: BillCreateManyInput
  registered: Boolean
}

input BillCreateManyInput {
  create: [BillCreateInput!]
  connect: [BillWhereUniqueInput!]
}

input BillCreateManyWithoutTableDataInput {
  create: [BillCreateWithoutTableDataInput!]
  connect: [BillWhereUniqueInput!]
}

input BillCreateManyWithoutWorkDayInput {
  create: [BillCreateWithoutWorkDayInput!]
  connect: [BillWhereUniqueInput!]
}

input BillCreateOneWithoutOrdersInput {
  create: BillCreateWithoutOrdersInput
  connect: BillWhereUniqueInput
}

input BillCreateOneWithoutPaymentsInput {
  create: BillCreateWithoutPaymentsInput
  connect: BillWhereUniqueInput
}

input BillCreateWithoutOrdersInput {
  closedAt: DateTime
  id: ID
  workDay: WorkDayCreateOneWithoutBillsInput!
  tableData: TableDataCreateOneWithoutBillsInput!
  status: BillStatus!
  discount: Float
  discountReason: String
  value: Float
  payments: PaymentCreateManyWithoutBillInput
  wasReopen: Boolean
  reopenBills: BillCreateManyInput
  registered: Boolean
}

input BillCreateWithoutPaymentsInput {
  closedAt: DateTime
  id: ID
  workDay: WorkDayCreateOneWithoutBillsInput!
  tableData: TableDataCreateOneWithoutBillsInput!
  orders: OrderCreateManyWithoutBillInput
  status: BillStatus!
  discount: Float
  discountReason: String
  value: Float
  wasReopen: Boolean
  reopenBills: BillCreateManyInput
  registered: Boolean
}

input BillCreateWithoutTableDataInput {
  closedAt: DateTime
  id: ID
  workDay: WorkDayCreateOneWithoutBillsInput!
  orders: OrderCreateManyWithoutBillInput
  status: BillStatus!
  discount: Float
  discountReason: String
  value: Float
  payments: PaymentCreateManyWithoutBillInput
  wasReopen: Boolean
  reopenBills: BillCreateManyInput
  registered: Boolean
}

input BillCreateWithoutWorkDayInput {
  closedAt: DateTime
  id: ID
  tableData: TableDataCreateOneWithoutBillsInput!
  orders: OrderCreateManyWithoutBillInput
  status: BillStatus!
  discount: Float
  discountReason: String
  value: Float
  payments: PaymentCreateManyWithoutBillInput
  wasReopen: Boolean
  reopenBills: BillCreateManyInput
  registered: Boolean
}

type BillEdge {
  node: Bill!
  cursor: String!
}

enum BillOrderByInput {
  createdAt_ASC
  createdAt_DESC
  closedAt_ASC
  closedAt_DESC
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  discount_ASC
  discount_DESC
  discountReason_ASC
  discountReason_DESC
  value_ASC
  value_DESC
  wasReopen_ASC
  wasReopen_DESC
  registered_ASC
  registered_DESC
}

type BillPreviousValues {
  createdAt: DateTime!
  closedAt: DateTime
  id: ID!
  status: BillStatus!
  discount: Float
  discountReason: String
  value: Float
  wasReopen: Boolean
  registered: Boolean
}

input BillScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  closedAt: DateTime
  closedAt_not: DateTime
  closedAt_in: [DateTime!]
  closedAt_not_in: [DateTime!]
  closedAt_lt: DateTime
  closedAt_lte: DateTime
  closedAt_gt: DateTime
  closedAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: BillStatus
  status_not: BillStatus
  status_in: [BillStatus!]
  status_not_in: [BillStatus!]
  discount: Float
  discount_not: Float
  discount_in: [Float!]
  discount_not_in: [Float!]
  discount_lt: Float
  discount_lte: Float
  discount_gt: Float
  discount_gte: Float
  discountReason: String
  discountReason_not: String
  discountReason_in: [String!]
  discountReason_not_in: [String!]
  discountReason_lt: String
  discountReason_lte: String
  discountReason_gt: String
  discountReason_gte: String
  discountReason_contains: String
  discountReason_not_contains: String
  discountReason_starts_with: String
  discountReason_not_starts_with: String
  discountReason_ends_with: String
  discountReason_not_ends_with: String
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  wasReopen: Boolean
  wasReopen_not: Boolean
  registered: Boolean
  registered_not: Boolean
  AND: [BillScalarWhereInput!]
  OR: [BillScalarWhereInput!]
  NOT: [BillScalarWhereInput!]
}

enum BillStatus {
  PAID
  OPEN
  CLOSED
}

type BillSubscriptionPayload {
  mutation: MutationType!
  node: Bill
  updatedFields: [String!]
  previousValues: BillPreviousValues
}

input BillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BillWhereInput
  AND: [BillSubscriptionWhereInput!]
  OR: [BillSubscriptionWhereInput!]
  NOT: [BillSubscriptionWhereInput!]
}

input BillUpdateDataInput {
  closedAt: DateTime
  workDay: WorkDayUpdateOneRequiredWithoutBillsInput
  tableData: TableDataUpdateOneRequiredWithoutBillsInput
  orders: OrderUpdateManyWithoutBillInput
  status: BillStatus
  discount: Float
  discountReason: String
  value: Float
  payments: PaymentUpdateManyWithoutBillInput
  wasReopen: Boolean
  reopenBills: BillUpdateManyInput
  registered: Boolean
}

input BillUpdateInput {
  closedAt: DateTime
  workDay: WorkDayUpdateOneRequiredWithoutBillsInput
  tableData: TableDataUpdateOneRequiredWithoutBillsInput
  orders: OrderUpdateManyWithoutBillInput
  status: BillStatus
  discount: Float
  discountReason: String
  value: Float
  payments: PaymentUpdateManyWithoutBillInput
  wasReopen: Boolean
  reopenBills: BillUpdateManyInput
  registered: Boolean
}

input BillUpdateManyDataInput {
  closedAt: DateTime
  status: BillStatus
  discount: Float
  discountReason: String
  value: Float
  wasReopen: Boolean
  registered: Boolean
}

input BillUpdateManyInput {
  create: [BillCreateInput!]
  update: [BillUpdateWithWhereUniqueNestedInput!]
  upsert: [BillUpsertWithWhereUniqueNestedInput!]
  delete: [BillWhereUniqueInput!]
  connect: [BillWhereUniqueInput!]
  set: [BillWhereUniqueInput!]
  disconnect: [BillWhereUniqueInput!]
  deleteMany: [BillScalarWhereInput!]
  updateMany: [BillUpdateManyWithWhereNestedInput!]
}

input BillUpdateManyMutationInput {
  closedAt: DateTime
  status: BillStatus
  discount: Float
  discountReason: String
  value: Float
  wasReopen: Boolean
  registered: Boolean
}

input BillUpdateManyWithoutTableDataInput {
  create: [BillCreateWithoutTableDataInput!]
  delete: [BillWhereUniqueInput!]
  connect: [BillWhereUniqueInput!]
  set: [BillWhereUniqueInput!]
  disconnect: [BillWhereUniqueInput!]
  update: [BillUpdateWithWhereUniqueWithoutTableDataInput!]
  upsert: [BillUpsertWithWhereUniqueWithoutTableDataInput!]
  deleteMany: [BillScalarWhereInput!]
  updateMany: [BillUpdateManyWithWhereNestedInput!]
}

input BillUpdateManyWithoutWorkDayInput {
  create: [BillCreateWithoutWorkDayInput!]
  delete: [BillWhereUniqueInput!]
  connect: [BillWhereUniqueInput!]
  set: [BillWhereUniqueInput!]
  disconnect: [BillWhereUniqueInput!]
  update: [BillUpdateWithWhereUniqueWithoutWorkDayInput!]
  upsert: [BillUpsertWithWhereUniqueWithoutWorkDayInput!]
  deleteMany: [BillScalarWhereInput!]
  updateMany: [BillUpdateManyWithWhereNestedInput!]
}

input BillUpdateManyWithWhereNestedInput {
  where: BillScalarWhereInput!
  data: BillUpdateManyDataInput!
}

input BillUpdateOneWithoutOrdersInput {
  create: BillCreateWithoutOrdersInput
  update: BillUpdateWithoutOrdersDataInput
  upsert: BillUpsertWithoutOrdersInput
  delete: Boolean
  disconnect: Boolean
  connect: BillWhereUniqueInput
}

input BillUpdateOneWithoutPaymentsInput {
  create: BillCreateWithoutPaymentsInput
  update: BillUpdateWithoutPaymentsDataInput
  upsert: BillUpsertWithoutPaymentsInput
  delete: Boolean
  disconnect: Boolean
  connect: BillWhereUniqueInput
}

input BillUpdateWithoutOrdersDataInput {
  closedAt: DateTime
  workDay: WorkDayUpdateOneRequiredWithoutBillsInput
  tableData: TableDataUpdateOneRequiredWithoutBillsInput
  status: BillStatus
  discount: Float
  discountReason: String
  value: Float
  payments: PaymentUpdateManyWithoutBillInput
  wasReopen: Boolean
  reopenBills: BillUpdateManyInput
  registered: Boolean
}

input BillUpdateWithoutPaymentsDataInput {
  closedAt: DateTime
  workDay: WorkDayUpdateOneRequiredWithoutBillsInput
  tableData: TableDataUpdateOneRequiredWithoutBillsInput
  orders: OrderUpdateManyWithoutBillInput
  status: BillStatus
  discount: Float
  discountReason: String
  value: Float
  wasReopen: Boolean
  reopenBills: BillUpdateManyInput
  registered: Boolean
}

input BillUpdateWithoutTableDataDataInput {
  closedAt: DateTime
  workDay: WorkDayUpdateOneRequiredWithoutBillsInput
  orders: OrderUpdateManyWithoutBillInput
  status: BillStatus
  discount: Float
  discountReason: String
  value: Float
  payments: PaymentUpdateManyWithoutBillInput
  wasReopen: Boolean
  reopenBills: BillUpdateManyInput
  registered: Boolean
}

input BillUpdateWithoutWorkDayDataInput {
  closedAt: DateTime
  tableData: TableDataUpdateOneRequiredWithoutBillsInput
  orders: OrderUpdateManyWithoutBillInput
  status: BillStatus
  discount: Float
  discountReason: String
  value: Float
  payments: PaymentUpdateManyWithoutBillInput
  wasReopen: Boolean
  reopenBills: BillUpdateManyInput
  registered: Boolean
}

input BillUpdateWithWhereUniqueNestedInput {
  where: BillWhereUniqueInput!
  data: BillUpdateDataInput!
}

input BillUpdateWithWhereUniqueWithoutTableDataInput {
  where: BillWhereUniqueInput!
  data: BillUpdateWithoutTableDataDataInput!
}

input BillUpdateWithWhereUniqueWithoutWorkDayInput {
  where: BillWhereUniqueInput!
  data: BillUpdateWithoutWorkDayDataInput!
}

input BillUpsertWithoutOrdersInput {
  update: BillUpdateWithoutOrdersDataInput!
  create: BillCreateWithoutOrdersInput!
}

input BillUpsertWithoutPaymentsInput {
  update: BillUpdateWithoutPaymentsDataInput!
  create: BillCreateWithoutPaymentsInput!
}

input BillUpsertWithWhereUniqueNestedInput {
  where: BillWhereUniqueInput!
  update: BillUpdateDataInput!
  create: BillCreateInput!
}

input BillUpsertWithWhereUniqueWithoutTableDataInput {
  where: BillWhereUniqueInput!
  update: BillUpdateWithoutTableDataDataInput!
  create: BillCreateWithoutTableDataInput!
}

input BillUpsertWithWhereUniqueWithoutWorkDayInput {
  where: BillWhereUniqueInput!
  update: BillUpdateWithoutWorkDayDataInput!
  create: BillCreateWithoutWorkDayInput!
}

input BillWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  closedAt: DateTime
  closedAt_not: DateTime
  closedAt_in: [DateTime!]
  closedAt_not_in: [DateTime!]
  closedAt_lt: DateTime
  closedAt_lte: DateTime
  closedAt_gt: DateTime
  closedAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  workDay: WorkDayWhereInput
  tableData: TableDataWhereInput
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  status: BillStatus
  status_not: BillStatus
  status_in: [BillStatus!]
  status_not_in: [BillStatus!]
  discount: Float
  discount_not: Float
  discount_in: [Float!]
  discount_not_in: [Float!]
  discount_lt: Float
  discount_lte: Float
  discount_gt: Float
  discount_gte: Float
  discountReason: String
  discountReason_not: String
  discountReason_in: [String!]
  discountReason_not_in: [String!]
  discountReason_lt: String
  discountReason_lte: String
  discountReason_gt: String
  discountReason_gte: String
  discountReason_contains: String
  discountReason_not_contains: String
  discountReason_starts_with: String
  discountReason_not_starts_with: String
  discountReason_ends_with: String
  discountReason_not_ends_with: String
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  wasReopen: Boolean
  wasReopen_not: Boolean
  reopenBills_every: BillWhereInput
  reopenBills_some: BillWhereInput
  reopenBills_none: BillWhereInput
  registered: Boolean
  registered_not: Boolean
  AND: [BillWhereInput!]
  OR: [BillWhereInput!]
  NOT: [BillWhereInput!]
}

input BillWhereUniqueInput {
  id: ID
}

type CheckData {
  id: ID!
  payment: Payment!
  checkbookId: String
  compensationNumber: Int
  bankNumber: Int
}

type CheckDataConnection {
  pageInfo: PageInfo!
  edges: [CheckDataEdge]!
  aggregate: AggregateCheckData!
}

input CheckDataCreateInput {
  id: ID
  payment: PaymentCreateOneWithoutCheckDataInput!
  checkbookId: String
  compensationNumber: Int
  bankNumber: Int
}

input CheckDataCreateOneWithoutPaymentInput {
  create: CheckDataCreateWithoutPaymentInput
  connect: CheckDataWhereUniqueInput
}

input CheckDataCreateWithoutPaymentInput {
  id: ID
  checkbookId: String
  compensationNumber: Int
  bankNumber: Int
}

type CheckDataEdge {
  node: CheckData!
  cursor: String!
}

enum CheckDataOrderByInput {
  id_ASC
  id_DESC
  checkbookId_ASC
  checkbookId_DESC
  compensationNumber_ASC
  compensationNumber_DESC
  bankNumber_ASC
  bankNumber_DESC
}

type CheckDataPreviousValues {
  id: ID!
  checkbookId: String
  compensationNumber: Int
  bankNumber: Int
}

type CheckDataSubscriptionPayload {
  mutation: MutationType!
  node: CheckData
  updatedFields: [String!]
  previousValues: CheckDataPreviousValues
}

input CheckDataSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CheckDataWhereInput
  AND: [CheckDataSubscriptionWhereInput!]
  OR: [CheckDataSubscriptionWhereInput!]
  NOT: [CheckDataSubscriptionWhereInput!]
}

input CheckDataUpdateInput {
  payment: PaymentUpdateOneRequiredWithoutCheckDataInput
  checkbookId: String
  compensationNumber: Int
  bankNumber: Int
}

input CheckDataUpdateManyMutationInput {
  checkbookId: String
  compensationNumber: Int
  bankNumber: Int
}

input CheckDataUpdateOneWithoutPaymentInput {
  create: CheckDataCreateWithoutPaymentInput
  update: CheckDataUpdateWithoutPaymentDataInput
  upsert: CheckDataUpsertWithoutPaymentInput
  delete: Boolean
  disconnect: Boolean
  connect: CheckDataWhereUniqueInput
}

input CheckDataUpdateWithoutPaymentDataInput {
  checkbookId: String
  compensationNumber: Int
  bankNumber: Int
}

input CheckDataUpsertWithoutPaymentInput {
  update: CheckDataUpdateWithoutPaymentDataInput!
  create: CheckDataCreateWithoutPaymentInput!
}

input CheckDataWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  payment: PaymentWhereInput
  checkbookId: String
  checkbookId_not: String
  checkbookId_in: [String!]
  checkbookId_not_in: [String!]
  checkbookId_lt: String
  checkbookId_lte: String
  checkbookId_gt: String
  checkbookId_gte: String
  checkbookId_contains: String
  checkbookId_not_contains: String
  checkbookId_starts_with: String
  checkbookId_not_starts_with: String
  checkbookId_ends_with: String
  checkbookId_not_ends_with: String
  compensationNumber: Int
  compensationNumber_not: Int
  compensationNumber_in: [Int!]
  compensationNumber_not_in: [Int!]
  compensationNumber_lt: Int
  compensationNumber_lte: Int
  compensationNumber_gt: Int
  compensationNumber_gte: Int
  bankNumber: Int
  bankNumber_not: Int
  bankNumber_in: [Int!]
  bankNumber_not_in: [Int!]
  bankNumber_lt: Int
  bankNumber_lte: Int
  bankNumber_gt: Int
  bankNumber_gte: Int
  AND: [CheckDataWhereInput!]
  OR: [CheckDataWhereInput!]
  NOT: [CheckDataWhereInput!]
}

input CheckDataWhereUniqueInput {
  id: ID
}

type Client {
  id: ID!
  name: String!
  address: String!
  complement: String
  postCode: String!
  telephoneNumber: String!
  establishment: Establishment!
  distanceKm: String!
  distanceTime: String!
}

type ClientConnection {
  pageInfo: PageInfo!
  edges: [ClientEdge]!
  aggregate: AggregateClient!
}

input ClientCreateInput {
  id: ID
  name: String!
  address: String!
  complement: String
  postCode: String!
  telephoneNumber: String!
  establishment: EstablishmentCreateOneWithoutClientsInput!
  distanceKm: String!
  distanceTime: String!
}

input ClientCreateManyWithoutEstablishmentInput {
  create: [ClientCreateWithoutEstablishmentInput!]
  connect: [ClientWhereUniqueInput!]
}

input ClientCreateWithoutEstablishmentInput {
  id: ID
  name: String!
  address: String!
  complement: String
  postCode: String!
  telephoneNumber: String!
  distanceKm: String!
  distanceTime: String!
}

type ClientEdge {
  node: Client!
  cursor: String!
}

enum ClientOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  address_ASC
  address_DESC
  complement_ASC
  complement_DESC
  postCode_ASC
  postCode_DESC
  telephoneNumber_ASC
  telephoneNumber_DESC
  distanceKm_ASC
  distanceKm_DESC
  distanceTime_ASC
  distanceTime_DESC
}

type ClientPreviousValues {
  id: ID!
  name: String!
  address: String!
  complement: String
  postCode: String!
  telephoneNumber: String!
  distanceKm: String!
  distanceTime: String!
}

input ClientScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  complement: String
  complement_not: String
  complement_in: [String!]
  complement_not_in: [String!]
  complement_lt: String
  complement_lte: String
  complement_gt: String
  complement_gte: String
  complement_contains: String
  complement_not_contains: String
  complement_starts_with: String
  complement_not_starts_with: String
  complement_ends_with: String
  complement_not_ends_with: String
  postCode: String
  postCode_not: String
  postCode_in: [String!]
  postCode_not_in: [String!]
  postCode_lt: String
  postCode_lte: String
  postCode_gt: String
  postCode_gte: String
  postCode_contains: String
  postCode_not_contains: String
  postCode_starts_with: String
  postCode_not_starts_with: String
  postCode_ends_with: String
  postCode_not_ends_with: String
  telephoneNumber: String
  telephoneNumber_not: String
  telephoneNumber_in: [String!]
  telephoneNumber_not_in: [String!]
  telephoneNumber_lt: String
  telephoneNumber_lte: String
  telephoneNumber_gt: String
  telephoneNumber_gte: String
  telephoneNumber_contains: String
  telephoneNumber_not_contains: String
  telephoneNumber_starts_with: String
  telephoneNumber_not_starts_with: String
  telephoneNumber_ends_with: String
  telephoneNumber_not_ends_with: String
  distanceKm: String
  distanceKm_not: String
  distanceKm_in: [String!]
  distanceKm_not_in: [String!]
  distanceKm_lt: String
  distanceKm_lte: String
  distanceKm_gt: String
  distanceKm_gte: String
  distanceKm_contains: String
  distanceKm_not_contains: String
  distanceKm_starts_with: String
  distanceKm_not_starts_with: String
  distanceKm_ends_with: String
  distanceKm_not_ends_with: String
  distanceTime: String
  distanceTime_not: String
  distanceTime_in: [String!]
  distanceTime_not_in: [String!]
  distanceTime_lt: String
  distanceTime_lte: String
  distanceTime_gt: String
  distanceTime_gte: String
  distanceTime_contains: String
  distanceTime_not_contains: String
  distanceTime_starts_with: String
  distanceTime_not_starts_with: String
  distanceTime_ends_with: String
  distanceTime_not_ends_with: String
  AND: [ClientScalarWhereInput!]
  OR: [ClientScalarWhereInput!]
  NOT: [ClientScalarWhereInput!]
}

type ClientSubscriptionPayload {
  mutation: MutationType!
  node: Client
  updatedFields: [String!]
  previousValues: ClientPreviousValues
}

input ClientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClientWhereInput
  AND: [ClientSubscriptionWhereInput!]
  OR: [ClientSubscriptionWhereInput!]
  NOT: [ClientSubscriptionWhereInput!]
}

input ClientUpdateInput {
  name: String
  address: String
  complement: String
  postCode: String
  telephoneNumber: String
  establishment: EstablishmentUpdateOneRequiredWithoutClientsInput
  distanceKm: String
  distanceTime: String
}

input ClientUpdateManyDataInput {
  name: String
  address: String
  complement: String
  postCode: String
  telephoneNumber: String
  distanceKm: String
  distanceTime: String
}

input ClientUpdateManyMutationInput {
  name: String
  address: String
  complement: String
  postCode: String
  telephoneNumber: String
  distanceKm: String
  distanceTime: String
}

input ClientUpdateManyWithoutEstablishmentInput {
  create: [ClientCreateWithoutEstablishmentInput!]
  delete: [ClientWhereUniqueInput!]
  connect: [ClientWhereUniqueInput!]
  set: [ClientWhereUniqueInput!]
  disconnect: [ClientWhereUniqueInput!]
  update: [ClientUpdateWithWhereUniqueWithoutEstablishmentInput!]
  upsert: [ClientUpsertWithWhereUniqueWithoutEstablishmentInput!]
  deleteMany: [ClientScalarWhereInput!]
  updateMany: [ClientUpdateManyWithWhereNestedInput!]
}

input ClientUpdateManyWithWhereNestedInput {
  where: ClientScalarWhereInput!
  data: ClientUpdateManyDataInput!
}

input ClientUpdateWithoutEstablishmentDataInput {
  name: String
  address: String
  complement: String
  postCode: String
  telephoneNumber: String
  distanceKm: String
  distanceTime: String
}

input ClientUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: ClientWhereUniqueInput!
  data: ClientUpdateWithoutEstablishmentDataInput!
}

input ClientUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: ClientWhereUniqueInput!
  update: ClientUpdateWithoutEstablishmentDataInput!
  create: ClientCreateWithoutEstablishmentInput!
}

input ClientWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  complement: String
  complement_not: String
  complement_in: [String!]
  complement_not_in: [String!]
  complement_lt: String
  complement_lte: String
  complement_gt: String
  complement_gte: String
  complement_contains: String
  complement_not_contains: String
  complement_starts_with: String
  complement_not_starts_with: String
  complement_ends_with: String
  complement_not_ends_with: String
  postCode: String
  postCode_not: String
  postCode_in: [String!]
  postCode_not_in: [String!]
  postCode_lt: String
  postCode_lte: String
  postCode_gt: String
  postCode_gte: String
  postCode_contains: String
  postCode_not_contains: String
  postCode_starts_with: String
  postCode_not_starts_with: String
  postCode_ends_with: String
  postCode_not_ends_with: String
  telephoneNumber: String
  telephoneNumber_not: String
  telephoneNumber_in: [String!]
  telephoneNumber_not_in: [String!]
  telephoneNumber_lt: String
  telephoneNumber_lte: String
  telephoneNumber_gt: String
  telephoneNumber_gte: String
  telephoneNumber_contains: String
  telephoneNumber_not_contains: String
  telephoneNumber_starts_with: String
  telephoneNumber_not_starts_with: String
  telephoneNumber_ends_with: String
  telephoneNumber_not_ends_with: String
  establishment: EstablishmentWhereInput
  distanceKm: String
  distanceKm_not: String
  distanceKm_in: [String!]
  distanceKm_not_in: [String!]
  distanceKm_lt: String
  distanceKm_lte: String
  distanceKm_gt: String
  distanceKm_gte: String
  distanceKm_contains: String
  distanceKm_not_contains: String
  distanceKm_starts_with: String
  distanceKm_not_starts_with: String
  distanceKm_ends_with: String
  distanceKm_not_ends_with: String
  distanceTime: String
  distanceTime_not: String
  distanceTime_in: [String!]
  distanceTime_not_in: [String!]
  distanceTime_lt: String
  distanceTime_lte: String
  distanceTime_gt: String
  distanceTime_gte: String
  distanceTime_contains: String
  distanceTime_not_contains: String
  distanceTime_starts_with: String
  distanceTime_not_starts_with: String
  distanceTime_ends_with: String
  distanceTime_not_ends_with: String
  AND: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  NOT: [ClientWhereInput!]
}

input ClientWhereUniqueInput {
  id: ID
  telephoneNumber: String
}

scalar DateTime

type Employee {
  createdAt: DateTime!
  id: ID!
  establishment: Establishment!
  employeeId: Int!
  name: String!
  role: String!
  tables(where: TableDataWhereInput, orderBy: TableDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TableData!]
  orderPads(where: OrderPadWhereInput, orderBy: OrderPadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderPad!]
  itemsOrdered(where: OrderItemWhereInput, orderBy: OrderItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderItem!]
  workHours(where: WorkHourWhereInput, orderBy: WorkHourOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkHour!]
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean!
}

type EmployeeConnection {
  pageInfo: PageInfo!
  edges: [EmployeeEdge]!
  aggregate: AggregateEmployee!
}

input EmployeeCreateInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutEmployeesInput!
  employeeId: Int!
  name: String!
  role: String!
  tables: TableDataCreateManyWithoutWaiterInput
  orderPads: OrderPadCreateManyWithoutEmployeeInput
  itemsOrdered: OrderItemCreateManyWithoutEmployeeInput
  workHours: WorkHourCreateManyWithoutEmployeeInput
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean!
}

input EmployeeCreateManyWithoutEstablishmentInput {
  create: [EmployeeCreateWithoutEstablishmentInput!]
  connect: [EmployeeWhereUniqueInput!]
}

input EmployeeCreateOneWithoutItemsOrderedInput {
  create: EmployeeCreateWithoutItemsOrderedInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateOneWithoutOrderPadsInput {
  create: EmployeeCreateWithoutOrderPadsInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateOneWithoutTablesInput {
  create: EmployeeCreateWithoutTablesInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateOneWithoutWorkHoursInput {
  create: EmployeeCreateWithoutWorkHoursInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeCreateWithoutEstablishmentInput {
  id: ID
  employeeId: Int!
  name: String!
  role: String!
  tables: TableDataCreateManyWithoutWaiterInput
  orderPads: OrderPadCreateManyWithoutEmployeeInput
  itemsOrdered: OrderItemCreateManyWithoutEmployeeInput
  workHours: WorkHourCreateManyWithoutEmployeeInput
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean!
}

input EmployeeCreateWithoutItemsOrderedInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutEmployeesInput!
  employeeId: Int!
  name: String!
  role: String!
  tables: TableDataCreateManyWithoutWaiterInput
  orderPads: OrderPadCreateManyWithoutEmployeeInput
  workHours: WorkHourCreateManyWithoutEmployeeInput
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean!
}

input EmployeeCreateWithoutOrderPadsInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutEmployeesInput!
  employeeId: Int!
  name: String!
  role: String!
  tables: TableDataCreateManyWithoutWaiterInput
  itemsOrdered: OrderItemCreateManyWithoutEmployeeInput
  workHours: WorkHourCreateManyWithoutEmployeeInput
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean!
}

input EmployeeCreateWithoutTablesInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutEmployeesInput!
  employeeId: Int!
  name: String!
  role: String!
  orderPads: OrderPadCreateManyWithoutEmployeeInput
  itemsOrdered: OrderItemCreateManyWithoutEmployeeInput
  workHours: WorkHourCreateManyWithoutEmployeeInput
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean!
}

input EmployeeCreateWithoutWorkHoursInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutEmployeesInput!
  employeeId: Int!
  name: String!
  role: String!
  tables: TableDataCreateManyWithoutWaiterInput
  orderPads: OrderPadCreateManyWithoutEmployeeInput
  itemsOrdered: OrderItemCreateManyWithoutEmployeeInput
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean!
}

type EmployeeEdge {
  node: Employee!
  cursor: String!
}

enum EmployeeOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  employeeId_ASC
  employeeId_DESC
  name_ASC
  name_DESC
  role_ASC
  role_DESC
  admissionDate_ASC
  admissionDate_DESC
  terminationDate_ASC
  terminationDate_DESC
  isActive_ASC
  isActive_DESC
}

type EmployeePreviousValues {
  createdAt: DateTime!
  id: ID!
  employeeId: Int!
  name: String!
  role: String!
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean!
}

input EmployeeScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  employeeId: Int
  employeeId_not: Int
  employeeId_in: [Int!]
  employeeId_not_in: [Int!]
  employeeId_lt: Int
  employeeId_lte: Int
  employeeId_gt: Int
  employeeId_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  role: String
  role_not: String
  role_in: [String!]
  role_not_in: [String!]
  role_lt: String
  role_lte: String
  role_gt: String
  role_gte: String
  role_contains: String
  role_not_contains: String
  role_starts_with: String
  role_not_starts_with: String
  role_ends_with: String
  role_not_ends_with: String
  admissionDate: DateTime
  admissionDate_not: DateTime
  admissionDate_in: [DateTime!]
  admissionDate_not_in: [DateTime!]
  admissionDate_lt: DateTime
  admissionDate_lte: DateTime
  admissionDate_gt: DateTime
  admissionDate_gte: DateTime
  terminationDate: DateTime
  terminationDate_not: DateTime
  terminationDate_in: [DateTime!]
  terminationDate_not_in: [DateTime!]
  terminationDate_lt: DateTime
  terminationDate_lte: DateTime
  terminationDate_gt: DateTime
  terminationDate_gte: DateTime
  isActive: Boolean
  isActive_not: Boolean
  AND: [EmployeeScalarWhereInput!]
  OR: [EmployeeScalarWhereInput!]
  NOT: [EmployeeScalarWhereInput!]
}

type EmployeeSubscriptionPayload {
  mutation: MutationType!
  node: Employee
  updatedFields: [String!]
  previousValues: EmployeePreviousValues
}

input EmployeeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmployeeWhereInput
  AND: [EmployeeSubscriptionWhereInput!]
  OR: [EmployeeSubscriptionWhereInput!]
  NOT: [EmployeeSubscriptionWhereInput!]
}

input EmployeeUpdateInput {
  establishment: EstablishmentUpdateOneRequiredWithoutEmployeesInput
  employeeId: Int
  name: String
  role: String
  tables: TableDataUpdateManyWithoutWaiterInput
  orderPads: OrderPadUpdateManyWithoutEmployeeInput
  itemsOrdered: OrderItemUpdateManyWithoutEmployeeInput
  workHours: WorkHourUpdateManyWithoutEmployeeInput
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean
}

input EmployeeUpdateManyDataInput {
  employeeId: Int
  name: String
  role: String
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean
}

input EmployeeUpdateManyMutationInput {
  employeeId: Int
  name: String
  role: String
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean
}

input EmployeeUpdateManyWithoutEstablishmentInput {
  create: [EmployeeCreateWithoutEstablishmentInput!]
  delete: [EmployeeWhereUniqueInput!]
  connect: [EmployeeWhereUniqueInput!]
  set: [EmployeeWhereUniqueInput!]
  disconnect: [EmployeeWhereUniqueInput!]
  update: [EmployeeUpdateWithWhereUniqueWithoutEstablishmentInput!]
  upsert: [EmployeeUpsertWithWhereUniqueWithoutEstablishmentInput!]
  deleteMany: [EmployeeScalarWhereInput!]
  updateMany: [EmployeeUpdateManyWithWhereNestedInput!]
}

input EmployeeUpdateManyWithWhereNestedInput {
  where: EmployeeScalarWhereInput!
  data: EmployeeUpdateManyDataInput!
}

input EmployeeUpdateOneRequiredWithoutWorkHoursInput {
  create: EmployeeCreateWithoutWorkHoursInput
  update: EmployeeUpdateWithoutWorkHoursDataInput
  upsert: EmployeeUpsertWithoutWorkHoursInput
  connect: EmployeeWhereUniqueInput
}

input EmployeeUpdateOneWithoutItemsOrderedInput {
  create: EmployeeCreateWithoutItemsOrderedInput
  update: EmployeeUpdateWithoutItemsOrderedDataInput
  upsert: EmployeeUpsertWithoutItemsOrderedInput
  delete: Boolean
  disconnect: Boolean
  connect: EmployeeWhereUniqueInput
}

input EmployeeUpdateOneWithoutOrderPadsInput {
  create: EmployeeCreateWithoutOrderPadsInput
  update: EmployeeUpdateWithoutOrderPadsDataInput
  upsert: EmployeeUpsertWithoutOrderPadsInput
  delete: Boolean
  disconnect: Boolean
  connect: EmployeeWhereUniqueInput
}

input EmployeeUpdateOneWithoutTablesInput {
  create: EmployeeCreateWithoutTablesInput
  update: EmployeeUpdateWithoutTablesDataInput
  upsert: EmployeeUpsertWithoutTablesInput
  delete: Boolean
  disconnect: Boolean
  connect: EmployeeWhereUniqueInput
}

input EmployeeUpdateWithoutEstablishmentDataInput {
  employeeId: Int
  name: String
  role: String
  tables: TableDataUpdateManyWithoutWaiterInput
  orderPads: OrderPadUpdateManyWithoutEmployeeInput
  itemsOrdered: OrderItemUpdateManyWithoutEmployeeInput
  workHours: WorkHourUpdateManyWithoutEmployeeInput
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean
}

input EmployeeUpdateWithoutItemsOrderedDataInput {
  establishment: EstablishmentUpdateOneRequiredWithoutEmployeesInput
  employeeId: Int
  name: String
  role: String
  tables: TableDataUpdateManyWithoutWaiterInput
  orderPads: OrderPadUpdateManyWithoutEmployeeInput
  workHours: WorkHourUpdateManyWithoutEmployeeInput
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean
}

input EmployeeUpdateWithoutOrderPadsDataInput {
  establishment: EstablishmentUpdateOneRequiredWithoutEmployeesInput
  employeeId: Int
  name: String
  role: String
  tables: TableDataUpdateManyWithoutWaiterInput
  itemsOrdered: OrderItemUpdateManyWithoutEmployeeInput
  workHours: WorkHourUpdateManyWithoutEmployeeInput
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean
}

input EmployeeUpdateWithoutTablesDataInput {
  establishment: EstablishmentUpdateOneRequiredWithoutEmployeesInput
  employeeId: Int
  name: String
  role: String
  orderPads: OrderPadUpdateManyWithoutEmployeeInput
  itemsOrdered: OrderItemUpdateManyWithoutEmployeeInput
  workHours: WorkHourUpdateManyWithoutEmployeeInput
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean
}

input EmployeeUpdateWithoutWorkHoursDataInput {
  establishment: EstablishmentUpdateOneRequiredWithoutEmployeesInput
  employeeId: Int
  name: String
  role: String
  tables: TableDataUpdateManyWithoutWaiterInput
  orderPads: OrderPadUpdateManyWithoutEmployeeInput
  itemsOrdered: OrderItemUpdateManyWithoutEmployeeInput
  admissionDate: DateTime
  terminationDate: DateTime
  isActive: Boolean
}

input EmployeeUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: EmployeeWhereUniqueInput!
  data: EmployeeUpdateWithoutEstablishmentDataInput!
}

input EmployeeUpsertWithoutItemsOrderedInput {
  update: EmployeeUpdateWithoutItemsOrderedDataInput!
  create: EmployeeCreateWithoutItemsOrderedInput!
}

input EmployeeUpsertWithoutOrderPadsInput {
  update: EmployeeUpdateWithoutOrderPadsDataInput!
  create: EmployeeCreateWithoutOrderPadsInput!
}

input EmployeeUpsertWithoutTablesInput {
  update: EmployeeUpdateWithoutTablesDataInput!
  create: EmployeeCreateWithoutTablesInput!
}

input EmployeeUpsertWithoutWorkHoursInput {
  update: EmployeeUpdateWithoutWorkHoursDataInput!
  create: EmployeeCreateWithoutWorkHoursInput!
}

input EmployeeUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: EmployeeWhereUniqueInput!
  update: EmployeeUpdateWithoutEstablishmentDataInput!
  create: EmployeeCreateWithoutEstablishmentInput!
}

input EmployeeWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  establishment: EstablishmentWhereInput
  employeeId: Int
  employeeId_not: Int
  employeeId_in: [Int!]
  employeeId_not_in: [Int!]
  employeeId_lt: Int
  employeeId_lte: Int
  employeeId_gt: Int
  employeeId_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  role: String
  role_not: String
  role_in: [String!]
  role_not_in: [String!]
  role_lt: String
  role_lte: String
  role_gt: String
  role_gte: String
  role_contains: String
  role_not_contains: String
  role_starts_with: String
  role_not_starts_with: String
  role_ends_with: String
  role_not_ends_with: String
  tables_every: TableDataWhereInput
  tables_some: TableDataWhereInput
  tables_none: TableDataWhereInput
  orderPads_every: OrderPadWhereInput
  orderPads_some: OrderPadWhereInput
  orderPads_none: OrderPadWhereInput
  itemsOrdered_every: OrderItemWhereInput
  itemsOrdered_some: OrderItemWhereInput
  itemsOrdered_none: OrderItemWhereInput
  workHours_every: WorkHourWhereInput
  workHours_some: WorkHourWhereInput
  workHours_none: WorkHourWhereInput
  admissionDate: DateTime
  admissionDate_not: DateTime
  admissionDate_in: [DateTime!]
  admissionDate_not_in: [DateTime!]
  admissionDate_lt: DateTime
  admissionDate_lte: DateTime
  admissionDate_gt: DateTime
  admissionDate_gte: DateTime
  terminationDate: DateTime
  terminationDate_not: DateTime
  terminationDate_in: [DateTime!]
  terminationDate_not_in: [DateTime!]
  terminationDate_lt: DateTime
  terminationDate_lte: DateTime
  terminationDate_gt: DateTime
  terminationDate_gte: DateTime
  isActive: Boolean
  isActive_not: Boolean
  AND: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  NOT: [EmployeeWhereInput!]
}

input EmployeeWhereUniqueInput {
  id: ID
  employeeId: Int
}

type Establishment {
  createdAt: DateTime!
  id: ID!
  name: String!
  lat: Float!
  long: Float!
  restaurantId: String!
  valueInCashRegister: Float!
  maximumInCashRegister: Float!
  incomeMaxReference: Int!
  isOpen: Boolean!
  workingDays(where: WorkDayWhereInput, orderBy: WorkDayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkDay!]
  permissions(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Permission!]
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  employees(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Employee!]
  tables(where: TableWhereInput, orderBy: TableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Table!]
  expenses(where: ExpenseWhereInput, orderBy: ExpenseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Expense!]
  discountReasons: [String!]!
  totalInvoices: Int
  clients(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Client!]
}

type EstablishmentConnection {
  pageInfo: PageInfo!
  edges: [EstablishmentEdge]!
  aggregate: AggregateEstablishment!
}

input EstablishmentCreatediscountReasonsInput {
  set: [String!]
}

input EstablishmentCreateInput {
  id: ID
  name: String!
  lat: Float
  long: Float
  restaurantId: String!
  valueInCashRegister: Float!
  maximumInCashRegister: Float!
  incomeMaxReference: Int!
  isOpen: Boolean!
  workingDays: WorkDayCreateManyWithoutEstablishmentInput
  permissions: PermissionCreateManyWithoutEstablishmentInput
  items: ItemCreateManyWithoutEstablishmentInput
  employees: EmployeeCreateManyWithoutEstablishmentInput
  tables: TableCreateManyWithoutEstablishmentInput
  expenses: ExpenseCreateManyWithoutEstablishmentInput
  discountReasons: EstablishmentCreatediscountReasonsInput
  totalInvoices: Int
  clients: ClientCreateManyWithoutEstablishmentInput
}

input EstablishmentCreateOneWithoutClientsInput {
  create: EstablishmentCreateWithoutClientsInput
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentCreateOneWithoutEmployeesInput {
  create: EstablishmentCreateWithoutEmployeesInput
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentCreateOneWithoutExpensesInput {
  create: EstablishmentCreateWithoutExpensesInput
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentCreateOneWithoutItemsInput {
  create: EstablishmentCreateWithoutItemsInput
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentCreateOneWithoutPermissionsInput {
  create: EstablishmentCreateWithoutPermissionsInput
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentCreateOneWithoutTablesInput {
  create: EstablishmentCreateWithoutTablesInput
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentCreateOneWithoutWorkingDaysInput {
  create: EstablishmentCreateWithoutWorkingDaysInput
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentCreateWithoutClientsInput {
  id: ID
  name: String!
  lat: Float
  long: Float
  restaurantId: String!
  valueInCashRegister: Float!
  maximumInCashRegister: Float!
  incomeMaxReference: Int!
  isOpen: Boolean!
  workingDays: WorkDayCreateManyWithoutEstablishmentInput
  permissions: PermissionCreateManyWithoutEstablishmentInput
  items: ItemCreateManyWithoutEstablishmentInput
  employees: EmployeeCreateManyWithoutEstablishmentInput
  tables: TableCreateManyWithoutEstablishmentInput
  expenses: ExpenseCreateManyWithoutEstablishmentInput
  discountReasons: EstablishmentCreatediscountReasonsInput
  totalInvoices: Int
}

input EstablishmentCreateWithoutEmployeesInput {
  id: ID
  name: String!
  lat: Float
  long: Float
  restaurantId: String!
  valueInCashRegister: Float!
  maximumInCashRegister: Float!
  incomeMaxReference: Int!
  isOpen: Boolean!
  workingDays: WorkDayCreateManyWithoutEstablishmentInput
  permissions: PermissionCreateManyWithoutEstablishmentInput
  items: ItemCreateManyWithoutEstablishmentInput
  tables: TableCreateManyWithoutEstablishmentInput
  expenses: ExpenseCreateManyWithoutEstablishmentInput
  discountReasons: EstablishmentCreatediscountReasonsInput
  totalInvoices: Int
  clients: ClientCreateManyWithoutEstablishmentInput
}

input EstablishmentCreateWithoutExpensesInput {
  id: ID
  name: String!
  lat: Float
  long: Float
  restaurantId: String!
  valueInCashRegister: Float!
  maximumInCashRegister: Float!
  incomeMaxReference: Int!
  isOpen: Boolean!
  workingDays: WorkDayCreateManyWithoutEstablishmentInput
  permissions: PermissionCreateManyWithoutEstablishmentInput
  items: ItemCreateManyWithoutEstablishmentInput
  employees: EmployeeCreateManyWithoutEstablishmentInput
  tables: TableCreateManyWithoutEstablishmentInput
  discountReasons: EstablishmentCreatediscountReasonsInput
  totalInvoices: Int
  clients: ClientCreateManyWithoutEstablishmentInput
}

input EstablishmentCreateWithoutItemsInput {
  id: ID
  name: String!
  lat: Float
  long: Float
  restaurantId: String!
  valueInCashRegister: Float!
  maximumInCashRegister: Float!
  incomeMaxReference: Int!
  isOpen: Boolean!
  workingDays: WorkDayCreateManyWithoutEstablishmentInput
  permissions: PermissionCreateManyWithoutEstablishmentInput
  employees: EmployeeCreateManyWithoutEstablishmentInput
  tables: TableCreateManyWithoutEstablishmentInput
  expenses: ExpenseCreateManyWithoutEstablishmentInput
  discountReasons: EstablishmentCreatediscountReasonsInput
  totalInvoices: Int
  clients: ClientCreateManyWithoutEstablishmentInput
}

input EstablishmentCreateWithoutPermissionsInput {
  id: ID
  name: String!
  lat: Float
  long: Float
  restaurantId: String!
  valueInCashRegister: Float!
  maximumInCashRegister: Float!
  incomeMaxReference: Int!
  isOpen: Boolean!
  workingDays: WorkDayCreateManyWithoutEstablishmentInput
  items: ItemCreateManyWithoutEstablishmentInput
  employees: EmployeeCreateManyWithoutEstablishmentInput
  tables: TableCreateManyWithoutEstablishmentInput
  expenses: ExpenseCreateManyWithoutEstablishmentInput
  discountReasons: EstablishmentCreatediscountReasonsInput
  totalInvoices: Int
  clients: ClientCreateManyWithoutEstablishmentInput
}

input EstablishmentCreateWithoutTablesInput {
  id: ID
  name: String!
  lat: Float
  long: Float
  restaurantId: String!
  valueInCashRegister: Float!
  maximumInCashRegister: Float!
  incomeMaxReference: Int!
  isOpen: Boolean!
  workingDays: WorkDayCreateManyWithoutEstablishmentInput
  permissions: PermissionCreateManyWithoutEstablishmentInput
  items: ItemCreateManyWithoutEstablishmentInput
  employees: EmployeeCreateManyWithoutEstablishmentInput
  expenses: ExpenseCreateManyWithoutEstablishmentInput
  discountReasons: EstablishmentCreatediscountReasonsInput
  totalInvoices: Int
  clients: ClientCreateManyWithoutEstablishmentInput
}

input EstablishmentCreateWithoutWorkingDaysInput {
  id: ID
  name: String!
  lat: Float
  long: Float
  restaurantId: String!
  valueInCashRegister: Float!
  maximumInCashRegister: Float!
  incomeMaxReference: Int!
  isOpen: Boolean!
  permissions: PermissionCreateManyWithoutEstablishmentInput
  items: ItemCreateManyWithoutEstablishmentInput
  employees: EmployeeCreateManyWithoutEstablishmentInput
  tables: TableCreateManyWithoutEstablishmentInput
  expenses: ExpenseCreateManyWithoutEstablishmentInput
  discountReasons: EstablishmentCreatediscountReasonsInput
  totalInvoices: Int
  clients: ClientCreateManyWithoutEstablishmentInput
}

type EstablishmentEdge {
  node: Establishment!
  cursor: String!
}

enum EstablishmentOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  lat_ASC
  lat_DESC
  long_ASC
  long_DESC
  restaurantId_ASC
  restaurantId_DESC
  valueInCashRegister_ASC
  valueInCashRegister_DESC
  maximumInCashRegister_ASC
  maximumInCashRegister_DESC
  incomeMaxReference_ASC
  incomeMaxReference_DESC
  isOpen_ASC
  isOpen_DESC
  totalInvoices_ASC
  totalInvoices_DESC
}

type EstablishmentPreviousValues {
  createdAt: DateTime!
  id: ID!
  name: String!
  lat: Float!
  long: Float!
  restaurantId: String!
  valueInCashRegister: Float!
  maximumInCashRegister: Float!
  incomeMaxReference: Int!
  isOpen: Boolean!
  discountReasons: [String!]!
  totalInvoices: Int
}

type EstablishmentSubscriptionPayload {
  mutation: MutationType!
  node: Establishment
  updatedFields: [String!]
  previousValues: EstablishmentPreviousValues
}

input EstablishmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EstablishmentWhereInput
  AND: [EstablishmentSubscriptionWhereInput!]
  OR: [EstablishmentSubscriptionWhereInput!]
  NOT: [EstablishmentSubscriptionWhereInput!]
}

input EstablishmentUpdatediscountReasonsInput {
  set: [String!]
}

input EstablishmentUpdateInput {
  name: String
  lat: Float
  long: Float
  restaurantId: String
  valueInCashRegister: Float
  maximumInCashRegister: Float
  incomeMaxReference: Int
  isOpen: Boolean
  workingDays: WorkDayUpdateManyWithoutEstablishmentInput
  permissions: PermissionUpdateManyWithoutEstablishmentInput
  items: ItemUpdateManyWithoutEstablishmentInput
  employees: EmployeeUpdateManyWithoutEstablishmentInput
  tables: TableUpdateManyWithoutEstablishmentInput
  expenses: ExpenseUpdateManyWithoutEstablishmentInput
  discountReasons: EstablishmentUpdatediscountReasonsInput
  totalInvoices: Int
  clients: ClientUpdateManyWithoutEstablishmentInput
}

input EstablishmentUpdateManyMutationInput {
  name: String
  lat: Float
  long: Float
  restaurantId: String
  valueInCashRegister: Float
  maximumInCashRegister: Float
  incomeMaxReference: Int
  isOpen: Boolean
  discountReasons: EstablishmentUpdatediscountReasonsInput
  totalInvoices: Int
}

input EstablishmentUpdateOneRequiredWithoutClientsInput {
  create: EstablishmentCreateWithoutClientsInput
  update: EstablishmentUpdateWithoutClientsDataInput
  upsert: EstablishmentUpsertWithoutClientsInput
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentUpdateOneRequiredWithoutEmployeesInput {
  create: EstablishmentCreateWithoutEmployeesInput
  update: EstablishmentUpdateWithoutEmployeesDataInput
  upsert: EstablishmentUpsertWithoutEmployeesInput
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentUpdateOneRequiredWithoutPermissionsInput {
  create: EstablishmentCreateWithoutPermissionsInput
  update: EstablishmentUpdateWithoutPermissionsDataInput
  upsert: EstablishmentUpsertWithoutPermissionsInput
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentUpdateOneWithoutExpensesInput {
  create: EstablishmentCreateWithoutExpensesInput
  update: EstablishmentUpdateWithoutExpensesDataInput
  upsert: EstablishmentUpsertWithoutExpensesInput
  delete: Boolean
  disconnect: Boolean
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentUpdateOneWithoutItemsInput {
  create: EstablishmentCreateWithoutItemsInput
  update: EstablishmentUpdateWithoutItemsDataInput
  upsert: EstablishmentUpsertWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentUpdateOneWithoutTablesInput {
  create: EstablishmentCreateWithoutTablesInput
  update: EstablishmentUpdateWithoutTablesDataInput
  upsert: EstablishmentUpsertWithoutTablesInput
  delete: Boolean
  disconnect: Boolean
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentUpdateOneWithoutWorkingDaysInput {
  create: EstablishmentCreateWithoutWorkingDaysInput
  update: EstablishmentUpdateWithoutWorkingDaysDataInput
  upsert: EstablishmentUpsertWithoutWorkingDaysInput
  delete: Boolean
  disconnect: Boolean
  connect: EstablishmentWhereUniqueInput
}

input EstablishmentUpdateWithoutClientsDataInput {
  name: String
  lat: Float
  long: Float
  restaurantId: String
  valueInCashRegister: Float
  maximumInCashRegister: Float
  incomeMaxReference: Int
  isOpen: Boolean
  workingDays: WorkDayUpdateManyWithoutEstablishmentInput
  permissions: PermissionUpdateManyWithoutEstablishmentInput
  items: ItemUpdateManyWithoutEstablishmentInput
  employees: EmployeeUpdateManyWithoutEstablishmentInput
  tables: TableUpdateManyWithoutEstablishmentInput
  expenses: ExpenseUpdateManyWithoutEstablishmentInput
  discountReasons: EstablishmentUpdatediscountReasonsInput
  totalInvoices: Int
}

input EstablishmentUpdateWithoutEmployeesDataInput {
  name: String
  lat: Float
  long: Float
  restaurantId: String
  valueInCashRegister: Float
  maximumInCashRegister: Float
  incomeMaxReference: Int
  isOpen: Boolean
  workingDays: WorkDayUpdateManyWithoutEstablishmentInput
  permissions: PermissionUpdateManyWithoutEstablishmentInput
  items: ItemUpdateManyWithoutEstablishmentInput
  tables: TableUpdateManyWithoutEstablishmentInput
  expenses: ExpenseUpdateManyWithoutEstablishmentInput
  discountReasons: EstablishmentUpdatediscountReasonsInput
  totalInvoices: Int
  clients: ClientUpdateManyWithoutEstablishmentInput
}

input EstablishmentUpdateWithoutExpensesDataInput {
  name: String
  lat: Float
  long: Float
  restaurantId: String
  valueInCashRegister: Float
  maximumInCashRegister: Float
  incomeMaxReference: Int
  isOpen: Boolean
  workingDays: WorkDayUpdateManyWithoutEstablishmentInput
  permissions: PermissionUpdateManyWithoutEstablishmentInput
  items: ItemUpdateManyWithoutEstablishmentInput
  employees: EmployeeUpdateManyWithoutEstablishmentInput
  tables: TableUpdateManyWithoutEstablishmentInput
  discountReasons: EstablishmentUpdatediscountReasonsInput
  totalInvoices: Int
  clients: ClientUpdateManyWithoutEstablishmentInput
}

input EstablishmentUpdateWithoutItemsDataInput {
  name: String
  lat: Float
  long: Float
  restaurantId: String
  valueInCashRegister: Float
  maximumInCashRegister: Float
  incomeMaxReference: Int
  isOpen: Boolean
  workingDays: WorkDayUpdateManyWithoutEstablishmentInput
  permissions: PermissionUpdateManyWithoutEstablishmentInput
  employees: EmployeeUpdateManyWithoutEstablishmentInput
  tables: TableUpdateManyWithoutEstablishmentInput
  expenses: ExpenseUpdateManyWithoutEstablishmentInput
  discountReasons: EstablishmentUpdatediscountReasonsInput
  totalInvoices: Int
  clients: ClientUpdateManyWithoutEstablishmentInput
}

input EstablishmentUpdateWithoutPermissionsDataInput {
  name: String
  lat: Float
  long: Float
  restaurantId: String
  valueInCashRegister: Float
  maximumInCashRegister: Float
  incomeMaxReference: Int
  isOpen: Boolean
  workingDays: WorkDayUpdateManyWithoutEstablishmentInput
  items: ItemUpdateManyWithoutEstablishmentInput
  employees: EmployeeUpdateManyWithoutEstablishmentInput
  tables: TableUpdateManyWithoutEstablishmentInput
  expenses: ExpenseUpdateManyWithoutEstablishmentInput
  discountReasons: EstablishmentUpdatediscountReasonsInput
  totalInvoices: Int
  clients: ClientUpdateManyWithoutEstablishmentInput
}

input EstablishmentUpdateWithoutTablesDataInput {
  name: String
  lat: Float
  long: Float
  restaurantId: String
  valueInCashRegister: Float
  maximumInCashRegister: Float
  incomeMaxReference: Int
  isOpen: Boolean
  workingDays: WorkDayUpdateManyWithoutEstablishmentInput
  permissions: PermissionUpdateManyWithoutEstablishmentInput
  items: ItemUpdateManyWithoutEstablishmentInput
  employees: EmployeeUpdateManyWithoutEstablishmentInput
  expenses: ExpenseUpdateManyWithoutEstablishmentInput
  discountReasons: EstablishmentUpdatediscountReasonsInput
  totalInvoices: Int
  clients: ClientUpdateManyWithoutEstablishmentInput
}

input EstablishmentUpdateWithoutWorkingDaysDataInput {
  name: String
  lat: Float
  long: Float
  restaurantId: String
  valueInCashRegister: Float
  maximumInCashRegister: Float
  incomeMaxReference: Int
  isOpen: Boolean
  permissions: PermissionUpdateManyWithoutEstablishmentInput
  items: ItemUpdateManyWithoutEstablishmentInput
  employees: EmployeeUpdateManyWithoutEstablishmentInput
  tables: TableUpdateManyWithoutEstablishmentInput
  expenses: ExpenseUpdateManyWithoutEstablishmentInput
  discountReasons: EstablishmentUpdatediscountReasonsInput
  totalInvoices: Int
  clients: ClientUpdateManyWithoutEstablishmentInput
}

input EstablishmentUpsertWithoutClientsInput {
  update: EstablishmentUpdateWithoutClientsDataInput!
  create: EstablishmentCreateWithoutClientsInput!
}

input EstablishmentUpsertWithoutEmployeesInput {
  update: EstablishmentUpdateWithoutEmployeesDataInput!
  create: EstablishmentCreateWithoutEmployeesInput!
}

input EstablishmentUpsertWithoutExpensesInput {
  update: EstablishmentUpdateWithoutExpensesDataInput!
  create: EstablishmentCreateWithoutExpensesInput!
}

input EstablishmentUpsertWithoutItemsInput {
  update: EstablishmentUpdateWithoutItemsDataInput!
  create: EstablishmentCreateWithoutItemsInput!
}

input EstablishmentUpsertWithoutPermissionsInput {
  update: EstablishmentUpdateWithoutPermissionsDataInput!
  create: EstablishmentCreateWithoutPermissionsInput!
}

input EstablishmentUpsertWithoutTablesInput {
  update: EstablishmentUpdateWithoutTablesDataInput!
  create: EstablishmentCreateWithoutTablesInput!
}

input EstablishmentUpsertWithoutWorkingDaysInput {
  update: EstablishmentUpdateWithoutWorkingDaysDataInput!
  create: EstablishmentCreateWithoutWorkingDaysInput!
}

input EstablishmentWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  long: Float
  long_not: Float
  long_in: [Float!]
  long_not_in: [Float!]
  long_lt: Float
  long_lte: Float
  long_gt: Float
  long_gte: Float
  restaurantId: String
  restaurantId_not: String
  restaurantId_in: [String!]
  restaurantId_not_in: [String!]
  restaurantId_lt: String
  restaurantId_lte: String
  restaurantId_gt: String
  restaurantId_gte: String
  restaurantId_contains: String
  restaurantId_not_contains: String
  restaurantId_starts_with: String
  restaurantId_not_starts_with: String
  restaurantId_ends_with: String
  restaurantId_not_ends_with: String
  valueInCashRegister: Float
  valueInCashRegister_not: Float
  valueInCashRegister_in: [Float!]
  valueInCashRegister_not_in: [Float!]
  valueInCashRegister_lt: Float
  valueInCashRegister_lte: Float
  valueInCashRegister_gt: Float
  valueInCashRegister_gte: Float
  maximumInCashRegister: Float
  maximumInCashRegister_not: Float
  maximumInCashRegister_in: [Float!]
  maximumInCashRegister_not_in: [Float!]
  maximumInCashRegister_lt: Float
  maximumInCashRegister_lte: Float
  maximumInCashRegister_gt: Float
  maximumInCashRegister_gte: Float
  incomeMaxReference: Int
  incomeMaxReference_not: Int
  incomeMaxReference_in: [Int!]
  incomeMaxReference_not_in: [Int!]
  incomeMaxReference_lt: Int
  incomeMaxReference_lte: Int
  incomeMaxReference_gt: Int
  incomeMaxReference_gte: Int
  isOpen: Boolean
  isOpen_not: Boolean
  workingDays_every: WorkDayWhereInput
  workingDays_some: WorkDayWhereInput
  workingDays_none: WorkDayWhereInput
  permissions_every: PermissionWhereInput
  permissions_some: PermissionWhereInput
  permissions_none: PermissionWhereInput
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  employees_every: EmployeeWhereInput
  employees_some: EmployeeWhereInput
  employees_none: EmployeeWhereInput
  tables_every: TableWhereInput
  tables_some: TableWhereInput
  tables_none: TableWhereInput
  expenses_every: ExpenseWhereInput
  expenses_some: ExpenseWhereInput
  expenses_none: ExpenseWhereInput
  totalInvoices: Int
  totalInvoices_not: Int
  totalInvoices_in: [Int!]
  totalInvoices_not_in: [Int!]
  totalInvoices_lt: Int
  totalInvoices_lte: Int
  totalInvoices_gt: Int
  totalInvoices_gte: Int
  clients_every: ClientWhereInput
  clients_some: ClientWhereInput
  clients_none: ClientWhereInput
  AND: [EstablishmentWhereInput!]
  OR: [EstablishmentWhereInput!]
  NOT: [EstablishmentWhereInput!]
}

input EstablishmentWhereUniqueInput {
  id: ID
}

type Expense {
  createdAt: DateTime!
  id: ID!
  establishment: Establishment
  NFE: Boolean!
  NFEReference: String
  expenseItems(where: ExpenseItemWhereInput, orderBy: ExpenseItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExpenseItem!]
  date: DateTime!
  executionDate: DateTime!
  payment: Payment
}

type ExpenseConnection {
  pageInfo: PageInfo!
  edges: [ExpenseEdge]!
  aggregate: AggregateExpense!
}

input ExpenseCreateInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutExpensesInput
  NFE: Boolean!
  NFEReference: String
  expenseItems: ExpenseItemCreateManyInput
  date: DateTime!
  executionDate: DateTime!
  payment: PaymentCreateOneWithoutExpenseInput
}

input ExpenseCreateManyWithoutEstablishmentInput {
  create: [ExpenseCreateWithoutEstablishmentInput!]
  connect: [ExpenseWhereUniqueInput!]
}

input ExpenseCreateOneWithoutPaymentInput {
  create: ExpenseCreateWithoutPaymentInput
  connect: ExpenseWhereUniqueInput
}

input ExpenseCreateWithoutEstablishmentInput {
  id: ID
  NFE: Boolean!
  NFEReference: String
  expenseItems: ExpenseItemCreateManyInput
  date: DateTime!
  executionDate: DateTime!
  payment: PaymentCreateOneWithoutExpenseInput
}

input ExpenseCreateWithoutPaymentInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutExpensesInput
  NFE: Boolean!
  NFEReference: String
  expenseItems: ExpenseItemCreateManyInput
  date: DateTime!
  executionDate: DateTime!
}

type ExpenseEdge {
  node: Expense!
  cursor: String!
}

type ExpenseItem {
  createdAt: DateTime!
  id: ID!
  quantity: Float!
  product: Product!
  value: Float!
  details: String
}

type ExpenseItemConnection {
  pageInfo: PageInfo!
  edges: [ExpenseItemEdge]!
  aggregate: AggregateExpenseItem!
}

input ExpenseItemCreateInput {
  id: ID
  quantity: Float!
  product: ProductCreateOneInput!
  value: Float!
  details: String
}

input ExpenseItemCreateManyInput {
  create: [ExpenseItemCreateInput!]
  connect: [ExpenseItemWhereUniqueInput!]
}

type ExpenseItemEdge {
  node: ExpenseItem!
  cursor: String!
}

enum ExpenseItemOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  quantity_ASC
  quantity_DESC
  value_ASC
  value_DESC
  details_ASC
  details_DESC
}

type ExpenseItemPreviousValues {
  createdAt: DateTime!
  id: ID!
  quantity: Float!
  value: Float!
  details: String
}

input ExpenseItemScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quantity: Float
  quantity_not: Float
  quantity_in: [Float!]
  quantity_not_in: [Float!]
  quantity_lt: Float
  quantity_lte: Float
  quantity_gt: Float
  quantity_gte: Float
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  details: String
  details_not: String
  details_in: [String!]
  details_not_in: [String!]
  details_lt: String
  details_lte: String
  details_gt: String
  details_gte: String
  details_contains: String
  details_not_contains: String
  details_starts_with: String
  details_not_starts_with: String
  details_ends_with: String
  details_not_ends_with: String
  AND: [ExpenseItemScalarWhereInput!]
  OR: [ExpenseItemScalarWhereInput!]
  NOT: [ExpenseItemScalarWhereInput!]
}

type ExpenseItemSubscriptionPayload {
  mutation: MutationType!
  node: ExpenseItem
  updatedFields: [String!]
  previousValues: ExpenseItemPreviousValues
}

input ExpenseItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExpenseItemWhereInput
  AND: [ExpenseItemSubscriptionWhereInput!]
  OR: [ExpenseItemSubscriptionWhereInput!]
  NOT: [ExpenseItemSubscriptionWhereInput!]
}

input ExpenseItemUpdateDataInput {
  quantity: Float
  product: ProductUpdateOneRequiredInput
  value: Float
  details: String
}

input ExpenseItemUpdateInput {
  quantity: Float
  product: ProductUpdateOneRequiredInput
  value: Float
  details: String
}

input ExpenseItemUpdateManyDataInput {
  quantity: Float
  value: Float
  details: String
}

input ExpenseItemUpdateManyInput {
  create: [ExpenseItemCreateInput!]
  update: [ExpenseItemUpdateWithWhereUniqueNestedInput!]
  upsert: [ExpenseItemUpsertWithWhereUniqueNestedInput!]
  delete: [ExpenseItemWhereUniqueInput!]
  connect: [ExpenseItemWhereUniqueInput!]
  set: [ExpenseItemWhereUniqueInput!]
  disconnect: [ExpenseItemWhereUniqueInput!]
  deleteMany: [ExpenseItemScalarWhereInput!]
  updateMany: [ExpenseItemUpdateManyWithWhereNestedInput!]
}

input ExpenseItemUpdateManyMutationInput {
  quantity: Float
  value: Float
  details: String
}

input ExpenseItemUpdateManyWithWhereNestedInput {
  where: ExpenseItemScalarWhereInput!
  data: ExpenseItemUpdateManyDataInput!
}

input ExpenseItemUpdateWithWhereUniqueNestedInput {
  where: ExpenseItemWhereUniqueInput!
  data: ExpenseItemUpdateDataInput!
}

input ExpenseItemUpsertWithWhereUniqueNestedInput {
  where: ExpenseItemWhereUniqueInput!
  update: ExpenseItemUpdateDataInput!
  create: ExpenseItemCreateInput!
}

input ExpenseItemWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quantity: Float
  quantity_not: Float
  quantity_in: [Float!]
  quantity_not_in: [Float!]
  quantity_lt: Float
  quantity_lte: Float
  quantity_gt: Float
  quantity_gte: Float
  product: ProductWhereInput
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  details: String
  details_not: String
  details_in: [String!]
  details_not_in: [String!]
  details_lt: String
  details_lte: String
  details_gt: String
  details_gte: String
  details_contains: String
  details_not_contains: String
  details_starts_with: String
  details_not_starts_with: String
  details_ends_with: String
  details_not_ends_with: String
  AND: [ExpenseItemWhereInput!]
  OR: [ExpenseItemWhereInput!]
  NOT: [ExpenseItemWhereInput!]
}

input ExpenseItemWhereUniqueInput {
  id: ID
}

enum ExpenseOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  NFE_ASC
  NFE_DESC
  NFEReference_ASC
  NFEReference_DESC
  date_ASC
  date_DESC
  executionDate_ASC
  executionDate_DESC
}

type ExpensePreviousValues {
  createdAt: DateTime!
  id: ID!
  NFE: Boolean!
  NFEReference: String
  date: DateTime!
  executionDate: DateTime!
}

input ExpenseScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  NFE: Boolean
  NFE_not: Boolean
  NFEReference: String
  NFEReference_not: String
  NFEReference_in: [String!]
  NFEReference_not_in: [String!]
  NFEReference_lt: String
  NFEReference_lte: String
  NFEReference_gt: String
  NFEReference_gte: String
  NFEReference_contains: String
  NFEReference_not_contains: String
  NFEReference_starts_with: String
  NFEReference_not_starts_with: String
  NFEReference_ends_with: String
  NFEReference_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  executionDate: DateTime
  executionDate_not: DateTime
  executionDate_in: [DateTime!]
  executionDate_not_in: [DateTime!]
  executionDate_lt: DateTime
  executionDate_lte: DateTime
  executionDate_gt: DateTime
  executionDate_gte: DateTime
  AND: [ExpenseScalarWhereInput!]
  OR: [ExpenseScalarWhereInput!]
  NOT: [ExpenseScalarWhereInput!]
}

type ExpenseSubscriptionPayload {
  mutation: MutationType!
  node: Expense
  updatedFields: [String!]
  previousValues: ExpensePreviousValues
}

input ExpenseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExpenseWhereInput
  AND: [ExpenseSubscriptionWhereInput!]
  OR: [ExpenseSubscriptionWhereInput!]
  NOT: [ExpenseSubscriptionWhereInput!]
}

input ExpenseUpdateInput {
  establishment: EstablishmentUpdateOneWithoutExpensesInput
  NFE: Boolean
  NFEReference: String
  expenseItems: ExpenseItemUpdateManyInput
  date: DateTime
  executionDate: DateTime
  payment: PaymentUpdateOneWithoutExpenseInput
}

input ExpenseUpdateManyDataInput {
  NFE: Boolean
  NFEReference: String
  date: DateTime
  executionDate: DateTime
}

input ExpenseUpdateManyMutationInput {
  NFE: Boolean
  NFEReference: String
  date: DateTime
  executionDate: DateTime
}

input ExpenseUpdateManyWithoutEstablishmentInput {
  create: [ExpenseCreateWithoutEstablishmentInput!]
  delete: [ExpenseWhereUniqueInput!]
  connect: [ExpenseWhereUniqueInput!]
  set: [ExpenseWhereUniqueInput!]
  disconnect: [ExpenseWhereUniqueInput!]
  update: [ExpenseUpdateWithWhereUniqueWithoutEstablishmentInput!]
  upsert: [ExpenseUpsertWithWhereUniqueWithoutEstablishmentInput!]
  deleteMany: [ExpenseScalarWhereInput!]
  updateMany: [ExpenseUpdateManyWithWhereNestedInput!]
}

input ExpenseUpdateManyWithWhereNestedInput {
  where: ExpenseScalarWhereInput!
  data: ExpenseUpdateManyDataInput!
}

input ExpenseUpdateOneWithoutPaymentInput {
  create: ExpenseCreateWithoutPaymentInput
  update: ExpenseUpdateWithoutPaymentDataInput
  upsert: ExpenseUpsertWithoutPaymentInput
  delete: Boolean
  disconnect: Boolean
  connect: ExpenseWhereUniqueInput
}

input ExpenseUpdateWithoutEstablishmentDataInput {
  NFE: Boolean
  NFEReference: String
  expenseItems: ExpenseItemUpdateManyInput
  date: DateTime
  executionDate: DateTime
  payment: PaymentUpdateOneWithoutExpenseInput
}

input ExpenseUpdateWithoutPaymentDataInput {
  establishment: EstablishmentUpdateOneWithoutExpensesInput
  NFE: Boolean
  NFEReference: String
  expenseItems: ExpenseItemUpdateManyInput
  date: DateTime
  executionDate: DateTime
}

input ExpenseUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: ExpenseWhereUniqueInput!
  data: ExpenseUpdateWithoutEstablishmentDataInput!
}

input ExpenseUpsertWithoutPaymentInput {
  update: ExpenseUpdateWithoutPaymentDataInput!
  create: ExpenseCreateWithoutPaymentInput!
}

input ExpenseUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: ExpenseWhereUniqueInput!
  update: ExpenseUpdateWithoutEstablishmentDataInput!
  create: ExpenseCreateWithoutEstablishmentInput!
}

input ExpenseWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  establishment: EstablishmentWhereInput
  NFE: Boolean
  NFE_not: Boolean
  NFEReference: String
  NFEReference_not: String
  NFEReference_in: [String!]
  NFEReference_not_in: [String!]
  NFEReference_lt: String
  NFEReference_lte: String
  NFEReference_gt: String
  NFEReference_gte: String
  NFEReference_contains: String
  NFEReference_not_contains: String
  NFEReference_starts_with: String
  NFEReference_not_starts_with: String
  NFEReference_ends_with: String
  NFEReference_not_ends_with: String
  expenseItems_every: ExpenseItemWhereInput
  expenseItems_some: ExpenseItemWhereInput
  expenseItems_none: ExpenseItemWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  executionDate: DateTime
  executionDate_not: DateTime
  executionDate_in: [DateTime!]
  executionDate_not_in: [DateTime!]
  executionDate_lt: DateTime
  executionDate_lte: DateTime
  executionDate_gt: DateTime
  executionDate_gte: DateTime
  payment: PaymentWhereInput
  AND: [ExpenseWhereInput!]
  OR: [ExpenseWhereInput!]
  NOT: [ExpenseWhereInput!]
}

input ExpenseWhereUniqueInput {
  id: ID
}

type Income {
  createdAt: DateTime!
  id: ID!
  workDay: WorkDay
  reference: String!
  value: Float!
  type: String
}

type IncomeConnection {
  pageInfo: PageInfo!
  edges: [IncomeEdge]!
  aggregate: AggregateIncome!
}

input IncomeCreateInput {
  id: ID
  workDay: WorkDayCreateOneWithoutIncomesInput
  reference: String!
  value: Float!
  type: String
}

input IncomeCreateManyWithoutWorkDayInput {
  create: [IncomeCreateWithoutWorkDayInput!]
  connect: [IncomeWhereUniqueInput!]
}

input IncomeCreateWithoutWorkDayInput {
  id: ID
  reference: String!
  value: Float!
  type: String
}

type IncomeEdge {
  node: Income!
  cursor: String!
}

enum IncomeOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  reference_ASC
  reference_DESC
  value_ASC
  value_DESC
  type_ASC
  type_DESC
}

type IncomePreviousValues {
  createdAt: DateTime!
  id: ID!
  reference: String!
  value: Float!
  type: String
}

input IncomeScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reference: String
  reference_not: String
  reference_in: [String!]
  reference_not_in: [String!]
  reference_lt: String
  reference_lte: String
  reference_gt: String
  reference_gte: String
  reference_contains: String
  reference_not_contains: String
  reference_starts_with: String
  reference_not_starts_with: String
  reference_ends_with: String
  reference_not_ends_with: String
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  AND: [IncomeScalarWhereInput!]
  OR: [IncomeScalarWhereInput!]
  NOT: [IncomeScalarWhereInput!]
}

type IncomeSubscriptionPayload {
  mutation: MutationType!
  node: Income
  updatedFields: [String!]
  previousValues: IncomePreviousValues
}

input IncomeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IncomeWhereInput
  AND: [IncomeSubscriptionWhereInput!]
  OR: [IncomeSubscriptionWhereInput!]
  NOT: [IncomeSubscriptionWhereInput!]
}

input IncomeUpdateInput {
  workDay: WorkDayUpdateOneWithoutIncomesInput
  reference: String
  value: Float
  type: String
}

input IncomeUpdateManyDataInput {
  reference: String
  value: Float
  type: String
}

input IncomeUpdateManyMutationInput {
  reference: String
  value: Float
  type: String
}

input IncomeUpdateManyWithoutWorkDayInput {
  create: [IncomeCreateWithoutWorkDayInput!]
  delete: [IncomeWhereUniqueInput!]
  connect: [IncomeWhereUniqueInput!]
  set: [IncomeWhereUniqueInput!]
  disconnect: [IncomeWhereUniqueInput!]
  update: [IncomeUpdateWithWhereUniqueWithoutWorkDayInput!]
  upsert: [IncomeUpsertWithWhereUniqueWithoutWorkDayInput!]
  deleteMany: [IncomeScalarWhereInput!]
  updateMany: [IncomeUpdateManyWithWhereNestedInput!]
}

input IncomeUpdateManyWithWhereNestedInput {
  where: IncomeScalarWhereInput!
  data: IncomeUpdateManyDataInput!
}

input IncomeUpdateWithoutWorkDayDataInput {
  reference: String
  value: Float
  type: String
}

input IncomeUpdateWithWhereUniqueWithoutWorkDayInput {
  where: IncomeWhereUniqueInput!
  data: IncomeUpdateWithoutWorkDayDataInput!
}

input IncomeUpsertWithWhereUniqueWithoutWorkDayInput {
  where: IncomeWhereUniqueInput!
  update: IncomeUpdateWithoutWorkDayDataInput!
  create: IncomeCreateWithoutWorkDayInput!
}

input IncomeWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  workDay: WorkDayWhereInput
  reference: String
  reference_not: String
  reference_in: [String!]
  reference_not_in: [String!]
  reference_lt: String
  reference_lte: String
  reference_gt: String
  reference_gte: String
  reference_contains: String
  reference_not_contains: String
  reference_starts_with: String
  reference_not_starts_with: String
  reference_ends_with: String
  reference_not_ends_with: String
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  AND: [IncomeWhereInput!]
  OR: [IncomeWhereInput!]
  NOT: [IncomeWhereInput!]
}

input IncomeWhereUniqueInput {
  id: ID
  reference: String
}

type Item {
  id: ID!
  itemId: String!
  name: String!
  price: Float!
  priceToGo: Float
  employeePrice: Float
  category: String!
  orderItem(where: OrderItemWhereInput, orderBy: OrderItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderItem!]
  establishment: Establishment
  canTakeToGo: Boolean
  isActive: Boolean!
  itemNCM: NCM
  hasTaxSubstitution: Boolean
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  id: ID
  itemId: String!
  name: String!
  price: Float!
  priceToGo: Float
  employeePrice: Float
  category: String!
  orderItem: OrderItemCreateManyWithoutItemInput
  establishment: EstablishmentCreateOneWithoutItemsInput
  canTakeToGo: Boolean
  isActive: Boolean!
  itemNCM: NCMCreateOneWithoutItemsInput
  hasTaxSubstitution: Boolean
}

input ItemCreateManyWithoutEstablishmentInput {
  create: [ItemCreateWithoutEstablishmentInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateManyWithoutItemNCMInput {
  create: [ItemCreateWithoutItemNCMInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateOneWithoutOrderItemInput {
  create: ItemCreateWithoutOrderItemInput
  connect: ItemWhereUniqueInput
}

input ItemCreateWithoutEstablishmentInput {
  id: ID
  itemId: String!
  name: String!
  price: Float!
  priceToGo: Float
  employeePrice: Float
  category: String!
  orderItem: OrderItemCreateManyWithoutItemInput
  canTakeToGo: Boolean
  isActive: Boolean!
  itemNCM: NCMCreateOneWithoutItemsInput
  hasTaxSubstitution: Boolean
}

input ItemCreateWithoutItemNCMInput {
  id: ID
  itemId: String!
  name: String!
  price: Float!
  priceToGo: Float
  employeePrice: Float
  category: String!
  orderItem: OrderItemCreateManyWithoutItemInput
  establishment: EstablishmentCreateOneWithoutItemsInput
  canTakeToGo: Boolean
  isActive: Boolean!
  hasTaxSubstitution: Boolean
}

input ItemCreateWithoutOrderItemInput {
  id: ID
  itemId: String!
  name: String!
  price: Float!
  priceToGo: Float
  employeePrice: Float
  category: String!
  establishment: EstablishmentCreateOneWithoutItemsInput
  canTakeToGo: Boolean
  isActive: Boolean!
  itemNCM: NCMCreateOneWithoutItemsInput
  hasTaxSubstitution: Boolean
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  itemId_ASC
  itemId_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
  priceToGo_ASC
  priceToGo_DESC
  employeePrice_ASC
  employeePrice_DESC
  category_ASC
  category_DESC
  canTakeToGo_ASC
  canTakeToGo_DESC
  isActive_ASC
  isActive_DESC
  hasTaxSubstitution_ASC
  hasTaxSubstitution_DESC
}

type ItemPreviousValues {
  id: ID!
  itemId: String!
  name: String!
  price: Float!
  priceToGo: Float
  employeePrice: Float
  category: String!
  canTakeToGo: Boolean
  isActive: Boolean!
  hasTaxSubstitution: Boolean
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  itemId: String
  itemId_not: String
  itemId_in: [String!]
  itemId_not_in: [String!]
  itemId_lt: String
  itemId_lte: String
  itemId_gt: String
  itemId_gte: String
  itemId_contains: String
  itemId_not_contains: String
  itemId_starts_with: String
  itemId_not_starts_with: String
  itemId_ends_with: String
  itemId_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  priceToGo: Float
  priceToGo_not: Float
  priceToGo_in: [Float!]
  priceToGo_not_in: [Float!]
  priceToGo_lt: Float
  priceToGo_lte: Float
  priceToGo_gt: Float
  priceToGo_gte: Float
  employeePrice: Float
  employeePrice_not: Float
  employeePrice_in: [Float!]
  employeePrice_not_in: [Float!]
  employeePrice_lt: Float
  employeePrice_lte: Float
  employeePrice_gt: Float
  employeePrice_gte: Float
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  canTakeToGo: Boolean
  canTakeToGo_not: Boolean
  isActive: Boolean
  isActive_not: Boolean
  hasTaxSubstitution: Boolean
  hasTaxSubstitution_not: Boolean
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateInput {
  itemId: String
  name: String
  price: Float
  priceToGo: Float
  employeePrice: Float
  category: String
  orderItem: OrderItemUpdateManyWithoutItemInput
  establishment: EstablishmentUpdateOneWithoutItemsInput
  canTakeToGo: Boolean
  isActive: Boolean
  itemNCM: NCMUpdateOneWithoutItemsInput
  hasTaxSubstitution: Boolean
}

input ItemUpdateManyDataInput {
  itemId: String
  name: String
  price: Float
  priceToGo: Float
  employeePrice: Float
  category: String
  canTakeToGo: Boolean
  isActive: Boolean
  hasTaxSubstitution: Boolean
}

input ItemUpdateManyMutationInput {
  itemId: String
  name: String
  price: Float
  priceToGo: Float
  employeePrice: Float
  category: String
  canTakeToGo: Boolean
  isActive: Boolean
  hasTaxSubstitution: Boolean
}

input ItemUpdateManyWithoutEstablishmentInput {
  create: [ItemCreateWithoutEstablishmentInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutEstablishmentInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutEstablishmentInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithoutItemNCMInput {
  create: [ItemCreateWithoutItemNCMInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutItemNCMInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutItemNCMInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdateOneRequiredWithoutOrderItemInput {
  create: ItemCreateWithoutOrderItemInput
  update: ItemUpdateWithoutOrderItemDataInput
  upsert: ItemUpsertWithoutOrderItemInput
  connect: ItemWhereUniqueInput
}

input ItemUpdateWithoutEstablishmentDataInput {
  itemId: String
  name: String
  price: Float
  priceToGo: Float
  employeePrice: Float
  category: String
  orderItem: OrderItemUpdateManyWithoutItemInput
  canTakeToGo: Boolean
  isActive: Boolean
  itemNCM: NCMUpdateOneWithoutItemsInput
  hasTaxSubstitution: Boolean
}

input ItemUpdateWithoutItemNCMDataInput {
  itemId: String
  name: String
  price: Float
  priceToGo: Float
  employeePrice: Float
  category: String
  orderItem: OrderItemUpdateManyWithoutItemInput
  establishment: EstablishmentUpdateOneWithoutItemsInput
  canTakeToGo: Boolean
  isActive: Boolean
  hasTaxSubstitution: Boolean
}

input ItemUpdateWithoutOrderItemDataInput {
  itemId: String
  name: String
  price: Float
  priceToGo: Float
  employeePrice: Float
  category: String
  establishment: EstablishmentUpdateOneWithoutItemsInput
  canTakeToGo: Boolean
  isActive: Boolean
  itemNCM: NCMUpdateOneWithoutItemsInput
  hasTaxSubstitution: Boolean
}

input ItemUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutEstablishmentDataInput!
}

input ItemUpdateWithWhereUniqueWithoutItemNCMInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutItemNCMDataInput!
}

input ItemUpsertWithoutOrderItemInput {
  update: ItemUpdateWithoutOrderItemDataInput!
  create: ItemCreateWithoutOrderItemInput!
}

input ItemUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutEstablishmentDataInput!
  create: ItemCreateWithoutEstablishmentInput!
}

input ItemUpsertWithWhereUniqueWithoutItemNCMInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutItemNCMDataInput!
  create: ItemCreateWithoutItemNCMInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  itemId: String
  itemId_not: String
  itemId_in: [String!]
  itemId_not_in: [String!]
  itemId_lt: String
  itemId_lte: String
  itemId_gt: String
  itemId_gte: String
  itemId_contains: String
  itemId_not_contains: String
  itemId_starts_with: String
  itemId_not_starts_with: String
  itemId_ends_with: String
  itemId_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  priceToGo: Float
  priceToGo_not: Float
  priceToGo_in: [Float!]
  priceToGo_not_in: [Float!]
  priceToGo_lt: Float
  priceToGo_lte: Float
  priceToGo_gt: Float
  priceToGo_gte: Float
  employeePrice: Float
  employeePrice_not: Float
  employeePrice_in: [Float!]
  employeePrice_not_in: [Float!]
  employeePrice_lt: Float
  employeePrice_lte: Float
  employeePrice_gt: Float
  employeePrice_gte: Float
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  orderItem_every: OrderItemWhereInput
  orderItem_some: OrderItemWhereInput
  orderItem_none: OrderItemWhereInput
  establishment: EstablishmentWhereInput
  canTakeToGo: Boolean
  canTakeToGo_not: Boolean
  isActive: Boolean
  isActive_not: Boolean
  itemNCM: NCMWhereInput
  hasTaxSubstitution: Boolean
  hasTaxSubstitution_not: Boolean
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createBill(data: BillCreateInput!): Bill!
  updateBill(data: BillUpdateInput!, where: BillWhereUniqueInput!): Bill
  updateManyBills(data: BillUpdateManyMutationInput!, where: BillWhereInput): BatchPayload!
  upsertBill(where: BillWhereUniqueInput!, create: BillCreateInput!, update: BillUpdateInput!): Bill!
  deleteBill(where: BillWhereUniqueInput!): Bill
  deleteManyBills(where: BillWhereInput): BatchPayload!
  createCheckData(data: CheckDataCreateInput!): CheckData!
  updateCheckData(data: CheckDataUpdateInput!, where: CheckDataWhereUniqueInput!): CheckData
  updateManyCheckDatas(data: CheckDataUpdateManyMutationInput!, where: CheckDataWhereInput): BatchPayload!
  upsertCheckData(where: CheckDataWhereUniqueInput!, create: CheckDataCreateInput!, update: CheckDataUpdateInput!): CheckData!
  deleteCheckData(where: CheckDataWhereUniqueInput!): CheckData
  deleteManyCheckDatas(where: CheckDataWhereInput): BatchPayload!
  createClient(data: ClientCreateInput!): Client!
  updateClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateManyClients(data: ClientUpdateManyMutationInput!, where: ClientWhereInput): BatchPayload!
  upsertClient(where: ClientWhereUniqueInput!, create: ClientCreateInput!, update: ClientUpdateInput!): Client!
  deleteClient(where: ClientWhereUniqueInput!): Client
  deleteManyClients(where: ClientWhereInput): BatchPayload!
  createEmployee(data: EmployeeCreateInput!): Employee!
  updateEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  updateManyEmployees(data: EmployeeUpdateManyMutationInput!, where: EmployeeWhereInput): BatchPayload!
  upsertEmployee(where: EmployeeWhereUniqueInput!, create: EmployeeCreateInput!, update: EmployeeUpdateInput!): Employee!
  deleteEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteManyEmployees(where: EmployeeWhereInput): BatchPayload!
  createEstablishment(data: EstablishmentCreateInput!): Establishment!
  updateEstablishment(data: EstablishmentUpdateInput!, where: EstablishmentWhereUniqueInput!): Establishment
  updateManyEstablishments(data: EstablishmentUpdateManyMutationInput!, where: EstablishmentWhereInput): BatchPayload!
  upsertEstablishment(where: EstablishmentWhereUniqueInput!, create: EstablishmentCreateInput!, update: EstablishmentUpdateInput!): Establishment!
  deleteEstablishment(where: EstablishmentWhereUniqueInput!): Establishment
  deleteManyEstablishments(where: EstablishmentWhereInput): BatchPayload!
  createExpense(data: ExpenseCreateInput!): Expense!
  updateExpense(data: ExpenseUpdateInput!, where: ExpenseWhereUniqueInput!): Expense
  updateManyExpenses(data: ExpenseUpdateManyMutationInput!, where: ExpenseWhereInput): BatchPayload!
  upsertExpense(where: ExpenseWhereUniqueInput!, create: ExpenseCreateInput!, update: ExpenseUpdateInput!): Expense!
  deleteExpense(where: ExpenseWhereUniqueInput!): Expense
  deleteManyExpenses(where: ExpenseWhereInput): BatchPayload!
  createExpenseItem(data: ExpenseItemCreateInput!): ExpenseItem!
  updateExpenseItem(data: ExpenseItemUpdateInput!, where: ExpenseItemWhereUniqueInput!): ExpenseItem
  updateManyExpenseItems(data: ExpenseItemUpdateManyMutationInput!, where: ExpenseItemWhereInput): BatchPayload!
  upsertExpenseItem(where: ExpenseItemWhereUniqueInput!, create: ExpenseItemCreateInput!, update: ExpenseItemUpdateInput!): ExpenseItem!
  deleteExpenseItem(where: ExpenseItemWhereUniqueInput!): ExpenseItem
  deleteManyExpenseItems(where: ExpenseItemWhereInput): BatchPayload!
  createIncome(data: IncomeCreateInput!): Income!
  updateIncome(data: IncomeUpdateInput!, where: IncomeWhereUniqueInput!): Income
  updateManyIncomes(data: IncomeUpdateManyMutationInput!, where: IncomeWhereInput): BatchPayload!
  upsertIncome(where: IncomeWhereUniqueInput!, create: IncomeCreateInput!, update: IncomeUpdateInput!): Income!
  deleteIncome(where: IncomeWhereUniqueInput!): Income
  deleteManyIncomes(where: IncomeWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createNCM(data: NCMCreateInput!): NCM!
  updateNCM(data: NCMUpdateInput!, where: NCMWhereUniqueInput!): NCM
  updateManyNCMs(data: NCMUpdateManyMutationInput!, where: NCMWhereInput): BatchPayload!
  upsertNCM(where: NCMWhereUniqueInput!, create: NCMCreateInput!, update: NCMUpdateInput!): NCM!
  deleteNCM(where: NCMWhereUniqueInput!): NCM
  deleteManyNCMs(where: NCMWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createOrderItem(data: OrderItemCreateInput!): OrderItem!
  updateOrderItem(data: OrderItemUpdateInput!, where: OrderItemWhereUniqueInput!): OrderItem
  updateManyOrderItems(data: OrderItemUpdateManyMutationInput!, where: OrderItemWhereInput): BatchPayload!
  upsertOrderItem(where: OrderItemWhereUniqueInput!, create: OrderItemCreateInput!, update: OrderItemUpdateInput!): OrderItem!
  deleteOrderItem(where: OrderItemWhereUniqueInput!): OrderItem
  deleteManyOrderItems(where: OrderItemWhereInput): BatchPayload!
  createOrderPad(data: OrderPadCreateInput!): OrderPad!
  updateOrderPad(data: OrderPadUpdateInput!, where: OrderPadWhereUniqueInput!): OrderPad
  updateManyOrderPads(data: OrderPadUpdateManyMutationInput!, where: OrderPadWhereInput): BatchPayload!
  upsertOrderPad(where: OrderPadWhereUniqueInput!, create: OrderPadCreateInput!, update: OrderPadUpdateInput!): OrderPad!
  deleteOrderPad(where: OrderPadWhereUniqueInput!): OrderPad
  deleteManyOrderPads(where: OrderPadWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createPermission(data: PermissionCreateInput!): Permission!
  updatePermission(data: PermissionUpdateInput!, where: PermissionWhereUniqueInput!): Permission
  updateManyPermissions(data: PermissionUpdateManyMutationInput!, where: PermissionWhereInput): BatchPayload!
  upsertPermission(where: PermissionWhereUniqueInput!, create: PermissionCreateInput!, update: PermissionUpdateInput!): Permission!
  deletePermission(where: PermissionWhereUniqueInput!): Permission
  deleteManyPermissions(where: PermissionWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createTable(data: TableCreateInput!): Table!
  updateTable(data: TableUpdateInput!, where: TableWhereUniqueInput!): Table
  updateManyTables(data: TableUpdateManyMutationInput!, where: TableWhereInput): BatchPayload!
  upsertTable(where: TableWhereUniqueInput!, create: TableCreateInput!, update: TableUpdateInput!): Table!
  deleteTable(where: TableWhereUniqueInput!): Table
  deleteManyTables(where: TableWhereInput): BatchPayload!
  createTableData(data: TableDataCreateInput!): TableData!
  updateTableData(data: TableDataUpdateInput!, where: TableDataWhereUniqueInput!): TableData
  updateManyTableDatas(data: TableDataUpdateManyMutationInput!, where: TableDataWhereInput): BatchPayload!
  upsertTableData(where: TableDataWhereUniqueInput!, create: TableDataCreateInput!, update: TableDataUpdateInput!): TableData!
  deleteTableData(where: TableDataWhereUniqueInput!): TableData
  deleteManyTableDatas(where: TableDataWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createWorkDay(data: WorkDayCreateInput!): WorkDay!
  updateWorkDay(data: WorkDayUpdateInput!, where: WorkDayWhereUniqueInput!): WorkDay
  updateManyWorkDays(data: WorkDayUpdateManyMutationInput!, where: WorkDayWhereInput): BatchPayload!
  upsertWorkDay(where: WorkDayWhereUniqueInput!, create: WorkDayCreateInput!, update: WorkDayUpdateInput!): WorkDay!
  deleteWorkDay(where: WorkDayWhereUniqueInput!): WorkDay
  deleteManyWorkDays(where: WorkDayWhereInput): BatchPayload!
  createWorkHour(data: WorkHourCreateInput!): WorkHour!
  updateWorkHour(data: WorkHourUpdateInput!, where: WorkHourWhereUniqueInput!): WorkHour
  updateManyWorkHours(data: WorkHourUpdateManyMutationInput!, where: WorkHourWhereInput): BatchPayload!
  upsertWorkHour(where: WorkHourWhereUniqueInput!, create: WorkHourCreateInput!, update: WorkHourUpdateInput!): WorkHour!
  deleteWorkHour(where: WorkHourWhereUniqueInput!): WorkHour
  deleteManyWorkHours(where: WorkHourWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type NCM {
  id: ID!
  identifier: String!
  description: String
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
}

type NCMConnection {
  pageInfo: PageInfo!
  edges: [NCMEdge]!
  aggregate: AggregateNCM!
}

input NCMCreateInput {
  id: ID
  identifier: String!
  description: String
  items: ItemCreateManyWithoutItemNCMInput
}

input NCMCreateOneWithoutItemsInput {
  create: NCMCreateWithoutItemsInput
  connect: NCMWhereUniqueInput
}

input NCMCreateWithoutItemsInput {
  id: ID
  identifier: String!
  description: String
}

type NCMEdge {
  node: NCM!
  cursor: String!
}

enum NCMOrderByInput {
  id_ASC
  id_DESC
  identifier_ASC
  identifier_DESC
  description_ASC
  description_DESC
}

type NCMPreviousValues {
  id: ID!
  identifier: String!
  description: String
}

type NCMSubscriptionPayload {
  mutation: MutationType!
  node: NCM
  updatedFields: [String!]
  previousValues: NCMPreviousValues
}

input NCMSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NCMWhereInput
  AND: [NCMSubscriptionWhereInput!]
  OR: [NCMSubscriptionWhereInput!]
  NOT: [NCMSubscriptionWhereInput!]
}

input NCMUpdateInput {
  identifier: String
  description: String
  items: ItemUpdateManyWithoutItemNCMInput
}

input NCMUpdateManyMutationInput {
  identifier: String
  description: String
}

input NCMUpdateOneWithoutItemsInput {
  create: NCMCreateWithoutItemsInput
  update: NCMUpdateWithoutItemsDataInput
  upsert: NCMUpsertWithoutItemsInput
  delete: Boolean
  disconnect: Boolean
  connect: NCMWhereUniqueInput
}

input NCMUpdateWithoutItemsDataInput {
  identifier: String
  description: String
}

input NCMUpsertWithoutItemsInput {
  update: NCMUpdateWithoutItemsDataInput!
  create: NCMCreateWithoutItemsInput!
}

input NCMWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  identifier: String
  identifier_not: String
  identifier_in: [String!]
  identifier_not_in: [String!]
  identifier_lt: String
  identifier_lte: String
  identifier_gt: String
  identifier_gte: String
  identifier_contains: String
  identifier_not_contains: String
  identifier_starts_with: String
  identifier_not_starts_with: String
  identifier_ends_with: String
  identifier_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  AND: [NCMWhereInput!]
  OR: [NCMWhereInput!]
  NOT: [NCMWhereInput!]
}

input NCMWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type Order {
  createdAt: DateTime!
  id: ID!
  workDay: WorkDay!
  block: Int!
  orderId: Int!
  bill: Bill
  orderItems(where: OrderItemWhereInput, orderBy: OrderItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderItem!]
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  modifiedOrders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
  workDay: WorkDayCreateOneWithoutOrdersInput!
  block: Int!
  orderId: Int!
  bill: BillCreateOneWithoutOrdersInput
  orderItems: OrderItemCreateManyWithoutOrderInput
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  modifiedOrders: OrderCreateManyInput
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

input OrderCreateManyInput {
  create: [OrderCreateInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateManyWithoutBillInput {
  create: [OrderCreateWithoutBillInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateManyWithoutWorkDayInput {
  create: [OrderCreateWithoutWorkDayInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateOneWithoutOrderItemsInput {
  create: OrderCreateWithoutOrderItemsInput
  connect: OrderWhereUniqueInput
}

input OrderCreateWithoutBillInput {
  id: ID
  workDay: WorkDayCreateOneWithoutOrdersInput!
  block: Int!
  orderId: Int!
  orderItems: OrderItemCreateManyWithoutOrderInput
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  modifiedOrders: OrderCreateManyInput
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

input OrderCreateWithoutOrderItemsInput {
  id: ID
  workDay: WorkDayCreateOneWithoutOrdersInput!
  block: Int!
  orderId: Int!
  bill: BillCreateOneWithoutOrdersInput
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  modifiedOrders: OrderCreateManyInput
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

input OrderCreateWithoutWorkDayInput {
  id: ID
  block: Int!
  orderId: Int!
  bill: BillCreateOneWithoutOrdersInput
  orderItems: OrderItemCreateManyWithoutOrderInput
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  modifiedOrders: OrderCreateManyInput
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

type OrderEdge {
  node: Order!
  cursor: String!
}

type OrderItem {
  id: ID!
  quantity: Int!
  item: Item!
  order: Order
  employee: Employee
}

type OrderItemConnection {
  pageInfo: PageInfo!
  edges: [OrderItemEdge]!
  aggregate: AggregateOrderItem!
}

input OrderItemCreateInput {
  id: ID
  quantity: Int!
  item: ItemCreateOneWithoutOrderItemInput!
  order: OrderCreateOneWithoutOrderItemsInput
  employee: EmployeeCreateOneWithoutItemsOrderedInput
}

input OrderItemCreateManyWithoutEmployeeInput {
  create: [OrderItemCreateWithoutEmployeeInput!]
  connect: [OrderItemWhereUniqueInput!]
}

input OrderItemCreateManyWithoutItemInput {
  create: [OrderItemCreateWithoutItemInput!]
  connect: [OrderItemWhereUniqueInput!]
}

input OrderItemCreateManyWithoutOrderInput {
  create: [OrderItemCreateWithoutOrderInput!]
  connect: [OrderItemWhereUniqueInput!]
}

input OrderItemCreateWithoutEmployeeInput {
  id: ID
  quantity: Int!
  item: ItemCreateOneWithoutOrderItemInput!
  order: OrderCreateOneWithoutOrderItemsInput
}

input OrderItemCreateWithoutItemInput {
  id: ID
  quantity: Int!
  order: OrderCreateOneWithoutOrderItemsInput
  employee: EmployeeCreateOneWithoutItemsOrderedInput
}

input OrderItemCreateWithoutOrderInput {
  id: ID
  quantity: Int!
  item: ItemCreateOneWithoutOrderItemInput!
  employee: EmployeeCreateOneWithoutItemsOrderedInput
}

type OrderItemEdge {
  node: OrderItem!
  cursor: String!
}

enum OrderItemOrderByInput {
  id_ASC
  id_DESC
  quantity_ASC
  quantity_DESC
}

type OrderItemPreviousValues {
  id: ID!
  quantity: Int!
}

input OrderItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  AND: [OrderItemScalarWhereInput!]
  OR: [OrderItemScalarWhereInput!]
  NOT: [OrderItemScalarWhereInput!]
}

type OrderItemSubscriptionPayload {
  mutation: MutationType!
  node: OrderItem
  updatedFields: [String!]
  previousValues: OrderItemPreviousValues
}

input OrderItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderItemWhereInput
  AND: [OrderItemSubscriptionWhereInput!]
  OR: [OrderItemSubscriptionWhereInput!]
  NOT: [OrderItemSubscriptionWhereInput!]
}

input OrderItemUpdateInput {
  quantity: Int
  item: ItemUpdateOneRequiredWithoutOrderItemInput
  order: OrderUpdateOneWithoutOrderItemsInput
  employee: EmployeeUpdateOneWithoutItemsOrderedInput
}

input OrderItemUpdateManyDataInput {
  quantity: Int
}

input OrderItemUpdateManyMutationInput {
  quantity: Int
}

input OrderItemUpdateManyWithoutEmployeeInput {
  create: [OrderItemCreateWithoutEmployeeInput!]
  delete: [OrderItemWhereUniqueInput!]
  connect: [OrderItemWhereUniqueInput!]
  set: [OrderItemWhereUniqueInput!]
  disconnect: [OrderItemWhereUniqueInput!]
  update: [OrderItemUpdateWithWhereUniqueWithoutEmployeeInput!]
  upsert: [OrderItemUpsertWithWhereUniqueWithoutEmployeeInput!]
  deleteMany: [OrderItemScalarWhereInput!]
  updateMany: [OrderItemUpdateManyWithWhereNestedInput!]
}

input OrderItemUpdateManyWithoutItemInput {
  create: [OrderItemCreateWithoutItemInput!]
  delete: [OrderItemWhereUniqueInput!]
  connect: [OrderItemWhereUniqueInput!]
  set: [OrderItemWhereUniqueInput!]
  disconnect: [OrderItemWhereUniqueInput!]
  update: [OrderItemUpdateWithWhereUniqueWithoutItemInput!]
  upsert: [OrderItemUpsertWithWhereUniqueWithoutItemInput!]
  deleteMany: [OrderItemScalarWhereInput!]
  updateMany: [OrderItemUpdateManyWithWhereNestedInput!]
}

input OrderItemUpdateManyWithoutOrderInput {
  create: [OrderItemCreateWithoutOrderInput!]
  delete: [OrderItemWhereUniqueInput!]
  connect: [OrderItemWhereUniqueInput!]
  set: [OrderItemWhereUniqueInput!]
  disconnect: [OrderItemWhereUniqueInput!]
  update: [OrderItemUpdateWithWhereUniqueWithoutOrderInput!]
  upsert: [OrderItemUpsertWithWhereUniqueWithoutOrderInput!]
  deleteMany: [OrderItemScalarWhereInput!]
  updateMany: [OrderItemUpdateManyWithWhereNestedInput!]
}

input OrderItemUpdateManyWithWhereNestedInput {
  where: OrderItemScalarWhereInput!
  data: OrderItemUpdateManyDataInput!
}

input OrderItemUpdateWithoutEmployeeDataInput {
  quantity: Int
  item: ItemUpdateOneRequiredWithoutOrderItemInput
  order: OrderUpdateOneWithoutOrderItemsInput
}

input OrderItemUpdateWithoutItemDataInput {
  quantity: Int
  order: OrderUpdateOneWithoutOrderItemsInput
  employee: EmployeeUpdateOneWithoutItemsOrderedInput
}

input OrderItemUpdateWithoutOrderDataInput {
  quantity: Int
  item: ItemUpdateOneRequiredWithoutOrderItemInput
  employee: EmployeeUpdateOneWithoutItemsOrderedInput
}

input OrderItemUpdateWithWhereUniqueWithoutEmployeeInput {
  where: OrderItemWhereUniqueInput!
  data: OrderItemUpdateWithoutEmployeeDataInput!
}

input OrderItemUpdateWithWhereUniqueWithoutItemInput {
  where: OrderItemWhereUniqueInput!
  data: OrderItemUpdateWithoutItemDataInput!
}

input OrderItemUpdateWithWhereUniqueWithoutOrderInput {
  where: OrderItemWhereUniqueInput!
  data: OrderItemUpdateWithoutOrderDataInput!
}

input OrderItemUpsertWithWhereUniqueWithoutEmployeeInput {
  where: OrderItemWhereUniqueInput!
  update: OrderItemUpdateWithoutEmployeeDataInput!
  create: OrderItemCreateWithoutEmployeeInput!
}

input OrderItemUpsertWithWhereUniqueWithoutItemInput {
  where: OrderItemWhereUniqueInput!
  update: OrderItemUpdateWithoutItemDataInput!
  create: OrderItemCreateWithoutItemInput!
}

input OrderItemUpsertWithWhereUniqueWithoutOrderInput {
  where: OrderItemWhereUniqueInput!
  update: OrderItemUpdateWithoutOrderDataInput!
  create: OrderItemCreateWithoutOrderInput!
}

input OrderItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  item: ItemWhereInput
  order: OrderWhereInput
  employee: EmployeeWhereInput
  AND: [OrderItemWhereInput!]
  OR: [OrderItemWhereInput!]
  NOT: [OrderItemWhereInput!]
}

input OrderItemWhereUniqueInput {
  id: ID
}

enum OrderOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  block_ASC
  block_DESC
  orderId_ASC
  orderId_DESC
  cancelled_ASC
  cancelled_DESC
  cancelationJustification_ASC
  cancelationJustification_DESC
  wasModified_ASC
  wasModified_DESC
  isEmployeeOrder_ASC
  isEmployeeOrder_DESC
  reuse_ASC
  reuse_DESC
  isToGo_ASC
  isToGo_DESC
  toGoReference_ASC
  toGoReference_DESC
}

type OrderPad {
  id: ID!
  workDay: WorkDay
  block: Int!
  firstOrderId: Int!
  lastOrderId: Int
  employee: Employee
  used: Boolean!
}

type OrderPadConnection {
  pageInfo: PageInfo!
  edges: [OrderPadEdge]!
  aggregate: AggregateOrderPad!
}

input OrderPadCreateInput {
  id: ID
  workDay: WorkDayCreateOneWithoutOrderPadsInput
  block: Int!
  firstOrderId: Int!
  lastOrderId: Int
  employee: EmployeeCreateOneWithoutOrderPadsInput
  used: Boolean!
}

input OrderPadCreateManyWithoutEmployeeInput {
  create: [OrderPadCreateWithoutEmployeeInput!]
  connect: [OrderPadWhereUniqueInput!]
}

input OrderPadCreateManyWithoutWorkDayInput {
  create: [OrderPadCreateWithoutWorkDayInput!]
  connect: [OrderPadWhereUniqueInput!]
}

input OrderPadCreateWithoutEmployeeInput {
  id: ID
  workDay: WorkDayCreateOneWithoutOrderPadsInput
  block: Int!
  firstOrderId: Int!
  lastOrderId: Int
  used: Boolean!
}

input OrderPadCreateWithoutWorkDayInput {
  id: ID
  block: Int!
  firstOrderId: Int!
  lastOrderId: Int
  employee: EmployeeCreateOneWithoutOrderPadsInput
  used: Boolean!
}

type OrderPadEdge {
  node: OrderPad!
  cursor: String!
}

enum OrderPadOrderByInput {
  id_ASC
  id_DESC
  block_ASC
  block_DESC
  firstOrderId_ASC
  firstOrderId_DESC
  lastOrderId_ASC
  lastOrderId_DESC
  used_ASC
  used_DESC
}

type OrderPadPreviousValues {
  id: ID!
  block: Int!
  firstOrderId: Int!
  lastOrderId: Int
  used: Boolean!
}

input OrderPadScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  block: Int
  block_not: Int
  block_in: [Int!]
  block_not_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_gt: Int
  block_gte: Int
  firstOrderId: Int
  firstOrderId_not: Int
  firstOrderId_in: [Int!]
  firstOrderId_not_in: [Int!]
  firstOrderId_lt: Int
  firstOrderId_lte: Int
  firstOrderId_gt: Int
  firstOrderId_gte: Int
  lastOrderId: Int
  lastOrderId_not: Int
  lastOrderId_in: [Int!]
  lastOrderId_not_in: [Int!]
  lastOrderId_lt: Int
  lastOrderId_lte: Int
  lastOrderId_gt: Int
  lastOrderId_gte: Int
  used: Boolean
  used_not: Boolean
  AND: [OrderPadScalarWhereInput!]
  OR: [OrderPadScalarWhereInput!]
  NOT: [OrderPadScalarWhereInput!]
}

type OrderPadSubscriptionPayload {
  mutation: MutationType!
  node: OrderPad
  updatedFields: [String!]
  previousValues: OrderPadPreviousValues
}

input OrderPadSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderPadWhereInput
  AND: [OrderPadSubscriptionWhereInput!]
  OR: [OrderPadSubscriptionWhereInput!]
  NOT: [OrderPadSubscriptionWhereInput!]
}

input OrderPadUpdateInput {
  workDay: WorkDayUpdateOneWithoutOrderPadsInput
  block: Int
  firstOrderId: Int
  lastOrderId: Int
  employee: EmployeeUpdateOneWithoutOrderPadsInput
  used: Boolean
}

input OrderPadUpdateManyDataInput {
  block: Int
  firstOrderId: Int
  lastOrderId: Int
  used: Boolean
}

input OrderPadUpdateManyMutationInput {
  block: Int
  firstOrderId: Int
  lastOrderId: Int
  used: Boolean
}

input OrderPadUpdateManyWithoutEmployeeInput {
  create: [OrderPadCreateWithoutEmployeeInput!]
  delete: [OrderPadWhereUniqueInput!]
  connect: [OrderPadWhereUniqueInput!]
  set: [OrderPadWhereUniqueInput!]
  disconnect: [OrderPadWhereUniqueInput!]
  update: [OrderPadUpdateWithWhereUniqueWithoutEmployeeInput!]
  upsert: [OrderPadUpsertWithWhereUniqueWithoutEmployeeInput!]
  deleteMany: [OrderPadScalarWhereInput!]
  updateMany: [OrderPadUpdateManyWithWhereNestedInput!]
}

input OrderPadUpdateManyWithoutWorkDayInput {
  create: [OrderPadCreateWithoutWorkDayInput!]
  delete: [OrderPadWhereUniqueInput!]
  connect: [OrderPadWhereUniqueInput!]
  set: [OrderPadWhereUniqueInput!]
  disconnect: [OrderPadWhereUniqueInput!]
  update: [OrderPadUpdateWithWhereUniqueWithoutWorkDayInput!]
  upsert: [OrderPadUpsertWithWhereUniqueWithoutWorkDayInput!]
  deleteMany: [OrderPadScalarWhereInput!]
  updateMany: [OrderPadUpdateManyWithWhereNestedInput!]
}

input OrderPadUpdateManyWithWhereNestedInput {
  where: OrderPadScalarWhereInput!
  data: OrderPadUpdateManyDataInput!
}

input OrderPadUpdateWithoutEmployeeDataInput {
  workDay: WorkDayUpdateOneWithoutOrderPadsInput
  block: Int
  firstOrderId: Int
  lastOrderId: Int
  used: Boolean
}

input OrderPadUpdateWithoutWorkDayDataInput {
  block: Int
  firstOrderId: Int
  lastOrderId: Int
  employee: EmployeeUpdateOneWithoutOrderPadsInput
  used: Boolean
}

input OrderPadUpdateWithWhereUniqueWithoutEmployeeInput {
  where: OrderPadWhereUniqueInput!
  data: OrderPadUpdateWithoutEmployeeDataInput!
}

input OrderPadUpdateWithWhereUniqueWithoutWorkDayInput {
  where: OrderPadWhereUniqueInput!
  data: OrderPadUpdateWithoutWorkDayDataInput!
}

input OrderPadUpsertWithWhereUniqueWithoutEmployeeInput {
  where: OrderPadWhereUniqueInput!
  update: OrderPadUpdateWithoutEmployeeDataInput!
  create: OrderPadCreateWithoutEmployeeInput!
}

input OrderPadUpsertWithWhereUniqueWithoutWorkDayInput {
  where: OrderPadWhereUniqueInput!
  update: OrderPadUpdateWithoutWorkDayDataInput!
  create: OrderPadCreateWithoutWorkDayInput!
}

input OrderPadWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  workDay: WorkDayWhereInput
  block: Int
  block_not: Int
  block_in: [Int!]
  block_not_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_gt: Int
  block_gte: Int
  firstOrderId: Int
  firstOrderId_not: Int
  firstOrderId_in: [Int!]
  firstOrderId_not_in: [Int!]
  firstOrderId_lt: Int
  firstOrderId_lte: Int
  firstOrderId_gt: Int
  firstOrderId_gte: Int
  lastOrderId: Int
  lastOrderId_not: Int
  lastOrderId_in: [Int!]
  lastOrderId_not_in: [Int!]
  lastOrderId_lt: Int
  lastOrderId_lte: Int
  lastOrderId_gt: Int
  lastOrderId_gte: Int
  employee: EmployeeWhereInput
  used: Boolean
  used_not: Boolean
  AND: [OrderPadWhereInput!]
  OR: [OrderPadWhereInput!]
  NOT: [OrderPadWhereInput!]
}

input OrderPadWhereUniqueInput {
  id: ID
}

type OrderPreviousValues {
  createdAt: DateTime!
  id: ID!
  block: Int!
  orderId: Int!
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

input OrderScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  block: Int
  block_not: Int
  block_in: [Int!]
  block_not_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_gt: Int
  block_gte: Int
  orderId: Int
  orderId_not: Int
  orderId_in: [Int!]
  orderId_not_in: [Int!]
  orderId_lt: Int
  orderId_lte: Int
  orderId_gt: Int
  orderId_gte: Int
  cancelled: Boolean
  cancelled_not: Boolean
  cancelationJustification: String
  cancelationJustification_not: String
  cancelationJustification_in: [String!]
  cancelationJustification_not_in: [String!]
  cancelationJustification_lt: String
  cancelationJustification_lte: String
  cancelationJustification_gt: String
  cancelationJustification_gte: String
  cancelationJustification_contains: String
  cancelationJustification_not_contains: String
  cancelationJustification_starts_with: String
  cancelationJustification_not_starts_with: String
  cancelationJustification_ends_with: String
  cancelationJustification_not_ends_with: String
  wasModified: Boolean
  wasModified_not: Boolean
  isEmployeeOrder: Boolean
  isEmployeeOrder_not: Boolean
  reuse: Boolean
  reuse_not: Boolean
  isToGo: Boolean
  isToGo_not: Boolean
  toGoReference: String
  toGoReference_not: String
  toGoReference_in: [String!]
  toGoReference_not_in: [String!]
  toGoReference_lt: String
  toGoReference_lte: String
  toGoReference_gt: String
  toGoReference_gte: String
  toGoReference_contains: String
  toGoReference_not_contains: String
  toGoReference_starts_with: String
  toGoReference_not_starts_with: String
  toGoReference_ends_with: String
  toGoReference_not_ends_with: String
  AND: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateDataInput {
  workDay: WorkDayUpdateOneRequiredWithoutOrdersInput
  block: Int
  orderId: Int
  bill: BillUpdateOneWithoutOrdersInput
  orderItems: OrderItemUpdateManyWithoutOrderInput
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  modifiedOrders: OrderUpdateManyInput
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

input OrderUpdateInput {
  workDay: WorkDayUpdateOneRequiredWithoutOrdersInput
  block: Int
  orderId: Int
  bill: BillUpdateOneWithoutOrdersInput
  orderItems: OrderItemUpdateManyWithoutOrderInput
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  modifiedOrders: OrderUpdateManyInput
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

input OrderUpdateManyDataInput {
  block: Int
  orderId: Int
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

input OrderUpdateManyInput {
  create: [OrderCreateInput!]
  update: [OrderUpdateWithWhereUniqueNestedInput!]
  upsert: [OrderUpsertWithWhereUniqueNestedInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyMutationInput {
  block: Int
  orderId: Int
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

input OrderUpdateManyWithoutBillInput {
  create: [OrderCreateWithoutBillInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutBillInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutBillInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyWithoutWorkDayInput {
  create: [OrderCreateWithoutWorkDayInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutWorkDayInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutWorkDayInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput!
  data: OrderUpdateManyDataInput!
}

input OrderUpdateOneWithoutOrderItemsInput {
  create: OrderCreateWithoutOrderItemsInput
  update: OrderUpdateWithoutOrderItemsDataInput
  upsert: OrderUpsertWithoutOrderItemsInput
  delete: Boolean
  disconnect: Boolean
  connect: OrderWhereUniqueInput
}

input OrderUpdateWithoutBillDataInput {
  workDay: WorkDayUpdateOneRequiredWithoutOrdersInput
  block: Int
  orderId: Int
  orderItems: OrderItemUpdateManyWithoutOrderInput
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  modifiedOrders: OrderUpdateManyInput
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

input OrderUpdateWithoutOrderItemsDataInput {
  workDay: WorkDayUpdateOneRequiredWithoutOrdersInput
  block: Int
  orderId: Int
  bill: BillUpdateOneWithoutOrdersInput
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  modifiedOrders: OrderUpdateManyInput
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

input OrderUpdateWithoutWorkDayDataInput {
  block: Int
  orderId: Int
  bill: BillUpdateOneWithoutOrdersInput
  orderItems: OrderItemUpdateManyWithoutOrderInput
  cancelled: Boolean
  cancelationJustification: String
  wasModified: Boolean
  modifiedOrders: OrderUpdateManyInput
  isEmployeeOrder: Boolean
  reuse: Boolean
  isToGo: Boolean
  toGoReference: String
}

input OrderUpdateWithWhereUniqueNestedInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateDataInput!
}

input OrderUpdateWithWhereUniqueWithoutBillInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutBillDataInput!
}

input OrderUpdateWithWhereUniqueWithoutWorkDayInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutWorkDayDataInput!
}

input OrderUpsertWithoutOrderItemsInput {
  update: OrderUpdateWithoutOrderItemsDataInput!
  create: OrderCreateWithoutOrderItemsInput!
}

input OrderUpsertWithWhereUniqueNestedInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateDataInput!
  create: OrderCreateInput!
}

input OrderUpsertWithWhereUniqueWithoutBillInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutBillDataInput!
  create: OrderCreateWithoutBillInput!
}

input OrderUpsertWithWhereUniqueWithoutWorkDayInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutWorkDayDataInput!
  create: OrderCreateWithoutWorkDayInput!
}

input OrderWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  workDay: WorkDayWhereInput
  block: Int
  block_not: Int
  block_in: [Int!]
  block_not_in: [Int!]
  block_lt: Int
  block_lte: Int
  block_gt: Int
  block_gte: Int
  orderId: Int
  orderId_not: Int
  orderId_in: [Int!]
  orderId_not_in: [Int!]
  orderId_lt: Int
  orderId_lte: Int
  orderId_gt: Int
  orderId_gte: Int
  bill: BillWhereInput
  orderItems_every: OrderItemWhereInput
  orderItems_some: OrderItemWhereInput
  orderItems_none: OrderItemWhereInput
  cancelled: Boolean
  cancelled_not: Boolean
  cancelationJustification: String
  cancelationJustification_not: String
  cancelationJustification_in: [String!]
  cancelationJustification_not_in: [String!]
  cancelationJustification_lt: String
  cancelationJustification_lte: String
  cancelationJustification_gt: String
  cancelationJustification_gte: String
  cancelationJustification_contains: String
  cancelationJustification_not_contains: String
  cancelationJustification_starts_with: String
  cancelationJustification_not_starts_with: String
  cancelationJustification_ends_with: String
  cancelationJustification_not_ends_with: String
  wasModified: Boolean
  wasModified_not: Boolean
  modifiedOrders_every: OrderWhereInput
  modifiedOrders_some: OrderWhereInput
  modifiedOrders_none: OrderWhereInput
  isEmployeeOrder: Boolean
  isEmployeeOrder_not: Boolean
  reuse: Boolean
  reuse_not: Boolean
  isToGo: Boolean
  isToGo_not: Boolean
  toGoReference: String
  toGoReference_not: String
  toGoReference_in: [String!]
  toGoReference_not_in: [String!]
  toGoReference_lt: String
  toGoReference_lte: String
  toGoReference_gt: String
  toGoReference_gte: String
  toGoReference_contains: String
  toGoReference_not_contains: String
  toGoReference_starts_with: String
  toGoReference_not_starts_with: String
  toGoReference_ends_with: String
  toGoReference_not_ends_with: String
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  createdAt: DateTime!
  id: ID!
  value: Float!
  paymentType: String!
  paymentTypeOption: String
  checkData: CheckData
  bill: Bill
  expense: Expense
  isActive: Boolean!
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  id: ID
  value: Float!
  paymentType: String!
  paymentTypeOption: String
  checkData: CheckDataCreateOneWithoutPaymentInput
  bill: BillCreateOneWithoutPaymentsInput
  expense: ExpenseCreateOneWithoutPaymentInput
  isActive: Boolean!
}

input PaymentCreateManyWithoutBillInput {
  create: [PaymentCreateWithoutBillInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateOneWithoutCheckDataInput {
  create: PaymentCreateWithoutCheckDataInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateOneWithoutExpenseInput {
  create: PaymentCreateWithoutExpenseInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutBillInput {
  id: ID
  value: Float!
  paymentType: String!
  paymentTypeOption: String
  checkData: CheckDataCreateOneWithoutPaymentInput
  expense: ExpenseCreateOneWithoutPaymentInput
  isActive: Boolean!
}

input PaymentCreateWithoutCheckDataInput {
  id: ID
  value: Float!
  paymentType: String!
  paymentTypeOption: String
  bill: BillCreateOneWithoutPaymentsInput
  expense: ExpenseCreateOneWithoutPaymentInput
  isActive: Boolean!
}

input PaymentCreateWithoutExpenseInput {
  id: ID
  value: Float!
  paymentType: String!
  paymentTypeOption: String
  checkData: CheckDataCreateOneWithoutPaymentInput
  bill: BillCreateOneWithoutPaymentsInput
  isActive: Boolean!
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  paymentType_ASC
  paymentType_DESC
  paymentTypeOption_ASC
  paymentTypeOption_DESC
  isActive_ASC
  isActive_DESC
}

type PaymentPreviousValues {
  createdAt: DateTime!
  id: ID!
  value: Float!
  paymentType: String!
  paymentTypeOption: String
  isActive: Boolean!
}

input PaymentScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  paymentType: String
  paymentType_not: String
  paymentType_in: [String!]
  paymentType_not_in: [String!]
  paymentType_lt: String
  paymentType_lte: String
  paymentType_gt: String
  paymentType_gte: String
  paymentType_contains: String
  paymentType_not_contains: String
  paymentType_starts_with: String
  paymentType_not_starts_with: String
  paymentType_ends_with: String
  paymentType_not_ends_with: String
  paymentTypeOption: String
  paymentTypeOption_not: String
  paymentTypeOption_in: [String!]
  paymentTypeOption_not_in: [String!]
  paymentTypeOption_lt: String
  paymentTypeOption_lte: String
  paymentTypeOption_gt: String
  paymentTypeOption_gte: String
  paymentTypeOption_contains: String
  paymentTypeOption_not_contains: String
  paymentTypeOption_starts_with: String
  paymentTypeOption_not_starts_with: String
  paymentTypeOption_ends_with: String
  paymentTypeOption_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  AND: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  NOT: [PaymentScalarWhereInput!]
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  value: Float
  paymentType: String
  paymentTypeOption: String
  checkData: CheckDataUpdateOneWithoutPaymentInput
  bill: BillUpdateOneWithoutPaymentsInput
  expense: ExpenseUpdateOneWithoutPaymentInput
  isActive: Boolean
}

input PaymentUpdateManyDataInput {
  value: Float
  paymentType: String
  paymentTypeOption: String
  isActive: Boolean
}

input PaymentUpdateManyMutationInput {
  value: Float
  paymentType: String
  paymentTypeOption: String
  isActive: Boolean
}

input PaymentUpdateManyWithoutBillInput {
  create: [PaymentCreateWithoutBillInput!]
  delete: [PaymentWhereUniqueInput!]
  connect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutBillInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutBillInput!]
  deleteMany: [PaymentScalarWhereInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
}

input PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput!
  data: PaymentUpdateManyDataInput!
}

input PaymentUpdateOneRequiredWithoutCheckDataInput {
  create: PaymentCreateWithoutCheckDataInput
  update: PaymentUpdateWithoutCheckDataDataInput
  upsert: PaymentUpsertWithoutCheckDataInput
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateOneWithoutExpenseInput {
  create: PaymentCreateWithoutExpenseInput
  update: PaymentUpdateWithoutExpenseDataInput
  upsert: PaymentUpsertWithoutExpenseInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutBillDataInput {
  value: Float
  paymentType: String
  paymentTypeOption: String
  checkData: CheckDataUpdateOneWithoutPaymentInput
  expense: ExpenseUpdateOneWithoutPaymentInput
  isActive: Boolean
}

input PaymentUpdateWithoutCheckDataDataInput {
  value: Float
  paymentType: String
  paymentTypeOption: String
  bill: BillUpdateOneWithoutPaymentsInput
  expense: ExpenseUpdateOneWithoutPaymentInput
  isActive: Boolean
}

input PaymentUpdateWithoutExpenseDataInput {
  value: Float
  paymentType: String
  paymentTypeOption: String
  checkData: CheckDataUpdateOneWithoutPaymentInput
  bill: BillUpdateOneWithoutPaymentsInput
  isActive: Boolean
}

input PaymentUpdateWithWhereUniqueWithoutBillInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutBillDataInput!
}

input PaymentUpsertWithoutCheckDataInput {
  update: PaymentUpdateWithoutCheckDataDataInput!
  create: PaymentCreateWithoutCheckDataInput!
}

input PaymentUpsertWithoutExpenseInput {
  update: PaymentUpdateWithoutExpenseDataInput!
  create: PaymentCreateWithoutExpenseInput!
}

input PaymentUpsertWithWhereUniqueWithoutBillInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutBillDataInput!
  create: PaymentCreateWithoutBillInput!
}

input PaymentWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Float
  value_not: Float
  value_in: [Float!]
  value_not_in: [Float!]
  value_lt: Float
  value_lte: Float
  value_gt: Float
  value_gte: Float
  paymentType: String
  paymentType_not: String
  paymentType_in: [String!]
  paymentType_not_in: [String!]
  paymentType_lt: String
  paymentType_lte: String
  paymentType_gt: String
  paymentType_gte: String
  paymentType_contains: String
  paymentType_not_contains: String
  paymentType_starts_with: String
  paymentType_not_starts_with: String
  paymentType_ends_with: String
  paymentType_not_ends_with: String
  paymentTypeOption: String
  paymentTypeOption_not: String
  paymentTypeOption_in: [String!]
  paymentTypeOption_not_in: [String!]
  paymentTypeOption_lt: String
  paymentTypeOption_lte: String
  paymentTypeOption_gt: String
  paymentTypeOption_gte: String
  paymentTypeOption_contains: String
  paymentTypeOption_not_contains: String
  paymentTypeOption_starts_with: String
  paymentTypeOption_not_starts_with: String
  paymentTypeOption_ends_with: String
  paymentTypeOption_not_ends_with: String
  checkData: CheckDataWhereInput
  bill: BillWhereInput
  expense: ExpenseWhereInput
  isActive: Boolean
  isActive_not: Boolean
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Permission {
  createdAt: DateTime!
  id: ID!
  user: User!
  establishment: Establishment!
  role: UserRole!
}

type PermissionConnection {
  pageInfo: PageInfo!
  edges: [PermissionEdge]!
  aggregate: AggregatePermission!
}

input PermissionCreateInput {
  id: ID
  user: UserCreateOneWithoutPermissionsInput!
  establishment: EstablishmentCreateOneWithoutPermissionsInput!
  role: UserRole!
}

input PermissionCreateManyWithoutEstablishmentInput {
  create: [PermissionCreateWithoutEstablishmentInput!]
  connect: [PermissionWhereUniqueInput!]
}

input PermissionCreateManyWithoutUserInput {
  create: [PermissionCreateWithoutUserInput!]
  connect: [PermissionWhereUniqueInput!]
}

input PermissionCreateWithoutEstablishmentInput {
  id: ID
  user: UserCreateOneWithoutPermissionsInput!
  role: UserRole!
}

input PermissionCreateWithoutUserInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutPermissionsInput!
  role: UserRole!
}

type PermissionEdge {
  node: Permission!
  cursor: String!
}

enum PermissionOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  role_ASC
  role_DESC
}

type PermissionPreviousValues {
  createdAt: DateTime!
  id: ID!
  role: UserRole!
}

input PermissionScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  role: UserRole
  role_not: UserRole
  role_in: [UserRole!]
  role_not_in: [UserRole!]
  AND: [PermissionScalarWhereInput!]
  OR: [PermissionScalarWhereInput!]
  NOT: [PermissionScalarWhereInput!]
}

type PermissionSubscriptionPayload {
  mutation: MutationType!
  node: Permission
  updatedFields: [String!]
  previousValues: PermissionPreviousValues
}

input PermissionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PermissionWhereInput
  AND: [PermissionSubscriptionWhereInput!]
  OR: [PermissionSubscriptionWhereInput!]
  NOT: [PermissionSubscriptionWhereInput!]
}

input PermissionUpdateInput {
  user: UserUpdateOneRequiredWithoutPermissionsInput
  establishment: EstablishmentUpdateOneRequiredWithoutPermissionsInput
  role: UserRole
}

input PermissionUpdateManyDataInput {
  role: UserRole
}

input PermissionUpdateManyMutationInput {
  role: UserRole
}

input PermissionUpdateManyWithoutEstablishmentInput {
  create: [PermissionCreateWithoutEstablishmentInput!]
  delete: [PermissionWhereUniqueInput!]
  connect: [PermissionWhereUniqueInput!]
  set: [PermissionWhereUniqueInput!]
  disconnect: [PermissionWhereUniqueInput!]
  update: [PermissionUpdateWithWhereUniqueWithoutEstablishmentInput!]
  upsert: [PermissionUpsertWithWhereUniqueWithoutEstablishmentInput!]
  deleteMany: [PermissionScalarWhereInput!]
  updateMany: [PermissionUpdateManyWithWhereNestedInput!]
}

input PermissionUpdateManyWithoutUserInput {
  create: [PermissionCreateWithoutUserInput!]
  delete: [PermissionWhereUniqueInput!]
  connect: [PermissionWhereUniqueInput!]
  set: [PermissionWhereUniqueInput!]
  disconnect: [PermissionWhereUniqueInput!]
  update: [PermissionUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [PermissionUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [PermissionScalarWhereInput!]
  updateMany: [PermissionUpdateManyWithWhereNestedInput!]
}

input PermissionUpdateManyWithWhereNestedInput {
  where: PermissionScalarWhereInput!
  data: PermissionUpdateManyDataInput!
}

input PermissionUpdateWithoutEstablishmentDataInput {
  user: UserUpdateOneRequiredWithoutPermissionsInput
  role: UserRole
}

input PermissionUpdateWithoutUserDataInput {
  establishment: EstablishmentUpdateOneRequiredWithoutPermissionsInput
  role: UserRole
}

input PermissionUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: PermissionWhereUniqueInput!
  data: PermissionUpdateWithoutEstablishmentDataInput!
}

input PermissionUpdateWithWhereUniqueWithoutUserInput {
  where: PermissionWhereUniqueInput!
  data: PermissionUpdateWithoutUserDataInput!
}

input PermissionUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: PermissionWhereUniqueInput!
  update: PermissionUpdateWithoutEstablishmentDataInput!
  create: PermissionCreateWithoutEstablishmentInput!
}

input PermissionUpsertWithWhereUniqueWithoutUserInput {
  where: PermissionWhereUniqueInput!
  update: PermissionUpdateWithoutUserDataInput!
  create: PermissionCreateWithoutUserInput!
}

input PermissionWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  establishment: EstablishmentWhereInput
  role: UserRole
  role_not: UserRole
  role_in: [UserRole!]
  role_not_in: [UserRole!]
  AND: [PermissionWhereInput!]
  OR: [PermissionWhereInput!]
  NOT: [PermissionWhereInput!]
}

input PermissionWhereUniqueInput {
  id: ID
}

type Product {
  id: ID!
  name: String!
  category: String!
  supplier: String!
  brand: String
  unit: String!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  name: String!
  category: String!
  supplier: String!
  brand: String
  unit: String!
}

input ProductCreateOneInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  category_ASC
  category_DESC
  supplier_ASC
  supplier_DESC
  brand_ASC
  brand_DESC
  unit_ASC
  unit_DESC
}

type ProductPreviousValues {
  id: ID!
  name: String!
  category: String!
  supplier: String!
  brand: String
  unit: String!
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateDataInput {
  name: String
  category: String
  supplier: String
  brand: String
  unit: String
}

input ProductUpdateInput {
  name: String
  category: String
  supplier: String
  brand: String
  unit: String
}

input ProductUpdateManyMutationInput {
  name: String
  category: String
  supplier: String
  brand: String
  unit: String
}

input ProductUpdateOneRequiredInput {
  create: ProductCreateInput
  update: ProductUpdateDataInput
  upsert: ProductUpsertNestedInput
  connect: ProductWhereUniqueInput
}

input ProductUpsertNestedInput {
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  supplier: String
  supplier_not: String
  supplier_in: [String!]
  supplier_not_in: [String!]
  supplier_lt: String
  supplier_lte: String
  supplier_gt: String
  supplier_gte: String
  supplier_contains: String
  supplier_not_contains: String
  supplier_starts_with: String
  supplier_not_starts_with: String
  supplier_ends_with: String
  supplier_not_ends_with: String
  brand: String
  brand_not: String
  brand_in: [String!]
  brand_not_in: [String!]
  brand_lt: String
  brand_lte: String
  brand_gt: String
  brand_gte: String
  brand_contains: String
  brand_not_contains: String
  brand_starts_with: String
  brand_not_starts_with: String
  brand_ends_with: String
  brand_not_ends_with: String
  unit: String
  unit_not: String
  unit_in: [String!]
  unit_not_in: [String!]
  unit_lt: String
  unit_lte: String
  unit_gt: String
  unit_gte: String
  unit_contains: String
  unit_not_contains: String
  unit_starts_with: String
  unit_not_starts_with: String
  unit_ends_with: String
  unit_not_ends_with: String
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  bill(where: BillWhereUniqueInput!): Bill
  bills(where: BillWhereInput, orderBy: BillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bill]!
  billsConnection(where: BillWhereInput, orderBy: BillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BillConnection!
  checkData(where: CheckDataWhereUniqueInput!): CheckData
  checkDatas(where: CheckDataWhereInput, orderBy: CheckDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CheckData]!
  checkDatasConnection(where: CheckDataWhereInput, orderBy: CheckDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CheckDataConnection!
  client(where: ClientWhereUniqueInput!): Client
  clients(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Client]!
  clientsConnection(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClientConnection!
  employee(where: EmployeeWhereUniqueInput!): Employee
  employees(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Employee]!
  employeesConnection(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmployeeConnection!
  establishment(where: EstablishmentWhereUniqueInput!): Establishment
  establishments(where: EstablishmentWhereInput, orderBy: EstablishmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Establishment]!
  establishmentsConnection(where: EstablishmentWhereInput, orderBy: EstablishmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EstablishmentConnection!
  expense(where: ExpenseWhereUniqueInput!): Expense
  expenses(where: ExpenseWhereInput, orderBy: ExpenseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Expense]!
  expensesConnection(where: ExpenseWhereInput, orderBy: ExpenseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExpenseConnection!
  expenseItem(where: ExpenseItemWhereUniqueInput!): ExpenseItem
  expenseItems(where: ExpenseItemWhereInput, orderBy: ExpenseItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExpenseItem]!
  expenseItemsConnection(where: ExpenseItemWhereInput, orderBy: ExpenseItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExpenseItemConnection!
  income(where: IncomeWhereUniqueInput!): Income
  incomes(where: IncomeWhereInput, orderBy: IncomeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Income]!
  incomesConnection(where: IncomeWhereInput, orderBy: IncomeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IncomeConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  nCM(where: NCMWhereUniqueInput!): NCM
  nCMs(where: NCMWhereInput, orderBy: NCMOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NCM]!
  nCMsConnection(where: NCMWhereInput, orderBy: NCMOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NCMConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  orderItem(where: OrderItemWhereUniqueInput!): OrderItem
  orderItems(where: OrderItemWhereInput, orderBy: OrderItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderItem]!
  orderItemsConnection(where: OrderItemWhereInput, orderBy: OrderItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderItemConnection!
  orderPad(where: OrderPadWhereUniqueInput!): OrderPad
  orderPads(where: OrderPadWhereInput, orderBy: OrderPadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderPad]!
  orderPadsConnection(where: OrderPadWhereInput, orderBy: OrderPadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderPadConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  permission(where: PermissionWhereUniqueInput!): Permission
  permissions(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Permission]!
  permissionsConnection(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PermissionConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  table(where: TableWhereUniqueInput!): Table
  tables(where: TableWhereInput, orderBy: TableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Table]!
  tablesConnection(where: TableWhereInput, orderBy: TableOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TableConnection!
  tableData(where: TableDataWhereUniqueInput!): TableData
  tableDatas(where: TableDataWhereInput, orderBy: TableDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TableData]!
  tableDatasConnection(where: TableDataWhereInput, orderBy: TableDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TableDataConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  workDay(where: WorkDayWhereUniqueInput!): WorkDay
  workDays(where: WorkDayWhereInput, orderBy: WorkDayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkDay]!
  workDaysConnection(where: WorkDayWhereInput, orderBy: WorkDayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkDayConnection!
  workHour(where: WorkHourWhereUniqueInput!): WorkHour
  workHours(where: WorkHourWhereInput, orderBy: WorkHourOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkHour]!
  workHoursConnection(where: WorkHourWhereInput, orderBy: WorkHourOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkHourConnection!
  node(id: ID!): Node
}

type Subscription {
  bill(where: BillSubscriptionWhereInput): BillSubscriptionPayload
  checkData(where: CheckDataSubscriptionWhereInput): CheckDataSubscriptionPayload
  client(where: ClientSubscriptionWhereInput): ClientSubscriptionPayload
  employee(where: EmployeeSubscriptionWhereInput): EmployeeSubscriptionPayload
  establishment(where: EstablishmentSubscriptionWhereInput): EstablishmentSubscriptionPayload
  expense(where: ExpenseSubscriptionWhereInput): ExpenseSubscriptionPayload
  expenseItem(where: ExpenseItemSubscriptionWhereInput): ExpenseItemSubscriptionPayload
  income(where: IncomeSubscriptionWhereInput): IncomeSubscriptionPayload
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  nCM(where: NCMSubscriptionWhereInput): NCMSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  orderItem(where: OrderItemSubscriptionWhereInput): OrderItemSubscriptionPayload
  orderPad(where: OrderPadSubscriptionWhereInput): OrderPadSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  permission(where: PermissionSubscriptionWhereInput): PermissionSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  table(where: TableSubscriptionWhereInput): TableSubscriptionPayload
  tableData(where: TableDataSubscriptionWhereInput): TableDataSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  workDay(where: WorkDaySubscriptionWhereInput): WorkDaySubscriptionPayload
  workHour(where: WorkHourSubscriptionWhereInput): WorkHourSubscriptionPayload
}

type Table {
  id: ID!
  tableNumber: Int!
  establishment: Establishment
  data(where: TableDataWhereInput, orderBy: TableDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TableData!]
}

type TableConnection {
  pageInfo: PageInfo!
  edges: [TableEdge]!
  aggregate: AggregateTable!
}

input TableCreateInput {
  id: ID
  tableNumber: Int!
  establishment: EstablishmentCreateOneWithoutTablesInput
  data: TableDataCreateManyWithoutTableInput
}

input TableCreateManyWithoutEstablishmentInput {
  create: [TableCreateWithoutEstablishmentInput!]
  connect: [TableWhereUniqueInput!]
}

input TableCreateOneWithoutDataInput {
  create: TableCreateWithoutDataInput
  connect: TableWhereUniqueInput
}

input TableCreateWithoutDataInput {
  id: ID
  tableNumber: Int!
  establishment: EstablishmentCreateOneWithoutTablesInput
}

input TableCreateWithoutEstablishmentInput {
  id: ID
  tableNumber: Int!
  data: TableDataCreateManyWithoutTableInput
}

type TableData {
  id: ID!
  totalOccupations: Int!
  table: Table!
  workDay: WorkDay!
  waiter: Employee
  bills(where: BillWhereInput, orderBy: BillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bill!]
}

type TableDataConnection {
  pageInfo: PageInfo!
  edges: [TableDataEdge]!
  aggregate: AggregateTableData!
}

input TableDataCreateInput {
  id: ID
  totalOccupations: Int!
  table: TableCreateOneWithoutDataInput!
  workDay: WorkDayCreateOneWithoutTablesInput!
  waiter: EmployeeCreateOneWithoutTablesInput
  bills: BillCreateManyWithoutTableDataInput
}

input TableDataCreateManyWithoutTableInput {
  create: [TableDataCreateWithoutTableInput!]
  connect: [TableDataWhereUniqueInput!]
}

input TableDataCreateManyWithoutWaiterInput {
  create: [TableDataCreateWithoutWaiterInput!]
  connect: [TableDataWhereUniqueInput!]
}

input TableDataCreateManyWithoutWorkDayInput {
  create: [TableDataCreateWithoutWorkDayInput!]
  connect: [TableDataWhereUniqueInput!]
}

input TableDataCreateOneWithoutBillsInput {
  create: TableDataCreateWithoutBillsInput
  connect: TableDataWhereUniqueInput
}

input TableDataCreateWithoutBillsInput {
  id: ID
  totalOccupations: Int!
  table: TableCreateOneWithoutDataInput!
  workDay: WorkDayCreateOneWithoutTablesInput!
  waiter: EmployeeCreateOneWithoutTablesInput
}

input TableDataCreateWithoutTableInput {
  id: ID
  totalOccupations: Int!
  workDay: WorkDayCreateOneWithoutTablesInput!
  waiter: EmployeeCreateOneWithoutTablesInput
  bills: BillCreateManyWithoutTableDataInput
}

input TableDataCreateWithoutWaiterInput {
  id: ID
  totalOccupations: Int!
  table: TableCreateOneWithoutDataInput!
  workDay: WorkDayCreateOneWithoutTablesInput!
  bills: BillCreateManyWithoutTableDataInput
}

input TableDataCreateWithoutWorkDayInput {
  id: ID
  totalOccupations: Int!
  table: TableCreateOneWithoutDataInput!
  waiter: EmployeeCreateOneWithoutTablesInput
  bills: BillCreateManyWithoutTableDataInput
}

type TableDataEdge {
  node: TableData!
  cursor: String!
}

enum TableDataOrderByInput {
  id_ASC
  id_DESC
  totalOccupations_ASC
  totalOccupations_DESC
}

type TableDataPreviousValues {
  id: ID!
  totalOccupations: Int!
}

input TableDataScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  totalOccupations: Int
  totalOccupations_not: Int
  totalOccupations_in: [Int!]
  totalOccupations_not_in: [Int!]
  totalOccupations_lt: Int
  totalOccupations_lte: Int
  totalOccupations_gt: Int
  totalOccupations_gte: Int
  AND: [TableDataScalarWhereInput!]
  OR: [TableDataScalarWhereInput!]
  NOT: [TableDataScalarWhereInput!]
}

type TableDataSubscriptionPayload {
  mutation: MutationType!
  node: TableData
  updatedFields: [String!]
  previousValues: TableDataPreviousValues
}

input TableDataSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TableDataWhereInput
  AND: [TableDataSubscriptionWhereInput!]
  OR: [TableDataSubscriptionWhereInput!]
  NOT: [TableDataSubscriptionWhereInput!]
}

input TableDataUpdateInput {
  totalOccupations: Int
  table: TableUpdateOneRequiredWithoutDataInput
  workDay: WorkDayUpdateOneRequiredWithoutTablesInput
  waiter: EmployeeUpdateOneWithoutTablesInput
  bills: BillUpdateManyWithoutTableDataInput
}

input TableDataUpdateManyDataInput {
  totalOccupations: Int
}

input TableDataUpdateManyMutationInput {
  totalOccupations: Int
}

input TableDataUpdateManyWithoutTableInput {
  create: [TableDataCreateWithoutTableInput!]
  delete: [TableDataWhereUniqueInput!]
  connect: [TableDataWhereUniqueInput!]
  set: [TableDataWhereUniqueInput!]
  disconnect: [TableDataWhereUniqueInput!]
  update: [TableDataUpdateWithWhereUniqueWithoutTableInput!]
  upsert: [TableDataUpsertWithWhereUniqueWithoutTableInput!]
  deleteMany: [TableDataScalarWhereInput!]
  updateMany: [TableDataUpdateManyWithWhereNestedInput!]
}

input TableDataUpdateManyWithoutWaiterInput {
  create: [TableDataCreateWithoutWaiterInput!]
  delete: [TableDataWhereUniqueInput!]
  connect: [TableDataWhereUniqueInput!]
  set: [TableDataWhereUniqueInput!]
  disconnect: [TableDataWhereUniqueInput!]
  update: [TableDataUpdateWithWhereUniqueWithoutWaiterInput!]
  upsert: [TableDataUpsertWithWhereUniqueWithoutWaiterInput!]
  deleteMany: [TableDataScalarWhereInput!]
  updateMany: [TableDataUpdateManyWithWhereNestedInput!]
}

input TableDataUpdateManyWithoutWorkDayInput {
  create: [TableDataCreateWithoutWorkDayInput!]
  delete: [TableDataWhereUniqueInput!]
  connect: [TableDataWhereUniqueInput!]
  set: [TableDataWhereUniqueInput!]
  disconnect: [TableDataWhereUniqueInput!]
  update: [TableDataUpdateWithWhereUniqueWithoutWorkDayInput!]
  upsert: [TableDataUpsertWithWhereUniqueWithoutWorkDayInput!]
  deleteMany: [TableDataScalarWhereInput!]
  updateMany: [TableDataUpdateManyWithWhereNestedInput!]
}

input TableDataUpdateManyWithWhereNestedInput {
  where: TableDataScalarWhereInput!
  data: TableDataUpdateManyDataInput!
}

input TableDataUpdateOneRequiredWithoutBillsInput {
  create: TableDataCreateWithoutBillsInput
  update: TableDataUpdateWithoutBillsDataInput
  upsert: TableDataUpsertWithoutBillsInput
  connect: TableDataWhereUniqueInput
}

input TableDataUpdateWithoutBillsDataInput {
  totalOccupations: Int
  table: TableUpdateOneRequiredWithoutDataInput
  workDay: WorkDayUpdateOneRequiredWithoutTablesInput
  waiter: EmployeeUpdateOneWithoutTablesInput
}

input TableDataUpdateWithoutTableDataInput {
  totalOccupations: Int
  workDay: WorkDayUpdateOneRequiredWithoutTablesInput
  waiter: EmployeeUpdateOneWithoutTablesInput
  bills: BillUpdateManyWithoutTableDataInput
}

input TableDataUpdateWithoutWaiterDataInput {
  totalOccupations: Int
  table: TableUpdateOneRequiredWithoutDataInput
  workDay: WorkDayUpdateOneRequiredWithoutTablesInput
  bills: BillUpdateManyWithoutTableDataInput
}

input TableDataUpdateWithoutWorkDayDataInput {
  totalOccupations: Int
  table: TableUpdateOneRequiredWithoutDataInput
  waiter: EmployeeUpdateOneWithoutTablesInput
  bills: BillUpdateManyWithoutTableDataInput
}

input TableDataUpdateWithWhereUniqueWithoutTableInput {
  where: TableDataWhereUniqueInput!
  data: TableDataUpdateWithoutTableDataInput!
}

input TableDataUpdateWithWhereUniqueWithoutWaiterInput {
  where: TableDataWhereUniqueInput!
  data: TableDataUpdateWithoutWaiterDataInput!
}

input TableDataUpdateWithWhereUniqueWithoutWorkDayInput {
  where: TableDataWhereUniqueInput!
  data: TableDataUpdateWithoutWorkDayDataInput!
}

input TableDataUpsertWithoutBillsInput {
  update: TableDataUpdateWithoutBillsDataInput!
  create: TableDataCreateWithoutBillsInput!
}

input TableDataUpsertWithWhereUniqueWithoutTableInput {
  where: TableDataWhereUniqueInput!
  update: TableDataUpdateWithoutTableDataInput!
  create: TableDataCreateWithoutTableInput!
}

input TableDataUpsertWithWhereUniqueWithoutWaiterInput {
  where: TableDataWhereUniqueInput!
  update: TableDataUpdateWithoutWaiterDataInput!
  create: TableDataCreateWithoutWaiterInput!
}

input TableDataUpsertWithWhereUniqueWithoutWorkDayInput {
  where: TableDataWhereUniqueInput!
  update: TableDataUpdateWithoutWorkDayDataInput!
  create: TableDataCreateWithoutWorkDayInput!
}

input TableDataWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  totalOccupations: Int
  totalOccupations_not: Int
  totalOccupations_in: [Int!]
  totalOccupations_not_in: [Int!]
  totalOccupations_lt: Int
  totalOccupations_lte: Int
  totalOccupations_gt: Int
  totalOccupations_gte: Int
  table: TableWhereInput
  workDay: WorkDayWhereInput
  waiter: EmployeeWhereInput
  bills_every: BillWhereInput
  bills_some: BillWhereInput
  bills_none: BillWhereInput
  AND: [TableDataWhereInput!]
  OR: [TableDataWhereInput!]
  NOT: [TableDataWhereInput!]
}

input TableDataWhereUniqueInput {
  id: ID
}

type TableEdge {
  node: Table!
  cursor: String!
}

enum TableOrderByInput {
  id_ASC
  id_DESC
  tableNumber_ASC
  tableNumber_DESC
}

type TablePreviousValues {
  id: ID!
  tableNumber: Int!
}

input TableScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  tableNumber: Int
  tableNumber_not: Int
  tableNumber_in: [Int!]
  tableNumber_not_in: [Int!]
  tableNumber_lt: Int
  tableNumber_lte: Int
  tableNumber_gt: Int
  tableNumber_gte: Int
  AND: [TableScalarWhereInput!]
  OR: [TableScalarWhereInput!]
  NOT: [TableScalarWhereInput!]
}

type TableSubscriptionPayload {
  mutation: MutationType!
  node: Table
  updatedFields: [String!]
  previousValues: TablePreviousValues
}

input TableSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TableWhereInput
  AND: [TableSubscriptionWhereInput!]
  OR: [TableSubscriptionWhereInput!]
  NOT: [TableSubscriptionWhereInput!]
}

input TableUpdateInput {
  tableNumber: Int
  establishment: EstablishmentUpdateOneWithoutTablesInput
  data: TableDataUpdateManyWithoutTableInput
}

input TableUpdateManyDataInput {
  tableNumber: Int
}

input TableUpdateManyMutationInput {
  tableNumber: Int
}

input TableUpdateManyWithoutEstablishmentInput {
  create: [TableCreateWithoutEstablishmentInput!]
  delete: [TableWhereUniqueInput!]
  connect: [TableWhereUniqueInput!]
  set: [TableWhereUniqueInput!]
  disconnect: [TableWhereUniqueInput!]
  update: [TableUpdateWithWhereUniqueWithoutEstablishmentInput!]
  upsert: [TableUpsertWithWhereUniqueWithoutEstablishmentInput!]
  deleteMany: [TableScalarWhereInput!]
  updateMany: [TableUpdateManyWithWhereNestedInput!]
}

input TableUpdateManyWithWhereNestedInput {
  where: TableScalarWhereInput!
  data: TableUpdateManyDataInput!
}

input TableUpdateOneRequiredWithoutDataInput {
  create: TableCreateWithoutDataInput
  update: TableUpdateWithoutDataDataInput
  upsert: TableUpsertWithoutDataInput
  connect: TableWhereUniqueInput
}

input TableUpdateWithoutDataDataInput {
  tableNumber: Int
  establishment: EstablishmentUpdateOneWithoutTablesInput
}

input TableUpdateWithoutEstablishmentDataInput {
  tableNumber: Int
  data: TableDataUpdateManyWithoutTableInput
}

input TableUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: TableWhereUniqueInput!
  data: TableUpdateWithoutEstablishmentDataInput!
}

input TableUpsertWithoutDataInput {
  update: TableUpdateWithoutDataDataInput!
  create: TableCreateWithoutDataInput!
}

input TableUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: TableWhereUniqueInput!
  update: TableUpdateWithoutEstablishmentDataInput!
  create: TableCreateWithoutEstablishmentInput!
}

input TableWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  tableNumber: Int
  tableNumber_not: Int
  tableNumber_in: [Int!]
  tableNumber_not_in: [Int!]
  tableNumber_lt: Int
  tableNumber_lte: Int
  tableNumber_gt: Int
  tableNumber_gte: Int
  establishment: EstablishmentWhereInput
  data_every: TableDataWhereInput
  data_some: TableDataWhereInput
  data_none: TableDataWhereInput
  AND: [TableWhereInput!]
  OR: [TableWhereInput!]
  NOT: [TableWhereInput!]
}

input TableWhereUniqueInput {
  id: ID
  tableNumber: Int
}

type User {
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
  permissions(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Permission!]
  email: String
  password: String
  responsibleWorkDays(where: WorkDayWhereInput, orderBy: WorkDayOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkDay!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  permissions: PermissionCreateManyWithoutUserInput
  email: String
  password: String
  responsibleWorkDays: WorkDayCreateManyWithoutUserResponsibleInput
}

input UserCreateOneWithoutPermissionsInput {
  create: UserCreateWithoutPermissionsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutResponsibleWorkDaysInput {
  create: UserCreateWithoutResponsibleWorkDaysInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutPermissionsInput {
  id: ID
  email: String
  password: String
  responsibleWorkDays: WorkDayCreateManyWithoutUserResponsibleInput
}

input UserCreateWithoutResponsibleWorkDaysInput {
  id: ID
  permissions: PermissionCreateManyWithoutUserInput
  email: String
  password: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
  email: String
  password: String
}

enum UserRole {
  EDITOR
  MODERATOR
  ADMIN
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  permissions: PermissionUpdateManyWithoutUserInput
  email: String
  password: String
  responsibleWorkDays: WorkDayUpdateManyWithoutUserResponsibleInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
}

input UserUpdateOneRequiredWithoutPermissionsInput {
  create: UserCreateWithoutPermissionsInput
  update: UserUpdateWithoutPermissionsDataInput
  upsert: UserUpsertWithoutPermissionsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutResponsibleWorkDaysInput {
  create: UserCreateWithoutResponsibleWorkDaysInput
  update: UserUpdateWithoutResponsibleWorkDaysDataInput
  upsert: UserUpsertWithoutResponsibleWorkDaysInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutPermissionsDataInput {
  email: String
  password: String
  responsibleWorkDays: WorkDayUpdateManyWithoutUserResponsibleInput
}

input UserUpdateWithoutResponsibleWorkDaysDataInput {
  permissions: PermissionUpdateManyWithoutUserInput
  email: String
  password: String
}

input UserUpsertWithoutPermissionsInput {
  update: UserUpdateWithoutPermissionsDataInput!
  create: UserCreateWithoutPermissionsInput!
}

input UserUpsertWithoutResponsibleWorkDaysInput {
  update: UserUpdateWithoutResponsibleWorkDaysDataInput!
  create: UserCreateWithoutResponsibleWorkDaysInput!
}

input UserWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  permissions_every: PermissionWhereInput
  permissions_some: PermissionWhereInput
  permissions_none: PermissionWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  responsibleWorkDays_every: WorkDayWhereInput
  responsibleWorkDays_some: WorkDayWhereInput
  responsibleWorkDays_none: WorkDayWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

enum WeekDay {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

type WorkDay {
  createdAt: DateTime!
  id: ID!
  establishment: Establishment
  isCurrent: Boolean!
  openDate: DateTime!
  closeDate: DateTime
  userResponsible: User
  tables(where: TableDataWhereInput, orderBy: TableDataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TableData!]
  incomes(where: IncomeWhereInput, orderBy: IncomeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Income!]
  bills(where: BillWhereInput, orderBy: BillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bill!]
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
  orderPads(where: OrderPadWhereInput, orderBy: OrderPadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrderPad!]
}

type WorkDayConnection {
  pageInfo: PageInfo!
  edges: [WorkDayEdge]!
  aggregate: AggregateWorkDay!
}

input WorkDayCreateInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutWorkingDaysInput
  isCurrent: Boolean!
  openDate: DateTime!
  closeDate: DateTime
  userResponsible: UserCreateOneWithoutResponsibleWorkDaysInput
  tables: TableDataCreateManyWithoutWorkDayInput
  incomes: IncomeCreateManyWithoutWorkDayInput
  bills: BillCreateManyWithoutWorkDayInput
  orders: OrderCreateManyWithoutWorkDayInput
  orderPads: OrderPadCreateManyWithoutWorkDayInput
}

input WorkDayCreateManyWithoutEstablishmentInput {
  create: [WorkDayCreateWithoutEstablishmentInput!]
  connect: [WorkDayWhereUniqueInput!]
}

input WorkDayCreateManyWithoutUserResponsibleInput {
  create: [WorkDayCreateWithoutUserResponsibleInput!]
  connect: [WorkDayWhereUniqueInput!]
}

input WorkDayCreateOneWithoutBillsInput {
  create: WorkDayCreateWithoutBillsInput
  connect: WorkDayWhereUniqueInput
}

input WorkDayCreateOneWithoutIncomesInput {
  create: WorkDayCreateWithoutIncomesInput
  connect: WorkDayWhereUniqueInput
}

input WorkDayCreateOneWithoutOrderPadsInput {
  create: WorkDayCreateWithoutOrderPadsInput
  connect: WorkDayWhereUniqueInput
}

input WorkDayCreateOneWithoutOrdersInput {
  create: WorkDayCreateWithoutOrdersInput
  connect: WorkDayWhereUniqueInput
}

input WorkDayCreateOneWithoutTablesInput {
  create: WorkDayCreateWithoutTablesInput
  connect: WorkDayWhereUniqueInput
}

input WorkDayCreateWithoutBillsInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutWorkingDaysInput
  isCurrent: Boolean!
  openDate: DateTime!
  closeDate: DateTime
  userResponsible: UserCreateOneWithoutResponsibleWorkDaysInput
  tables: TableDataCreateManyWithoutWorkDayInput
  incomes: IncomeCreateManyWithoutWorkDayInput
  orders: OrderCreateManyWithoutWorkDayInput
  orderPads: OrderPadCreateManyWithoutWorkDayInput
}

input WorkDayCreateWithoutEstablishmentInput {
  id: ID
  isCurrent: Boolean!
  openDate: DateTime!
  closeDate: DateTime
  userResponsible: UserCreateOneWithoutResponsibleWorkDaysInput
  tables: TableDataCreateManyWithoutWorkDayInput
  incomes: IncomeCreateManyWithoutWorkDayInput
  bills: BillCreateManyWithoutWorkDayInput
  orders: OrderCreateManyWithoutWorkDayInput
  orderPads: OrderPadCreateManyWithoutWorkDayInput
}

input WorkDayCreateWithoutIncomesInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutWorkingDaysInput
  isCurrent: Boolean!
  openDate: DateTime!
  closeDate: DateTime
  userResponsible: UserCreateOneWithoutResponsibleWorkDaysInput
  tables: TableDataCreateManyWithoutWorkDayInput
  bills: BillCreateManyWithoutWorkDayInput
  orders: OrderCreateManyWithoutWorkDayInput
  orderPads: OrderPadCreateManyWithoutWorkDayInput
}

input WorkDayCreateWithoutOrderPadsInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutWorkingDaysInput
  isCurrent: Boolean!
  openDate: DateTime!
  closeDate: DateTime
  userResponsible: UserCreateOneWithoutResponsibleWorkDaysInput
  tables: TableDataCreateManyWithoutWorkDayInput
  incomes: IncomeCreateManyWithoutWorkDayInput
  bills: BillCreateManyWithoutWorkDayInput
  orders: OrderCreateManyWithoutWorkDayInput
}

input WorkDayCreateWithoutOrdersInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutWorkingDaysInput
  isCurrent: Boolean!
  openDate: DateTime!
  closeDate: DateTime
  userResponsible: UserCreateOneWithoutResponsibleWorkDaysInput
  tables: TableDataCreateManyWithoutWorkDayInput
  incomes: IncomeCreateManyWithoutWorkDayInput
  bills: BillCreateManyWithoutWorkDayInput
  orderPads: OrderPadCreateManyWithoutWorkDayInput
}

input WorkDayCreateWithoutTablesInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutWorkingDaysInput
  isCurrent: Boolean!
  openDate: DateTime!
  closeDate: DateTime
  userResponsible: UserCreateOneWithoutResponsibleWorkDaysInput
  incomes: IncomeCreateManyWithoutWorkDayInput
  bills: BillCreateManyWithoutWorkDayInput
  orders: OrderCreateManyWithoutWorkDayInput
  orderPads: OrderPadCreateManyWithoutWorkDayInput
}

input WorkDayCreateWithoutUserResponsibleInput {
  id: ID
  establishment: EstablishmentCreateOneWithoutWorkingDaysInput
  isCurrent: Boolean!
  openDate: DateTime!
  closeDate: DateTime
  tables: TableDataCreateManyWithoutWorkDayInput
  incomes: IncomeCreateManyWithoutWorkDayInput
  bills: BillCreateManyWithoutWorkDayInput
  orders: OrderCreateManyWithoutWorkDayInput
  orderPads: OrderPadCreateManyWithoutWorkDayInput
}

type WorkDayEdge {
  node: WorkDay!
  cursor: String!
}

enum WorkDayOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  isCurrent_ASC
  isCurrent_DESC
  openDate_ASC
  openDate_DESC
  closeDate_ASC
  closeDate_DESC
}

type WorkDayPreviousValues {
  createdAt: DateTime!
  id: ID!
  isCurrent: Boolean!
  openDate: DateTime!
  closeDate: DateTime
}

input WorkDayScalarWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  isCurrent: Boolean
  isCurrent_not: Boolean
  openDate: DateTime
  openDate_not: DateTime
  openDate_in: [DateTime!]
  openDate_not_in: [DateTime!]
  openDate_lt: DateTime
  openDate_lte: DateTime
  openDate_gt: DateTime
  openDate_gte: DateTime
  closeDate: DateTime
  closeDate_not: DateTime
  closeDate_in: [DateTime!]
  closeDate_not_in: [DateTime!]
  closeDate_lt: DateTime
  closeDate_lte: DateTime
  closeDate_gt: DateTime
  closeDate_gte: DateTime
  AND: [WorkDayScalarWhereInput!]
  OR: [WorkDayScalarWhereInput!]
  NOT: [WorkDayScalarWhereInput!]
}

type WorkDaySubscriptionPayload {
  mutation: MutationType!
  node: WorkDay
  updatedFields: [String!]
  previousValues: WorkDayPreviousValues
}

input WorkDaySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkDayWhereInput
  AND: [WorkDaySubscriptionWhereInput!]
  OR: [WorkDaySubscriptionWhereInput!]
  NOT: [WorkDaySubscriptionWhereInput!]
}

input WorkDayUpdateInput {
  establishment: EstablishmentUpdateOneWithoutWorkingDaysInput
  isCurrent: Boolean
  openDate: DateTime
  closeDate: DateTime
  userResponsible: UserUpdateOneWithoutResponsibleWorkDaysInput
  tables: TableDataUpdateManyWithoutWorkDayInput
  incomes: IncomeUpdateManyWithoutWorkDayInput
  bills: BillUpdateManyWithoutWorkDayInput
  orders: OrderUpdateManyWithoutWorkDayInput
  orderPads: OrderPadUpdateManyWithoutWorkDayInput
}

input WorkDayUpdateManyDataInput {
  isCurrent: Boolean
  openDate: DateTime
  closeDate: DateTime
}

input WorkDayUpdateManyMutationInput {
  isCurrent: Boolean
  openDate: DateTime
  closeDate: DateTime
}

input WorkDayUpdateManyWithoutEstablishmentInput {
  create: [WorkDayCreateWithoutEstablishmentInput!]
  delete: [WorkDayWhereUniqueInput!]
  connect: [WorkDayWhereUniqueInput!]
  set: [WorkDayWhereUniqueInput!]
  disconnect: [WorkDayWhereUniqueInput!]
  update: [WorkDayUpdateWithWhereUniqueWithoutEstablishmentInput!]
  upsert: [WorkDayUpsertWithWhereUniqueWithoutEstablishmentInput!]
  deleteMany: [WorkDayScalarWhereInput!]
  updateMany: [WorkDayUpdateManyWithWhereNestedInput!]
}

input WorkDayUpdateManyWithoutUserResponsibleInput {
  create: [WorkDayCreateWithoutUserResponsibleInput!]
  delete: [WorkDayWhereUniqueInput!]
  connect: [WorkDayWhereUniqueInput!]
  set: [WorkDayWhereUniqueInput!]
  disconnect: [WorkDayWhereUniqueInput!]
  update: [WorkDayUpdateWithWhereUniqueWithoutUserResponsibleInput!]
  upsert: [WorkDayUpsertWithWhereUniqueWithoutUserResponsibleInput!]
  deleteMany: [WorkDayScalarWhereInput!]
  updateMany: [WorkDayUpdateManyWithWhereNestedInput!]
}

input WorkDayUpdateManyWithWhereNestedInput {
  where: WorkDayScalarWhereInput!
  data: WorkDayUpdateManyDataInput!
}

input WorkDayUpdateOneRequiredWithoutBillsInput {
  create: WorkDayCreateWithoutBillsInput
  update: WorkDayUpdateWithoutBillsDataInput
  upsert: WorkDayUpsertWithoutBillsInput
  connect: WorkDayWhereUniqueInput
}

input WorkDayUpdateOneRequiredWithoutOrdersInput {
  create: WorkDayCreateWithoutOrdersInput
  update: WorkDayUpdateWithoutOrdersDataInput
  upsert: WorkDayUpsertWithoutOrdersInput
  connect: WorkDayWhereUniqueInput
}

input WorkDayUpdateOneRequiredWithoutTablesInput {
  create: WorkDayCreateWithoutTablesInput
  update: WorkDayUpdateWithoutTablesDataInput
  upsert: WorkDayUpsertWithoutTablesInput
  connect: WorkDayWhereUniqueInput
}

input WorkDayUpdateOneWithoutIncomesInput {
  create: WorkDayCreateWithoutIncomesInput
  update: WorkDayUpdateWithoutIncomesDataInput
  upsert: WorkDayUpsertWithoutIncomesInput
  delete: Boolean
  disconnect: Boolean
  connect: WorkDayWhereUniqueInput
}

input WorkDayUpdateOneWithoutOrderPadsInput {
  create: WorkDayCreateWithoutOrderPadsInput
  update: WorkDayUpdateWithoutOrderPadsDataInput
  upsert: WorkDayUpsertWithoutOrderPadsInput
  delete: Boolean
  disconnect: Boolean
  connect: WorkDayWhereUniqueInput
}

input WorkDayUpdateWithoutBillsDataInput {
  establishment: EstablishmentUpdateOneWithoutWorkingDaysInput
  isCurrent: Boolean
  openDate: DateTime
  closeDate: DateTime
  userResponsible: UserUpdateOneWithoutResponsibleWorkDaysInput
  tables: TableDataUpdateManyWithoutWorkDayInput
  incomes: IncomeUpdateManyWithoutWorkDayInput
  orders: OrderUpdateManyWithoutWorkDayInput
  orderPads: OrderPadUpdateManyWithoutWorkDayInput
}

input WorkDayUpdateWithoutEstablishmentDataInput {
  isCurrent: Boolean
  openDate: DateTime
  closeDate: DateTime
  userResponsible: UserUpdateOneWithoutResponsibleWorkDaysInput
  tables: TableDataUpdateManyWithoutWorkDayInput
  incomes: IncomeUpdateManyWithoutWorkDayInput
  bills: BillUpdateManyWithoutWorkDayInput
  orders: OrderUpdateManyWithoutWorkDayInput
  orderPads: OrderPadUpdateManyWithoutWorkDayInput
}

input WorkDayUpdateWithoutIncomesDataInput {
  establishment: EstablishmentUpdateOneWithoutWorkingDaysInput
  isCurrent: Boolean
  openDate: DateTime
  closeDate: DateTime
  userResponsible: UserUpdateOneWithoutResponsibleWorkDaysInput
  tables: TableDataUpdateManyWithoutWorkDayInput
  bills: BillUpdateManyWithoutWorkDayInput
  orders: OrderUpdateManyWithoutWorkDayInput
  orderPads: OrderPadUpdateManyWithoutWorkDayInput
}

input WorkDayUpdateWithoutOrderPadsDataInput {
  establishment: EstablishmentUpdateOneWithoutWorkingDaysInput
  isCurrent: Boolean
  openDate: DateTime
  closeDate: DateTime
  userResponsible: UserUpdateOneWithoutResponsibleWorkDaysInput
  tables: TableDataUpdateManyWithoutWorkDayInput
  incomes: IncomeUpdateManyWithoutWorkDayInput
  bills: BillUpdateManyWithoutWorkDayInput
  orders: OrderUpdateManyWithoutWorkDayInput
}

input WorkDayUpdateWithoutOrdersDataInput {
  establishment: EstablishmentUpdateOneWithoutWorkingDaysInput
  isCurrent: Boolean
  openDate: DateTime
  closeDate: DateTime
  userResponsible: UserUpdateOneWithoutResponsibleWorkDaysInput
  tables: TableDataUpdateManyWithoutWorkDayInput
  incomes: IncomeUpdateManyWithoutWorkDayInput
  bills: BillUpdateManyWithoutWorkDayInput
  orderPads: OrderPadUpdateManyWithoutWorkDayInput
}

input WorkDayUpdateWithoutTablesDataInput {
  establishment: EstablishmentUpdateOneWithoutWorkingDaysInput
  isCurrent: Boolean
  openDate: DateTime
  closeDate: DateTime
  userResponsible: UserUpdateOneWithoutResponsibleWorkDaysInput
  incomes: IncomeUpdateManyWithoutWorkDayInput
  bills: BillUpdateManyWithoutWorkDayInput
  orders: OrderUpdateManyWithoutWorkDayInput
  orderPads: OrderPadUpdateManyWithoutWorkDayInput
}

input WorkDayUpdateWithoutUserResponsibleDataInput {
  establishment: EstablishmentUpdateOneWithoutWorkingDaysInput
  isCurrent: Boolean
  openDate: DateTime
  closeDate: DateTime
  tables: TableDataUpdateManyWithoutWorkDayInput
  incomes: IncomeUpdateManyWithoutWorkDayInput
  bills: BillUpdateManyWithoutWorkDayInput
  orders: OrderUpdateManyWithoutWorkDayInput
  orderPads: OrderPadUpdateManyWithoutWorkDayInput
}

input WorkDayUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: WorkDayWhereUniqueInput!
  data: WorkDayUpdateWithoutEstablishmentDataInput!
}

input WorkDayUpdateWithWhereUniqueWithoutUserResponsibleInput {
  where: WorkDayWhereUniqueInput!
  data: WorkDayUpdateWithoutUserResponsibleDataInput!
}

input WorkDayUpsertWithoutBillsInput {
  update: WorkDayUpdateWithoutBillsDataInput!
  create: WorkDayCreateWithoutBillsInput!
}

input WorkDayUpsertWithoutIncomesInput {
  update: WorkDayUpdateWithoutIncomesDataInput!
  create: WorkDayCreateWithoutIncomesInput!
}

input WorkDayUpsertWithoutOrderPadsInput {
  update: WorkDayUpdateWithoutOrderPadsDataInput!
  create: WorkDayCreateWithoutOrderPadsInput!
}

input WorkDayUpsertWithoutOrdersInput {
  update: WorkDayUpdateWithoutOrdersDataInput!
  create: WorkDayCreateWithoutOrdersInput!
}

input WorkDayUpsertWithoutTablesInput {
  update: WorkDayUpdateWithoutTablesDataInput!
  create: WorkDayCreateWithoutTablesInput!
}

input WorkDayUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: WorkDayWhereUniqueInput!
  update: WorkDayUpdateWithoutEstablishmentDataInput!
  create: WorkDayCreateWithoutEstablishmentInput!
}

input WorkDayUpsertWithWhereUniqueWithoutUserResponsibleInput {
  where: WorkDayWhereUniqueInput!
  update: WorkDayUpdateWithoutUserResponsibleDataInput!
  create: WorkDayCreateWithoutUserResponsibleInput!
}

input WorkDayWhereInput {
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  establishment: EstablishmentWhereInput
  isCurrent: Boolean
  isCurrent_not: Boolean
  openDate: DateTime
  openDate_not: DateTime
  openDate_in: [DateTime!]
  openDate_not_in: [DateTime!]
  openDate_lt: DateTime
  openDate_lte: DateTime
  openDate_gt: DateTime
  openDate_gte: DateTime
  closeDate: DateTime
  closeDate_not: DateTime
  closeDate_in: [DateTime!]
  closeDate_not_in: [DateTime!]
  closeDate_lt: DateTime
  closeDate_lte: DateTime
  closeDate_gt: DateTime
  closeDate_gte: DateTime
  userResponsible: UserWhereInput
  tables_every: TableDataWhereInput
  tables_some: TableDataWhereInput
  tables_none: TableDataWhereInput
  incomes_every: IncomeWhereInput
  incomes_some: IncomeWhereInput
  incomes_none: IncomeWhereInput
  bills_every: BillWhereInput
  bills_some: BillWhereInput
  bills_none: BillWhereInput
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  orderPads_every: OrderPadWhereInput
  orderPads_some: OrderPadWhereInput
  orderPads_none: OrderPadWhereInput
  AND: [WorkDayWhereInput!]
  OR: [WorkDayWhereInput!]
  NOT: [WorkDayWhereInput!]
}

input WorkDayWhereUniqueInput {
  id: ID
}

type WorkHour {
  id: ID!
  weekday: WeekDay!
  startTime: String
  endTime: String
  isDayOff: Boolean
  employee: Employee!
}

type WorkHourConnection {
  pageInfo: PageInfo!
  edges: [WorkHourEdge]!
  aggregate: AggregateWorkHour!
}

input WorkHourCreateInput {
  id: ID
  weekday: WeekDay!
  startTime: String
  endTime: String
  isDayOff: Boolean
  employee: EmployeeCreateOneWithoutWorkHoursInput!
}

input WorkHourCreateManyWithoutEmployeeInput {
  create: [WorkHourCreateWithoutEmployeeInput!]
  connect: [WorkHourWhereUniqueInput!]
}

input WorkHourCreateWithoutEmployeeInput {
  id: ID
  weekday: WeekDay!
  startTime: String
  endTime: String
  isDayOff: Boolean
}

type WorkHourEdge {
  node: WorkHour!
  cursor: String!
}

enum WorkHourOrderByInput {
  id_ASC
  id_DESC
  weekday_ASC
  weekday_DESC
  startTime_ASC
  startTime_DESC
  endTime_ASC
  endTime_DESC
  isDayOff_ASC
  isDayOff_DESC
}

type WorkHourPreviousValues {
  id: ID!
  weekday: WeekDay!
  startTime: String
  endTime: String
  isDayOff: Boolean
}

input WorkHourScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  weekday: WeekDay
  weekday_not: WeekDay
  weekday_in: [WeekDay!]
  weekday_not_in: [WeekDay!]
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  isDayOff: Boolean
  isDayOff_not: Boolean
  AND: [WorkHourScalarWhereInput!]
  OR: [WorkHourScalarWhereInput!]
  NOT: [WorkHourScalarWhereInput!]
}

type WorkHourSubscriptionPayload {
  mutation: MutationType!
  node: WorkHour
  updatedFields: [String!]
  previousValues: WorkHourPreviousValues
}

input WorkHourSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkHourWhereInput
  AND: [WorkHourSubscriptionWhereInput!]
  OR: [WorkHourSubscriptionWhereInput!]
  NOT: [WorkHourSubscriptionWhereInput!]
}

input WorkHourUpdateInput {
  weekday: WeekDay
  startTime: String
  endTime: String
  isDayOff: Boolean
  employee: EmployeeUpdateOneRequiredWithoutWorkHoursInput
}

input WorkHourUpdateManyDataInput {
  weekday: WeekDay
  startTime: String
  endTime: String
  isDayOff: Boolean
}

input WorkHourUpdateManyMutationInput {
  weekday: WeekDay
  startTime: String
  endTime: String
  isDayOff: Boolean
}

input WorkHourUpdateManyWithoutEmployeeInput {
  create: [WorkHourCreateWithoutEmployeeInput!]
  delete: [WorkHourWhereUniqueInput!]
  connect: [WorkHourWhereUniqueInput!]
  set: [WorkHourWhereUniqueInput!]
  disconnect: [WorkHourWhereUniqueInput!]
  update: [WorkHourUpdateWithWhereUniqueWithoutEmployeeInput!]
  upsert: [WorkHourUpsertWithWhereUniqueWithoutEmployeeInput!]
  deleteMany: [WorkHourScalarWhereInput!]
  updateMany: [WorkHourUpdateManyWithWhereNestedInput!]
}

input WorkHourUpdateManyWithWhereNestedInput {
  where: WorkHourScalarWhereInput!
  data: WorkHourUpdateManyDataInput!
}

input WorkHourUpdateWithoutEmployeeDataInput {
  weekday: WeekDay
  startTime: String
  endTime: String
  isDayOff: Boolean
}

input WorkHourUpdateWithWhereUniqueWithoutEmployeeInput {
  where: WorkHourWhereUniqueInput!
  data: WorkHourUpdateWithoutEmployeeDataInput!
}

input WorkHourUpsertWithWhereUniqueWithoutEmployeeInput {
  where: WorkHourWhereUniqueInput!
  update: WorkHourUpdateWithoutEmployeeDataInput!
  create: WorkHourCreateWithoutEmployeeInput!
}

input WorkHourWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  weekday: WeekDay
  weekday_not: WeekDay
  weekday_in: [WeekDay!]
  weekday_not_in: [WeekDay!]
  startTime: String
  startTime_not: String
  startTime_in: [String!]
  startTime_not_in: [String!]
  startTime_lt: String
  startTime_lte: String
  startTime_gt: String
  startTime_gte: String
  startTime_contains: String
  startTime_not_contains: String
  startTime_starts_with: String
  startTime_not_starts_with: String
  startTime_ends_with: String
  startTime_not_ends_with: String
  endTime: String
  endTime_not: String
  endTime_in: [String!]
  endTime_not_in: [String!]
  endTime_lt: String
  endTime_lte: String
  endTime_gt: String
  endTime_gte: String
  endTime_contains: String
  endTime_not_contains: String
  endTime_starts_with: String
  endTime_not_starts_with: String
  endTime_ends_with: String
  endTime_not_ends_with: String
  isDayOff: Boolean
  isDayOff_not: Boolean
  employee: EmployeeWhereInput
  AND: [WorkHourWhereInput!]
  OR: [WorkHourWhereInput!]
  NOT: [WorkHourWhereInput!]
}

input WorkHourWhereUniqueInput {
  id: ID
}
`
      }
    