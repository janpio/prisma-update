// Code generated by Prisma (prisma@1.34.12). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  bill: (where?: BillWhereInput) => Promise<boolean>;
  checkData: (where?: CheckDataWhereInput) => Promise<boolean>;
  client: (where?: ClientWhereInput) => Promise<boolean>;
  employee: (where?: EmployeeWhereInput) => Promise<boolean>;
  establishment: (where?: EstablishmentWhereInput) => Promise<boolean>;
  expense: (where?: ExpenseWhereInput) => Promise<boolean>;
  expenseItem: (where?: ExpenseItemWhereInput) => Promise<boolean>;
  income: (where?: IncomeWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  nCM: (where?: NCMWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  orderItem: (where?: OrderItemWhereInput) => Promise<boolean>;
  orderPad: (where?: OrderPadWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  permission: (where?: PermissionWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  table: (where?: TableWhereInput) => Promise<boolean>;
  tableData: (where?: TableDataWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  workDay: (where?: WorkDayWhereInput) => Promise<boolean>;
  workHour: (where?: WorkHourWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  bill: (where: BillWhereUniqueInput) => BillNullablePromise;
  bills: (args?: {
    where?: BillWhereInput;
    orderBy?: BillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bill>;
  billsConnection: (args?: {
    where?: BillWhereInput;
    orderBy?: BillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BillConnectionPromise;
  checkData: (where: CheckDataWhereUniqueInput) => CheckDataNullablePromise;
  checkDatas: (args?: {
    where?: CheckDataWhereInput;
    orderBy?: CheckDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CheckData>;
  checkDatasConnection: (args?: {
    where?: CheckDataWhereInput;
    orderBy?: CheckDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CheckDataConnectionPromise;
  client: (where: ClientWhereUniqueInput) => ClientNullablePromise;
  clients: (args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Client>;
  clientsConnection: (args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClientConnectionPromise;
  employee: (where: EmployeeWhereUniqueInput) => EmployeeNullablePromise;
  employees: (args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Employee>;
  employeesConnection: (args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EmployeeConnectionPromise;
  establishment: (
    where: EstablishmentWhereUniqueInput
  ) => EstablishmentNullablePromise;
  establishments: (args?: {
    where?: EstablishmentWhereInput;
    orderBy?: EstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Establishment>;
  establishmentsConnection: (args?: {
    where?: EstablishmentWhereInput;
    orderBy?: EstablishmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EstablishmentConnectionPromise;
  expense: (where: ExpenseWhereUniqueInput) => ExpenseNullablePromise;
  expenses: (args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Expense>;
  expensesConnection: (args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpenseConnectionPromise;
  expenseItem: (
    where: ExpenseItemWhereUniqueInput
  ) => ExpenseItemNullablePromise;
  expenseItems: (args?: {
    where?: ExpenseItemWhereInput;
    orderBy?: ExpenseItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ExpenseItem>;
  expenseItemsConnection: (args?: {
    where?: ExpenseItemWhereInput;
    orderBy?: ExpenseItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpenseItemConnectionPromise;
  income: (where: IncomeWhereUniqueInput) => IncomeNullablePromise;
  incomes: (args?: {
    where?: IncomeWhereInput;
    orderBy?: IncomeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Income>;
  incomesConnection: (args?: {
    where?: IncomeWhereInput;
    orderBy?: IncomeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => IncomeConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  nCM: (where: NCMWhereUniqueInput) => NCMNullablePromise;
  nCMs: (args?: {
    where?: NCMWhereInput;
    orderBy?: NCMOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<NCM>;
  nCMsConnection: (args?: {
    where?: NCMWhereInput;
    orderBy?: NCMOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NCMConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderNullablePromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  orderItem: (where: OrderItemWhereUniqueInput) => OrderItemNullablePromise;
  orderItems: (args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrderItem>;
  orderItemsConnection: (args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderItemConnectionPromise;
  orderPad: (where: OrderPadWhereUniqueInput) => OrderPadNullablePromise;
  orderPads: (args?: {
    where?: OrderPadWhereInput;
    orderBy?: OrderPadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<OrderPad>;
  orderPadsConnection: (args?: {
    where?: OrderPadWhereInput;
    orderBy?: OrderPadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderPadConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentNullablePromise;
  payments: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Payment>;
  paymentsConnection: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentConnectionPromise;
  permission: (where: PermissionWhereUniqueInput) => PermissionNullablePromise;
  permissions: (args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Permission>;
  permissionsConnection: (args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PermissionConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  table: (where: TableWhereUniqueInput) => TableNullablePromise;
  tables: (args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Table>;
  tablesConnection: (args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TableConnectionPromise;
  tableData: (where: TableDataWhereUniqueInput) => TableDataNullablePromise;
  tableDatas: (args?: {
    where?: TableDataWhereInput;
    orderBy?: TableDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TableData>;
  tableDatasConnection: (args?: {
    where?: TableDataWhereInput;
    orderBy?: TableDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TableDataConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  workDay: (where: WorkDayWhereUniqueInput) => WorkDayNullablePromise;
  workDays: (args?: {
    where?: WorkDayWhereInput;
    orderBy?: WorkDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WorkDay>;
  workDaysConnection: (args?: {
    where?: WorkDayWhereInput;
    orderBy?: WorkDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WorkDayConnectionPromise;
  workHour: (where: WorkHourWhereUniqueInput) => WorkHourNullablePromise;
  workHours: (args?: {
    where?: WorkHourWhereInput;
    orderBy?: WorkHourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<WorkHour>;
  workHoursConnection: (args?: {
    where?: WorkHourWhereInput;
    orderBy?: WorkHourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WorkHourConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBill: (data: BillCreateInput) => BillPromise;
  updateBill: (args: {
    data: BillUpdateInput;
    where: BillWhereUniqueInput;
  }) => BillPromise;
  updateManyBills: (args: {
    data: BillUpdateManyMutationInput;
    where?: BillWhereInput;
  }) => BatchPayloadPromise;
  upsertBill: (args: {
    where: BillWhereUniqueInput;
    create: BillCreateInput;
    update: BillUpdateInput;
  }) => BillPromise;
  deleteBill: (where: BillWhereUniqueInput) => BillPromise;
  deleteManyBills: (where?: BillWhereInput) => BatchPayloadPromise;
  createCheckData: (data: CheckDataCreateInput) => CheckDataPromise;
  updateCheckData: (args: {
    data: CheckDataUpdateInput;
    where: CheckDataWhereUniqueInput;
  }) => CheckDataPromise;
  updateManyCheckDatas: (args: {
    data: CheckDataUpdateManyMutationInput;
    where?: CheckDataWhereInput;
  }) => BatchPayloadPromise;
  upsertCheckData: (args: {
    where: CheckDataWhereUniqueInput;
    create: CheckDataCreateInput;
    update: CheckDataUpdateInput;
  }) => CheckDataPromise;
  deleteCheckData: (where: CheckDataWhereUniqueInput) => CheckDataPromise;
  deleteManyCheckDatas: (where?: CheckDataWhereInput) => BatchPayloadPromise;
  createClient: (data: ClientCreateInput) => ClientPromise;
  updateClient: (args: {
    data: ClientUpdateInput;
    where: ClientWhereUniqueInput;
  }) => ClientPromise;
  updateManyClients: (args: {
    data: ClientUpdateManyMutationInput;
    where?: ClientWhereInput;
  }) => BatchPayloadPromise;
  upsertClient: (args: {
    where: ClientWhereUniqueInput;
    create: ClientCreateInput;
    update: ClientUpdateInput;
  }) => ClientPromise;
  deleteClient: (where: ClientWhereUniqueInput) => ClientPromise;
  deleteManyClients: (where?: ClientWhereInput) => BatchPayloadPromise;
  createEmployee: (data: EmployeeCreateInput) => EmployeePromise;
  updateEmployee: (args: {
    data: EmployeeUpdateInput;
    where: EmployeeWhereUniqueInput;
  }) => EmployeePromise;
  updateManyEmployees: (args: {
    data: EmployeeUpdateManyMutationInput;
    where?: EmployeeWhereInput;
  }) => BatchPayloadPromise;
  upsertEmployee: (args: {
    where: EmployeeWhereUniqueInput;
    create: EmployeeCreateInput;
    update: EmployeeUpdateInput;
  }) => EmployeePromise;
  deleteEmployee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  deleteManyEmployees: (where?: EmployeeWhereInput) => BatchPayloadPromise;
  createEstablishment: (data: EstablishmentCreateInput) => EstablishmentPromise;
  updateEstablishment: (args: {
    data: EstablishmentUpdateInput;
    where: EstablishmentWhereUniqueInput;
  }) => EstablishmentPromise;
  updateManyEstablishments: (args: {
    data: EstablishmentUpdateManyMutationInput;
    where?: EstablishmentWhereInput;
  }) => BatchPayloadPromise;
  upsertEstablishment: (args: {
    where: EstablishmentWhereUniqueInput;
    create: EstablishmentCreateInput;
    update: EstablishmentUpdateInput;
  }) => EstablishmentPromise;
  deleteEstablishment: (
    where: EstablishmentWhereUniqueInput
  ) => EstablishmentPromise;
  deleteManyEstablishments: (
    where?: EstablishmentWhereInput
  ) => BatchPayloadPromise;
  createExpense: (data: ExpenseCreateInput) => ExpensePromise;
  updateExpense: (args: {
    data: ExpenseUpdateInput;
    where: ExpenseWhereUniqueInput;
  }) => ExpensePromise;
  updateManyExpenses: (args: {
    data: ExpenseUpdateManyMutationInput;
    where?: ExpenseWhereInput;
  }) => BatchPayloadPromise;
  upsertExpense: (args: {
    where: ExpenseWhereUniqueInput;
    create: ExpenseCreateInput;
    update: ExpenseUpdateInput;
  }) => ExpensePromise;
  deleteExpense: (where: ExpenseWhereUniqueInput) => ExpensePromise;
  deleteManyExpenses: (where?: ExpenseWhereInput) => BatchPayloadPromise;
  createExpenseItem: (data: ExpenseItemCreateInput) => ExpenseItemPromise;
  updateExpenseItem: (args: {
    data: ExpenseItemUpdateInput;
    where: ExpenseItemWhereUniqueInput;
  }) => ExpenseItemPromise;
  updateManyExpenseItems: (args: {
    data: ExpenseItemUpdateManyMutationInput;
    where?: ExpenseItemWhereInput;
  }) => BatchPayloadPromise;
  upsertExpenseItem: (args: {
    where: ExpenseItemWhereUniqueInput;
    create: ExpenseItemCreateInput;
    update: ExpenseItemUpdateInput;
  }) => ExpenseItemPromise;
  deleteExpenseItem: (where: ExpenseItemWhereUniqueInput) => ExpenseItemPromise;
  deleteManyExpenseItems: (
    where?: ExpenseItemWhereInput
  ) => BatchPayloadPromise;
  createIncome: (data: IncomeCreateInput) => IncomePromise;
  updateIncome: (args: {
    data: IncomeUpdateInput;
    where: IncomeWhereUniqueInput;
  }) => IncomePromise;
  updateManyIncomes: (args: {
    data: IncomeUpdateManyMutationInput;
    where?: IncomeWhereInput;
  }) => BatchPayloadPromise;
  upsertIncome: (args: {
    where: IncomeWhereUniqueInput;
    create: IncomeCreateInput;
    update: IncomeUpdateInput;
  }) => IncomePromise;
  deleteIncome: (where: IncomeWhereUniqueInput) => IncomePromise;
  deleteManyIncomes: (where?: IncomeWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createNCM: (data: NCMCreateInput) => NCMPromise;
  updateNCM: (args: {
    data: NCMUpdateInput;
    where: NCMWhereUniqueInput;
  }) => NCMPromise;
  updateManyNCMs: (args: {
    data: NCMUpdateManyMutationInput;
    where?: NCMWhereInput;
  }) => BatchPayloadPromise;
  upsertNCM: (args: {
    where: NCMWhereUniqueInput;
    create: NCMCreateInput;
    update: NCMUpdateInput;
  }) => NCMPromise;
  deleteNCM: (where: NCMWhereUniqueInput) => NCMPromise;
  deleteManyNCMs: (where?: NCMWhereInput) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createOrderItem: (data: OrderItemCreateInput) => OrderItemPromise;
  updateOrderItem: (args: {
    data: OrderItemUpdateInput;
    where: OrderItemWhereUniqueInput;
  }) => OrderItemPromise;
  updateManyOrderItems: (args: {
    data: OrderItemUpdateManyMutationInput;
    where?: OrderItemWhereInput;
  }) => BatchPayloadPromise;
  upsertOrderItem: (args: {
    where: OrderItemWhereUniqueInput;
    create: OrderItemCreateInput;
    update: OrderItemUpdateInput;
  }) => OrderItemPromise;
  deleteOrderItem: (where: OrderItemWhereUniqueInput) => OrderItemPromise;
  deleteManyOrderItems: (where?: OrderItemWhereInput) => BatchPayloadPromise;
  createOrderPad: (data: OrderPadCreateInput) => OrderPadPromise;
  updateOrderPad: (args: {
    data: OrderPadUpdateInput;
    where: OrderPadWhereUniqueInput;
  }) => OrderPadPromise;
  updateManyOrderPads: (args: {
    data: OrderPadUpdateManyMutationInput;
    where?: OrderPadWhereInput;
  }) => BatchPayloadPromise;
  upsertOrderPad: (args: {
    where: OrderPadWhereUniqueInput;
    create: OrderPadCreateInput;
    update: OrderPadUpdateInput;
  }) => OrderPadPromise;
  deleteOrderPad: (where: OrderPadWhereUniqueInput) => OrderPadPromise;
  deleteManyOrderPads: (where?: OrderPadWhereInput) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (args: {
    data: PaymentUpdateInput;
    where: PaymentWhereUniqueInput;
  }) => PaymentPromise;
  updateManyPayments: (args: {
    data: PaymentUpdateManyMutationInput;
    where?: PaymentWhereInput;
  }) => BatchPayloadPromise;
  upsertPayment: (args: {
    where: PaymentWhereUniqueInput;
    create: PaymentCreateInput;
    update: PaymentUpdateInput;
  }) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createPermission: (data: PermissionCreateInput) => PermissionPromise;
  updatePermission: (args: {
    data: PermissionUpdateInput;
    where: PermissionWhereUniqueInput;
  }) => PermissionPromise;
  updateManyPermissions: (args: {
    data: PermissionUpdateManyMutationInput;
    where?: PermissionWhereInput;
  }) => BatchPayloadPromise;
  upsertPermission: (args: {
    where: PermissionWhereUniqueInput;
    create: PermissionCreateInput;
    update: PermissionUpdateInput;
  }) => PermissionPromise;
  deletePermission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  deleteManyPermissions: (where?: PermissionWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createTable: (data: TableCreateInput) => TablePromise;
  updateTable: (args: {
    data: TableUpdateInput;
    where: TableWhereUniqueInput;
  }) => TablePromise;
  updateManyTables: (args: {
    data: TableUpdateManyMutationInput;
    where?: TableWhereInput;
  }) => BatchPayloadPromise;
  upsertTable: (args: {
    where: TableWhereUniqueInput;
    create: TableCreateInput;
    update: TableUpdateInput;
  }) => TablePromise;
  deleteTable: (where: TableWhereUniqueInput) => TablePromise;
  deleteManyTables: (where?: TableWhereInput) => BatchPayloadPromise;
  createTableData: (data: TableDataCreateInput) => TableDataPromise;
  updateTableData: (args: {
    data: TableDataUpdateInput;
    where: TableDataWhereUniqueInput;
  }) => TableDataPromise;
  updateManyTableDatas: (args: {
    data: TableDataUpdateManyMutationInput;
    where?: TableDataWhereInput;
  }) => BatchPayloadPromise;
  upsertTableData: (args: {
    where: TableDataWhereUniqueInput;
    create: TableDataCreateInput;
    update: TableDataUpdateInput;
  }) => TableDataPromise;
  deleteTableData: (where: TableDataWhereUniqueInput) => TableDataPromise;
  deleteManyTableDatas: (where?: TableDataWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createWorkDay: (data: WorkDayCreateInput) => WorkDayPromise;
  updateWorkDay: (args: {
    data: WorkDayUpdateInput;
    where: WorkDayWhereUniqueInput;
  }) => WorkDayPromise;
  updateManyWorkDays: (args: {
    data: WorkDayUpdateManyMutationInput;
    where?: WorkDayWhereInput;
  }) => BatchPayloadPromise;
  upsertWorkDay: (args: {
    where: WorkDayWhereUniqueInput;
    create: WorkDayCreateInput;
    update: WorkDayUpdateInput;
  }) => WorkDayPromise;
  deleteWorkDay: (where: WorkDayWhereUniqueInput) => WorkDayPromise;
  deleteManyWorkDays: (where?: WorkDayWhereInput) => BatchPayloadPromise;
  createWorkHour: (data: WorkHourCreateInput) => WorkHourPromise;
  updateWorkHour: (args: {
    data: WorkHourUpdateInput;
    where: WorkHourWhereUniqueInput;
  }) => WorkHourPromise;
  updateManyWorkHours: (args: {
    data: WorkHourUpdateManyMutationInput;
    where?: WorkHourWhereInput;
  }) => BatchPayloadPromise;
  upsertWorkHour: (args: {
    where: WorkHourWhereUniqueInput;
    create: WorkHourCreateInput;
    update: WorkHourUpdateInput;
  }) => WorkHourPromise;
  deleteWorkHour: (where: WorkHourWhereUniqueInput) => WorkHourPromise;
  deleteManyWorkHours: (where?: WorkHourWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  bill: (
    where?: BillSubscriptionWhereInput
  ) => BillSubscriptionPayloadSubscription;
  checkData: (
    where?: CheckDataSubscriptionWhereInput
  ) => CheckDataSubscriptionPayloadSubscription;
  client: (
    where?: ClientSubscriptionWhereInput
  ) => ClientSubscriptionPayloadSubscription;
  employee: (
    where?: EmployeeSubscriptionWhereInput
  ) => EmployeeSubscriptionPayloadSubscription;
  establishment: (
    where?: EstablishmentSubscriptionWhereInput
  ) => EstablishmentSubscriptionPayloadSubscription;
  expense: (
    where?: ExpenseSubscriptionWhereInput
  ) => ExpenseSubscriptionPayloadSubscription;
  expenseItem: (
    where?: ExpenseItemSubscriptionWhereInput
  ) => ExpenseItemSubscriptionPayloadSubscription;
  income: (
    where?: IncomeSubscriptionWhereInput
  ) => IncomeSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  nCM: (
    where?: NCMSubscriptionWhereInput
  ) => NCMSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  orderItem: (
    where?: OrderItemSubscriptionWhereInput
  ) => OrderItemSubscriptionPayloadSubscription;
  orderPad: (
    where?: OrderPadSubscriptionWhereInput
  ) => OrderPadSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  permission: (
    where?: PermissionSubscriptionWhereInput
  ) => PermissionSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  table: (
    where?: TableSubscriptionWhereInput
  ) => TableSubscriptionPayloadSubscription;
  tableData: (
    where?: TableDataSubscriptionWhereInput
  ) => TableDataSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  workDay: (
    where?: WorkDaySubscriptionWhereInput
  ) => WorkDaySubscriptionPayloadSubscription;
  workHour: (
    where?: WorkHourSubscriptionWhereInput
  ) => WorkHourSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserRole = "EDITOR" | "MODERATOR" | "ADMIN";

export type WeekDay =
  | "MONDAY"
  | "TUESDAY"
  | "WEDNESDAY"
  | "THURSDAY"
  | "FRIDAY"
  | "SATURDAY"
  | "SUNDAY";

export type BillStatus = "PAID" | "OPEN" | "CLOSED";

export type WorkDayOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "isCurrent_ASC"
  | "isCurrent_DESC"
  | "openDate_ASC"
  | "openDate_DESC"
  | "closeDate_ASC"
  | "closeDate_DESC";

export type PermissionOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "role_ASC"
  | "role_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "itemId_ASC"
  | "itemId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "priceToGo_ASC"
  | "priceToGo_DESC"
  | "employeePrice_ASC"
  | "employeePrice_DESC"
  | "category_ASC"
  | "category_DESC"
  | "canTakeToGo_ASC"
  | "canTakeToGo_DESC"
  | "isActive_ASC"
  | "isActive_DESC"
  | "hasTaxSubstitution_ASC"
  | "hasTaxSubstitution_DESC";

export type OrderItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "quantity_ASC"
  | "quantity_DESC";

export type OrderOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "block_ASC"
  | "block_DESC"
  | "orderId_ASC"
  | "orderId_DESC"
  | "cancelled_ASC"
  | "cancelled_DESC"
  | "cancelationJustification_ASC"
  | "cancelationJustification_DESC"
  | "wasModified_ASC"
  | "wasModified_DESC"
  | "isEmployeeOrder_ASC"
  | "isEmployeeOrder_DESC"
  | "reuse_ASC"
  | "reuse_DESC"
  | "isToGo_ASC"
  | "isToGo_DESC"
  | "toGoReference_ASC"
  | "toGoReference_DESC";

export type TableDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "totalOccupations_ASC"
  | "totalOccupations_DESC";

export type BillOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "closedAt_ASC"
  | "closedAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "discount_ASC"
  | "discount_DESC"
  | "discountReason_ASC"
  | "discountReason_DESC"
  | "value_ASC"
  | "value_DESC"
  | "wasReopen_ASC"
  | "wasReopen_DESC"
  | "registered_ASC"
  | "registered_DESC";

export type OrderPadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "block_ASC"
  | "block_DESC"
  | "firstOrderId_ASC"
  | "firstOrderId_DESC"
  | "lastOrderId_ASC"
  | "lastOrderId_DESC"
  | "used_ASC"
  | "used_DESC";

export type WorkHourOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "weekday_ASC"
  | "weekday_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "isDayOff_ASC"
  | "isDayOff_DESC";

export type EmployeeOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "employeeId_ASC"
  | "employeeId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "role_ASC"
  | "role_DESC"
  | "admissionDate_ASC"
  | "admissionDate_DESC"
  | "terminationDate_ASC"
  | "terminationDate_DESC"
  | "isActive_ASC"
  | "isActive_DESC";

export type TableOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "tableNumber_ASC"
  | "tableNumber_DESC";

export type ExpenseOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "NFE_ASC"
  | "NFE_DESC"
  | "NFEReference_ASC"
  | "NFEReference_DESC"
  | "date_ASC"
  | "date_DESC"
  | "executionDate_ASC"
  | "executionDate_DESC";

export type ExpenseItemOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "value_ASC"
  | "value_DESC"
  | "details_ASC"
  | "details_DESC";

export type ClientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC"
  | "complement_ASC"
  | "complement_DESC"
  | "postCode_ASC"
  | "postCode_DESC"
  | "telephoneNumber_ASC"
  | "telephoneNumber_DESC"
  | "distanceKm_ASC"
  | "distanceKm_DESC"
  | "distanceTime_ASC"
  | "distanceTime_DESC";

export type IncomeOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "reference_ASC"
  | "reference_DESC"
  | "value_ASC"
  | "value_DESC"
  | "type_ASC"
  | "type_DESC";

export type PaymentOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "paymentType_ASC"
  | "paymentType_DESC"
  | "paymentTypeOption_ASC"
  | "paymentTypeOption_DESC"
  | "isActive_ASC"
  | "isActive_DESC";

export type CheckDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "checkbookId_ASC"
  | "checkbookId_DESC"
  | "compensationNumber_ASC"
  | "compensationNumber_DESC"
  | "bankNumber_ASC"
  | "bankNumber_DESC";

export type EstablishmentOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "long_ASC"
  | "long_DESC"
  | "restaurantId_ASC"
  | "restaurantId_DESC"
  | "valueInCashRegister_ASC"
  | "valueInCashRegister_DESC"
  | "maximumInCashRegister_ASC"
  | "maximumInCashRegister_DESC"
  | "incomeMaxReference_ASC"
  | "incomeMaxReference_DESC"
  | "isOpen_ASC"
  | "isOpen_DESC"
  | "totalInvoices_ASC"
  | "totalInvoices_DESC";

export type NCMOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "identifier_ASC"
  | "identifier_DESC"
  | "description_ASC"
  | "description_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "category_ASC"
  | "category_DESC"
  | "supplier_ASC"
  | "supplier_DESC"
  | "brand_ASC"
  | "brand_DESC"
  | "unit_ASC"
  | "unit_DESC";

export type UserOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BillWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface WorkDayWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  establishment?: Maybe<EstablishmentWhereInput>;
  isCurrent?: Maybe<Boolean>;
  isCurrent_not?: Maybe<Boolean>;
  openDate?: Maybe<DateTimeInput>;
  openDate_not?: Maybe<DateTimeInput>;
  openDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  openDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  openDate_lt?: Maybe<DateTimeInput>;
  openDate_lte?: Maybe<DateTimeInput>;
  openDate_gt?: Maybe<DateTimeInput>;
  openDate_gte?: Maybe<DateTimeInput>;
  closeDate?: Maybe<DateTimeInput>;
  closeDate_not?: Maybe<DateTimeInput>;
  closeDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closeDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closeDate_lt?: Maybe<DateTimeInput>;
  closeDate_lte?: Maybe<DateTimeInput>;
  closeDate_gt?: Maybe<DateTimeInput>;
  closeDate_gte?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserWhereInput>;
  tables_every?: Maybe<TableDataWhereInput>;
  tables_some?: Maybe<TableDataWhereInput>;
  tables_none?: Maybe<TableDataWhereInput>;
  incomes_every?: Maybe<IncomeWhereInput>;
  incomes_some?: Maybe<IncomeWhereInput>;
  incomes_none?: Maybe<IncomeWhereInput>;
  bills_every?: Maybe<BillWhereInput>;
  bills_some?: Maybe<BillWhereInput>;
  bills_none?: Maybe<BillWhereInput>;
  orders_every?: Maybe<OrderWhereInput>;
  orders_some?: Maybe<OrderWhereInput>;
  orders_none?: Maybe<OrderWhereInput>;
  orderPads_every?: Maybe<OrderPadWhereInput>;
  orderPads_some?: Maybe<OrderPadWhereInput>;
  orderPads_none?: Maybe<OrderPadWhereInput>;
  AND?: Maybe<WorkDayWhereInput[] | WorkDayWhereInput>;
  OR?: Maybe<WorkDayWhereInput[] | WorkDayWhereInput>;
  NOT?: Maybe<WorkDayWhereInput[] | WorkDayWhereInput>;
}

export interface EstablishmentWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  long?: Maybe<Float>;
  long_not?: Maybe<Float>;
  long_in?: Maybe<Float[] | Float>;
  long_not_in?: Maybe<Float[] | Float>;
  long_lt?: Maybe<Float>;
  long_lte?: Maybe<Float>;
  long_gt?: Maybe<Float>;
  long_gte?: Maybe<Float>;
  restaurantId?: Maybe<String>;
  restaurantId_not?: Maybe<String>;
  restaurantId_in?: Maybe<String[] | String>;
  restaurantId_not_in?: Maybe<String[] | String>;
  restaurantId_lt?: Maybe<String>;
  restaurantId_lte?: Maybe<String>;
  restaurantId_gt?: Maybe<String>;
  restaurantId_gte?: Maybe<String>;
  restaurantId_contains?: Maybe<String>;
  restaurantId_not_contains?: Maybe<String>;
  restaurantId_starts_with?: Maybe<String>;
  restaurantId_not_starts_with?: Maybe<String>;
  restaurantId_ends_with?: Maybe<String>;
  restaurantId_not_ends_with?: Maybe<String>;
  valueInCashRegister?: Maybe<Float>;
  valueInCashRegister_not?: Maybe<Float>;
  valueInCashRegister_in?: Maybe<Float[] | Float>;
  valueInCashRegister_not_in?: Maybe<Float[] | Float>;
  valueInCashRegister_lt?: Maybe<Float>;
  valueInCashRegister_lte?: Maybe<Float>;
  valueInCashRegister_gt?: Maybe<Float>;
  valueInCashRegister_gte?: Maybe<Float>;
  maximumInCashRegister?: Maybe<Float>;
  maximumInCashRegister_not?: Maybe<Float>;
  maximumInCashRegister_in?: Maybe<Float[] | Float>;
  maximumInCashRegister_not_in?: Maybe<Float[] | Float>;
  maximumInCashRegister_lt?: Maybe<Float>;
  maximumInCashRegister_lte?: Maybe<Float>;
  maximumInCashRegister_gt?: Maybe<Float>;
  maximumInCashRegister_gte?: Maybe<Float>;
  incomeMaxReference?: Maybe<Int>;
  incomeMaxReference_not?: Maybe<Int>;
  incomeMaxReference_in?: Maybe<Int[] | Int>;
  incomeMaxReference_not_in?: Maybe<Int[] | Int>;
  incomeMaxReference_lt?: Maybe<Int>;
  incomeMaxReference_lte?: Maybe<Int>;
  incomeMaxReference_gt?: Maybe<Int>;
  incomeMaxReference_gte?: Maybe<Int>;
  isOpen?: Maybe<Boolean>;
  isOpen_not?: Maybe<Boolean>;
  workingDays_every?: Maybe<WorkDayWhereInput>;
  workingDays_some?: Maybe<WorkDayWhereInput>;
  workingDays_none?: Maybe<WorkDayWhereInput>;
  permissions_every?: Maybe<PermissionWhereInput>;
  permissions_some?: Maybe<PermissionWhereInput>;
  permissions_none?: Maybe<PermissionWhereInput>;
  items_every?: Maybe<ItemWhereInput>;
  items_some?: Maybe<ItemWhereInput>;
  items_none?: Maybe<ItemWhereInput>;
  employees_every?: Maybe<EmployeeWhereInput>;
  employees_some?: Maybe<EmployeeWhereInput>;
  employees_none?: Maybe<EmployeeWhereInput>;
  tables_every?: Maybe<TableWhereInput>;
  tables_some?: Maybe<TableWhereInput>;
  tables_none?: Maybe<TableWhereInput>;
  expenses_every?: Maybe<ExpenseWhereInput>;
  expenses_some?: Maybe<ExpenseWhereInput>;
  expenses_none?: Maybe<ExpenseWhereInput>;
  totalInvoices?: Maybe<Int>;
  totalInvoices_not?: Maybe<Int>;
  totalInvoices_in?: Maybe<Int[] | Int>;
  totalInvoices_not_in?: Maybe<Int[] | Int>;
  totalInvoices_lt?: Maybe<Int>;
  totalInvoices_lte?: Maybe<Int>;
  totalInvoices_gt?: Maybe<Int>;
  totalInvoices_gte?: Maybe<Int>;
  clients_every?: Maybe<ClientWhereInput>;
  clients_some?: Maybe<ClientWhereInput>;
  clients_none?: Maybe<ClientWhereInput>;
  AND?: Maybe<EstablishmentWhereInput[] | EstablishmentWhereInput>;
  OR?: Maybe<EstablishmentWhereInput[] | EstablishmentWhereInput>;
  NOT?: Maybe<EstablishmentWhereInput[] | EstablishmentWhereInput>;
}

export interface PermissionWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  establishment?: Maybe<EstablishmentWhereInput>;
  role?: Maybe<UserRole>;
  role_not?: Maybe<UserRole>;
  role_in?: Maybe<UserRole[] | UserRole>;
  role_not_in?: Maybe<UserRole[] | UserRole>;
  AND?: Maybe<PermissionWhereInput[] | PermissionWhereInput>;
  OR?: Maybe<PermissionWhereInput[] | PermissionWhereInput>;
  NOT?: Maybe<PermissionWhereInput[] | PermissionWhereInput>;
}

export interface UserWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  permissions_every?: Maybe<PermissionWhereInput>;
  permissions_some?: Maybe<PermissionWhereInput>;
  permissions_none?: Maybe<PermissionWhereInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  responsibleWorkDays_every?: Maybe<WorkDayWhereInput>;
  responsibleWorkDays_some?: Maybe<WorkDayWhereInput>;
  responsibleWorkDays_none?: Maybe<WorkDayWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  itemId?: Maybe<String>;
  itemId_not?: Maybe<String>;
  itemId_in?: Maybe<String[] | String>;
  itemId_not_in?: Maybe<String[] | String>;
  itemId_lt?: Maybe<String>;
  itemId_lte?: Maybe<String>;
  itemId_gt?: Maybe<String>;
  itemId_gte?: Maybe<String>;
  itemId_contains?: Maybe<String>;
  itemId_not_contains?: Maybe<String>;
  itemId_starts_with?: Maybe<String>;
  itemId_not_starts_with?: Maybe<String>;
  itemId_ends_with?: Maybe<String>;
  itemId_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  priceToGo?: Maybe<Float>;
  priceToGo_not?: Maybe<Float>;
  priceToGo_in?: Maybe<Float[] | Float>;
  priceToGo_not_in?: Maybe<Float[] | Float>;
  priceToGo_lt?: Maybe<Float>;
  priceToGo_lte?: Maybe<Float>;
  priceToGo_gt?: Maybe<Float>;
  priceToGo_gte?: Maybe<Float>;
  employeePrice?: Maybe<Float>;
  employeePrice_not?: Maybe<Float>;
  employeePrice_in?: Maybe<Float[] | Float>;
  employeePrice_not_in?: Maybe<Float[] | Float>;
  employeePrice_lt?: Maybe<Float>;
  employeePrice_lte?: Maybe<Float>;
  employeePrice_gt?: Maybe<Float>;
  employeePrice_gte?: Maybe<Float>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  orderItem_every?: Maybe<OrderItemWhereInput>;
  orderItem_some?: Maybe<OrderItemWhereInput>;
  orderItem_none?: Maybe<OrderItemWhereInput>;
  establishment?: Maybe<EstablishmentWhereInput>;
  canTakeToGo?: Maybe<Boolean>;
  canTakeToGo_not?: Maybe<Boolean>;
  isActive?: Maybe<Boolean>;
  isActive_not?: Maybe<Boolean>;
  itemNCM?: Maybe<NCMWhereInput>;
  hasTaxSubstitution?: Maybe<Boolean>;
  hasTaxSubstitution_not?: Maybe<Boolean>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export interface OrderItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  item?: Maybe<ItemWhereInput>;
  order?: Maybe<OrderWhereInput>;
  employee?: Maybe<EmployeeWhereInput>;
  AND?: Maybe<OrderItemWhereInput[] | OrderItemWhereInput>;
  OR?: Maybe<OrderItemWhereInput[] | OrderItemWhereInput>;
  NOT?: Maybe<OrderItemWhereInput[] | OrderItemWhereInput>;
}

export interface OrderWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  workDay?: Maybe<WorkDayWhereInput>;
  block?: Maybe<Int>;
  block_not?: Maybe<Int>;
  block_in?: Maybe<Int[] | Int>;
  block_not_in?: Maybe<Int[] | Int>;
  block_lt?: Maybe<Int>;
  block_lte?: Maybe<Int>;
  block_gt?: Maybe<Int>;
  block_gte?: Maybe<Int>;
  orderId?: Maybe<Int>;
  orderId_not?: Maybe<Int>;
  orderId_in?: Maybe<Int[] | Int>;
  orderId_not_in?: Maybe<Int[] | Int>;
  orderId_lt?: Maybe<Int>;
  orderId_lte?: Maybe<Int>;
  orderId_gt?: Maybe<Int>;
  orderId_gte?: Maybe<Int>;
  bill?: Maybe<BillWhereInput>;
  orderItems_every?: Maybe<OrderItemWhereInput>;
  orderItems_some?: Maybe<OrderItemWhereInput>;
  orderItems_none?: Maybe<OrderItemWhereInput>;
  cancelled?: Maybe<Boolean>;
  cancelled_not?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  cancelationJustification_not?: Maybe<String>;
  cancelationJustification_in?: Maybe<String[] | String>;
  cancelationJustification_not_in?: Maybe<String[] | String>;
  cancelationJustification_lt?: Maybe<String>;
  cancelationJustification_lte?: Maybe<String>;
  cancelationJustification_gt?: Maybe<String>;
  cancelationJustification_gte?: Maybe<String>;
  cancelationJustification_contains?: Maybe<String>;
  cancelationJustification_not_contains?: Maybe<String>;
  cancelationJustification_starts_with?: Maybe<String>;
  cancelationJustification_not_starts_with?: Maybe<String>;
  cancelationJustification_ends_with?: Maybe<String>;
  cancelationJustification_not_ends_with?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  wasModified_not?: Maybe<Boolean>;
  modifiedOrders_every?: Maybe<OrderWhereInput>;
  modifiedOrders_some?: Maybe<OrderWhereInput>;
  modifiedOrders_none?: Maybe<OrderWhereInput>;
  isEmployeeOrder?: Maybe<Boolean>;
  isEmployeeOrder_not?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  reuse_not?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  isToGo_not?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
  toGoReference_not?: Maybe<String>;
  toGoReference_in?: Maybe<String[] | String>;
  toGoReference_not_in?: Maybe<String[] | String>;
  toGoReference_lt?: Maybe<String>;
  toGoReference_lte?: Maybe<String>;
  toGoReference_gt?: Maybe<String>;
  toGoReference_gte?: Maybe<String>;
  toGoReference_contains?: Maybe<String>;
  toGoReference_not_contains?: Maybe<String>;
  toGoReference_starts_with?: Maybe<String>;
  toGoReference_not_starts_with?: Maybe<String>;
  toGoReference_ends_with?: Maybe<String>;
  toGoReference_not_ends_with?: Maybe<String>;
  AND?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  OR?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  NOT?: Maybe<OrderWhereInput[] | OrderWhereInput>;
}

export interface BillWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  closedAt_not?: Maybe<DateTimeInput>;
  closedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closedAt_lt?: Maybe<DateTimeInput>;
  closedAt_lte?: Maybe<DateTimeInput>;
  closedAt_gt?: Maybe<DateTimeInput>;
  closedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  workDay?: Maybe<WorkDayWhereInput>;
  tableData?: Maybe<TableDataWhereInput>;
  orders_every?: Maybe<OrderWhereInput>;
  orders_some?: Maybe<OrderWhereInput>;
  orders_none?: Maybe<OrderWhereInput>;
  status?: Maybe<BillStatus>;
  status_not?: Maybe<BillStatus>;
  status_in?: Maybe<BillStatus[] | BillStatus>;
  status_not_in?: Maybe<BillStatus[] | BillStatus>;
  discount?: Maybe<Float>;
  discount_not?: Maybe<Float>;
  discount_in?: Maybe<Float[] | Float>;
  discount_not_in?: Maybe<Float[] | Float>;
  discount_lt?: Maybe<Float>;
  discount_lte?: Maybe<Float>;
  discount_gt?: Maybe<Float>;
  discount_gte?: Maybe<Float>;
  discountReason?: Maybe<String>;
  discountReason_not?: Maybe<String>;
  discountReason_in?: Maybe<String[] | String>;
  discountReason_not_in?: Maybe<String[] | String>;
  discountReason_lt?: Maybe<String>;
  discountReason_lte?: Maybe<String>;
  discountReason_gt?: Maybe<String>;
  discountReason_gte?: Maybe<String>;
  discountReason_contains?: Maybe<String>;
  discountReason_not_contains?: Maybe<String>;
  discountReason_starts_with?: Maybe<String>;
  discountReason_not_starts_with?: Maybe<String>;
  discountReason_ends_with?: Maybe<String>;
  discountReason_not_ends_with?: Maybe<String>;
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  payments_every?: Maybe<PaymentWhereInput>;
  payments_some?: Maybe<PaymentWhereInput>;
  payments_none?: Maybe<PaymentWhereInput>;
  wasReopen?: Maybe<Boolean>;
  wasReopen_not?: Maybe<Boolean>;
  reopenBills_every?: Maybe<BillWhereInput>;
  reopenBills_some?: Maybe<BillWhereInput>;
  reopenBills_none?: Maybe<BillWhereInput>;
  registered?: Maybe<Boolean>;
  registered_not?: Maybe<Boolean>;
  AND?: Maybe<BillWhereInput[] | BillWhereInput>;
  OR?: Maybe<BillWhereInput[] | BillWhereInput>;
  NOT?: Maybe<BillWhereInput[] | BillWhereInput>;
}

export interface TableDataWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  totalOccupations?: Maybe<Int>;
  totalOccupations_not?: Maybe<Int>;
  totalOccupations_in?: Maybe<Int[] | Int>;
  totalOccupations_not_in?: Maybe<Int[] | Int>;
  totalOccupations_lt?: Maybe<Int>;
  totalOccupations_lte?: Maybe<Int>;
  totalOccupations_gt?: Maybe<Int>;
  totalOccupations_gte?: Maybe<Int>;
  table?: Maybe<TableWhereInput>;
  workDay?: Maybe<WorkDayWhereInput>;
  waiter?: Maybe<EmployeeWhereInput>;
  bills_every?: Maybe<BillWhereInput>;
  bills_some?: Maybe<BillWhereInput>;
  bills_none?: Maybe<BillWhereInput>;
  AND?: Maybe<TableDataWhereInput[] | TableDataWhereInput>;
  OR?: Maybe<TableDataWhereInput[] | TableDataWhereInput>;
  NOT?: Maybe<TableDataWhereInput[] | TableDataWhereInput>;
}

export interface TableWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  tableNumber?: Maybe<Int>;
  tableNumber_not?: Maybe<Int>;
  tableNumber_in?: Maybe<Int[] | Int>;
  tableNumber_not_in?: Maybe<Int[] | Int>;
  tableNumber_lt?: Maybe<Int>;
  tableNumber_lte?: Maybe<Int>;
  tableNumber_gt?: Maybe<Int>;
  tableNumber_gte?: Maybe<Int>;
  establishment?: Maybe<EstablishmentWhereInput>;
  data_every?: Maybe<TableDataWhereInput>;
  data_some?: Maybe<TableDataWhereInput>;
  data_none?: Maybe<TableDataWhereInput>;
  AND?: Maybe<TableWhereInput[] | TableWhereInput>;
  OR?: Maybe<TableWhereInput[] | TableWhereInput>;
  NOT?: Maybe<TableWhereInput[] | TableWhereInput>;
}

export interface EmployeeWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  establishment?: Maybe<EstablishmentWhereInput>;
  employeeId?: Maybe<Int>;
  employeeId_not?: Maybe<Int>;
  employeeId_in?: Maybe<Int[] | Int>;
  employeeId_not_in?: Maybe<Int[] | Int>;
  employeeId_lt?: Maybe<Int>;
  employeeId_lte?: Maybe<Int>;
  employeeId_gt?: Maybe<Int>;
  employeeId_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  role?: Maybe<String>;
  role_not?: Maybe<String>;
  role_in?: Maybe<String[] | String>;
  role_not_in?: Maybe<String[] | String>;
  role_lt?: Maybe<String>;
  role_lte?: Maybe<String>;
  role_gt?: Maybe<String>;
  role_gte?: Maybe<String>;
  role_contains?: Maybe<String>;
  role_not_contains?: Maybe<String>;
  role_starts_with?: Maybe<String>;
  role_not_starts_with?: Maybe<String>;
  role_ends_with?: Maybe<String>;
  role_not_ends_with?: Maybe<String>;
  tables_every?: Maybe<TableDataWhereInput>;
  tables_some?: Maybe<TableDataWhereInput>;
  tables_none?: Maybe<TableDataWhereInput>;
  orderPads_every?: Maybe<OrderPadWhereInput>;
  orderPads_some?: Maybe<OrderPadWhereInput>;
  orderPads_none?: Maybe<OrderPadWhereInput>;
  itemsOrdered_every?: Maybe<OrderItemWhereInput>;
  itemsOrdered_some?: Maybe<OrderItemWhereInput>;
  itemsOrdered_none?: Maybe<OrderItemWhereInput>;
  workHours_every?: Maybe<WorkHourWhereInput>;
  workHours_some?: Maybe<WorkHourWhereInput>;
  workHours_none?: Maybe<WorkHourWhereInput>;
  admissionDate?: Maybe<DateTimeInput>;
  admissionDate_not?: Maybe<DateTimeInput>;
  admissionDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  admissionDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  admissionDate_lt?: Maybe<DateTimeInput>;
  admissionDate_lte?: Maybe<DateTimeInput>;
  admissionDate_gt?: Maybe<DateTimeInput>;
  admissionDate_gte?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  terminationDate_not?: Maybe<DateTimeInput>;
  terminationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  terminationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  terminationDate_lt?: Maybe<DateTimeInput>;
  terminationDate_lte?: Maybe<DateTimeInput>;
  terminationDate_gt?: Maybe<DateTimeInput>;
  terminationDate_gte?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
  isActive_not?: Maybe<Boolean>;
  AND?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
  OR?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
  NOT?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
}

export interface OrderPadWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  workDay?: Maybe<WorkDayWhereInput>;
  block?: Maybe<Int>;
  block_not?: Maybe<Int>;
  block_in?: Maybe<Int[] | Int>;
  block_not_in?: Maybe<Int[] | Int>;
  block_lt?: Maybe<Int>;
  block_lte?: Maybe<Int>;
  block_gt?: Maybe<Int>;
  block_gte?: Maybe<Int>;
  firstOrderId?: Maybe<Int>;
  firstOrderId_not?: Maybe<Int>;
  firstOrderId_in?: Maybe<Int[] | Int>;
  firstOrderId_not_in?: Maybe<Int[] | Int>;
  firstOrderId_lt?: Maybe<Int>;
  firstOrderId_lte?: Maybe<Int>;
  firstOrderId_gt?: Maybe<Int>;
  firstOrderId_gte?: Maybe<Int>;
  lastOrderId?: Maybe<Int>;
  lastOrderId_not?: Maybe<Int>;
  lastOrderId_in?: Maybe<Int[] | Int>;
  lastOrderId_not_in?: Maybe<Int[] | Int>;
  lastOrderId_lt?: Maybe<Int>;
  lastOrderId_lte?: Maybe<Int>;
  lastOrderId_gt?: Maybe<Int>;
  lastOrderId_gte?: Maybe<Int>;
  employee?: Maybe<EmployeeWhereInput>;
  used?: Maybe<Boolean>;
  used_not?: Maybe<Boolean>;
  AND?: Maybe<OrderPadWhereInput[] | OrderPadWhereInput>;
  OR?: Maybe<OrderPadWhereInput[] | OrderPadWhereInput>;
  NOT?: Maybe<OrderPadWhereInput[] | OrderPadWhereInput>;
}

export interface WorkHourWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  weekday?: Maybe<WeekDay>;
  weekday_not?: Maybe<WeekDay>;
  weekday_in?: Maybe<WeekDay[] | WeekDay>;
  weekday_not_in?: Maybe<WeekDay[] | WeekDay>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  endTime?: Maybe<String>;
  endTime_not?: Maybe<String>;
  endTime_in?: Maybe<String[] | String>;
  endTime_not_in?: Maybe<String[] | String>;
  endTime_lt?: Maybe<String>;
  endTime_lte?: Maybe<String>;
  endTime_gt?: Maybe<String>;
  endTime_gte?: Maybe<String>;
  endTime_contains?: Maybe<String>;
  endTime_not_contains?: Maybe<String>;
  endTime_starts_with?: Maybe<String>;
  endTime_not_starts_with?: Maybe<String>;
  endTime_ends_with?: Maybe<String>;
  endTime_not_ends_with?: Maybe<String>;
  isDayOff?: Maybe<Boolean>;
  isDayOff_not?: Maybe<Boolean>;
  employee?: Maybe<EmployeeWhereInput>;
  AND?: Maybe<WorkHourWhereInput[] | WorkHourWhereInput>;
  OR?: Maybe<WorkHourWhereInput[] | WorkHourWhereInput>;
  NOT?: Maybe<WorkHourWhereInput[] | WorkHourWhereInput>;
}

export interface PaymentWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  paymentType?: Maybe<String>;
  paymentType_not?: Maybe<String>;
  paymentType_in?: Maybe<String[] | String>;
  paymentType_not_in?: Maybe<String[] | String>;
  paymentType_lt?: Maybe<String>;
  paymentType_lte?: Maybe<String>;
  paymentType_gt?: Maybe<String>;
  paymentType_gte?: Maybe<String>;
  paymentType_contains?: Maybe<String>;
  paymentType_not_contains?: Maybe<String>;
  paymentType_starts_with?: Maybe<String>;
  paymentType_not_starts_with?: Maybe<String>;
  paymentType_ends_with?: Maybe<String>;
  paymentType_not_ends_with?: Maybe<String>;
  paymentTypeOption?: Maybe<String>;
  paymentTypeOption_not?: Maybe<String>;
  paymentTypeOption_in?: Maybe<String[] | String>;
  paymentTypeOption_not_in?: Maybe<String[] | String>;
  paymentTypeOption_lt?: Maybe<String>;
  paymentTypeOption_lte?: Maybe<String>;
  paymentTypeOption_gt?: Maybe<String>;
  paymentTypeOption_gte?: Maybe<String>;
  paymentTypeOption_contains?: Maybe<String>;
  paymentTypeOption_not_contains?: Maybe<String>;
  paymentTypeOption_starts_with?: Maybe<String>;
  paymentTypeOption_not_starts_with?: Maybe<String>;
  paymentTypeOption_ends_with?: Maybe<String>;
  paymentTypeOption_not_ends_with?: Maybe<String>;
  checkData?: Maybe<CheckDataWhereInput>;
  bill?: Maybe<BillWhereInput>;
  expense?: Maybe<ExpenseWhereInput>;
  isActive?: Maybe<Boolean>;
  isActive_not?: Maybe<Boolean>;
  AND?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  OR?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  NOT?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
}

export interface CheckDataWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  payment?: Maybe<PaymentWhereInput>;
  checkbookId?: Maybe<String>;
  checkbookId_not?: Maybe<String>;
  checkbookId_in?: Maybe<String[] | String>;
  checkbookId_not_in?: Maybe<String[] | String>;
  checkbookId_lt?: Maybe<String>;
  checkbookId_lte?: Maybe<String>;
  checkbookId_gt?: Maybe<String>;
  checkbookId_gte?: Maybe<String>;
  checkbookId_contains?: Maybe<String>;
  checkbookId_not_contains?: Maybe<String>;
  checkbookId_starts_with?: Maybe<String>;
  checkbookId_not_starts_with?: Maybe<String>;
  checkbookId_ends_with?: Maybe<String>;
  checkbookId_not_ends_with?: Maybe<String>;
  compensationNumber?: Maybe<Int>;
  compensationNumber_not?: Maybe<Int>;
  compensationNumber_in?: Maybe<Int[] | Int>;
  compensationNumber_not_in?: Maybe<Int[] | Int>;
  compensationNumber_lt?: Maybe<Int>;
  compensationNumber_lte?: Maybe<Int>;
  compensationNumber_gt?: Maybe<Int>;
  compensationNumber_gte?: Maybe<Int>;
  bankNumber?: Maybe<Int>;
  bankNumber_not?: Maybe<Int>;
  bankNumber_in?: Maybe<Int[] | Int>;
  bankNumber_not_in?: Maybe<Int[] | Int>;
  bankNumber_lt?: Maybe<Int>;
  bankNumber_lte?: Maybe<Int>;
  bankNumber_gt?: Maybe<Int>;
  bankNumber_gte?: Maybe<Int>;
  AND?: Maybe<CheckDataWhereInput[] | CheckDataWhereInput>;
  OR?: Maybe<CheckDataWhereInput[] | CheckDataWhereInput>;
  NOT?: Maybe<CheckDataWhereInput[] | CheckDataWhereInput>;
}

export interface ExpenseWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  establishment?: Maybe<EstablishmentWhereInput>;
  NFE?: Maybe<Boolean>;
  NFE_not?: Maybe<Boolean>;
  NFEReference?: Maybe<String>;
  NFEReference_not?: Maybe<String>;
  NFEReference_in?: Maybe<String[] | String>;
  NFEReference_not_in?: Maybe<String[] | String>;
  NFEReference_lt?: Maybe<String>;
  NFEReference_lte?: Maybe<String>;
  NFEReference_gt?: Maybe<String>;
  NFEReference_gte?: Maybe<String>;
  NFEReference_contains?: Maybe<String>;
  NFEReference_not_contains?: Maybe<String>;
  NFEReference_starts_with?: Maybe<String>;
  NFEReference_not_starts_with?: Maybe<String>;
  NFEReference_ends_with?: Maybe<String>;
  NFEReference_not_ends_with?: Maybe<String>;
  expenseItems_every?: Maybe<ExpenseItemWhereInput>;
  expenseItems_some?: Maybe<ExpenseItemWhereInput>;
  expenseItems_none?: Maybe<ExpenseItemWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  executionDate?: Maybe<DateTimeInput>;
  executionDate_not?: Maybe<DateTimeInput>;
  executionDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  executionDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  executionDate_lt?: Maybe<DateTimeInput>;
  executionDate_lte?: Maybe<DateTimeInput>;
  executionDate_gt?: Maybe<DateTimeInput>;
  executionDate_gte?: Maybe<DateTimeInput>;
  payment?: Maybe<PaymentWhereInput>;
  AND?: Maybe<ExpenseWhereInput[] | ExpenseWhereInput>;
  OR?: Maybe<ExpenseWhereInput[] | ExpenseWhereInput>;
  NOT?: Maybe<ExpenseWhereInput[] | ExpenseWhereInput>;
}

export interface ExpenseItemWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<Float>;
  quantity_not?: Maybe<Float>;
  quantity_in?: Maybe<Float[] | Float>;
  quantity_not_in?: Maybe<Float[] | Float>;
  quantity_lt?: Maybe<Float>;
  quantity_lte?: Maybe<Float>;
  quantity_gt?: Maybe<Float>;
  quantity_gte?: Maybe<Float>;
  product?: Maybe<ProductWhereInput>;
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  details?: Maybe<String>;
  details_not?: Maybe<String>;
  details_in?: Maybe<String[] | String>;
  details_not_in?: Maybe<String[] | String>;
  details_lt?: Maybe<String>;
  details_lte?: Maybe<String>;
  details_gt?: Maybe<String>;
  details_gte?: Maybe<String>;
  details_contains?: Maybe<String>;
  details_not_contains?: Maybe<String>;
  details_starts_with?: Maybe<String>;
  details_not_starts_with?: Maybe<String>;
  details_ends_with?: Maybe<String>;
  details_not_ends_with?: Maybe<String>;
  AND?: Maybe<ExpenseItemWhereInput[] | ExpenseItemWhereInput>;
  OR?: Maybe<ExpenseItemWhereInput[] | ExpenseItemWhereInput>;
  NOT?: Maybe<ExpenseItemWhereInput[] | ExpenseItemWhereInput>;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  supplier?: Maybe<String>;
  supplier_not?: Maybe<String>;
  supplier_in?: Maybe<String[] | String>;
  supplier_not_in?: Maybe<String[] | String>;
  supplier_lt?: Maybe<String>;
  supplier_lte?: Maybe<String>;
  supplier_gt?: Maybe<String>;
  supplier_gte?: Maybe<String>;
  supplier_contains?: Maybe<String>;
  supplier_not_contains?: Maybe<String>;
  supplier_starts_with?: Maybe<String>;
  supplier_not_starts_with?: Maybe<String>;
  supplier_ends_with?: Maybe<String>;
  supplier_not_ends_with?: Maybe<String>;
  brand?: Maybe<String>;
  brand_not?: Maybe<String>;
  brand_in?: Maybe<String[] | String>;
  brand_not_in?: Maybe<String[] | String>;
  brand_lt?: Maybe<String>;
  brand_lte?: Maybe<String>;
  brand_gt?: Maybe<String>;
  brand_gte?: Maybe<String>;
  brand_contains?: Maybe<String>;
  brand_not_contains?: Maybe<String>;
  brand_starts_with?: Maybe<String>;
  brand_not_starts_with?: Maybe<String>;
  brand_ends_with?: Maybe<String>;
  brand_not_ends_with?: Maybe<String>;
  unit?: Maybe<String>;
  unit_not?: Maybe<String>;
  unit_in?: Maybe<String[] | String>;
  unit_not_in?: Maybe<String[] | String>;
  unit_lt?: Maybe<String>;
  unit_lte?: Maybe<String>;
  unit_gt?: Maybe<String>;
  unit_gte?: Maybe<String>;
  unit_contains?: Maybe<String>;
  unit_not_contains?: Maybe<String>;
  unit_starts_with?: Maybe<String>;
  unit_not_starts_with?: Maybe<String>;
  unit_ends_with?: Maybe<String>;
  unit_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface NCMWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  identifier?: Maybe<String>;
  identifier_not?: Maybe<String>;
  identifier_in?: Maybe<String[] | String>;
  identifier_not_in?: Maybe<String[] | String>;
  identifier_lt?: Maybe<String>;
  identifier_lte?: Maybe<String>;
  identifier_gt?: Maybe<String>;
  identifier_gte?: Maybe<String>;
  identifier_contains?: Maybe<String>;
  identifier_not_contains?: Maybe<String>;
  identifier_starts_with?: Maybe<String>;
  identifier_not_starts_with?: Maybe<String>;
  identifier_ends_with?: Maybe<String>;
  identifier_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  items_every?: Maybe<ItemWhereInput>;
  items_some?: Maybe<ItemWhereInput>;
  items_none?: Maybe<ItemWhereInput>;
  AND?: Maybe<NCMWhereInput[] | NCMWhereInput>;
  OR?: Maybe<NCMWhereInput[] | NCMWhereInput>;
  NOT?: Maybe<NCMWhereInput[] | NCMWhereInput>;
}

export interface ClientWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  complement?: Maybe<String>;
  complement_not?: Maybe<String>;
  complement_in?: Maybe<String[] | String>;
  complement_not_in?: Maybe<String[] | String>;
  complement_lt?: Maybe<String>;
  complement_lte?: Maybe<String>;
  complement_gt?: Maybe<String>;
  complement_gte?: Maybe<String>;
  complement_contains?: Maybe<String>;
  complement_not_contains?: Maybe<String>;
  complement_starts_with?: Maybe<String>;
  complement_not_starts_with?: Maybe<String>;
  complement_ends_with?: Maybe<String>;
  complement_not_ends_with?: Maybe<String>;
  postCode?: Maybe<String>;
  postCode_not?: Maybe<String>;
  postCode_in?: Maybe<String[] | String>;
  postCode_not_in?: Maybe<String[] | String>;
  postCode_lt?: Maybe<String>;
  postCode_lte?: Maybe<String>;
  postCode_gt?: Maybe<String>;
  postCode_gte?: Maybe<String>;
  postCode_contains?: Maybe<String>;
  postCode_not_contains?: Maybe<String>;
  postCode_starts_with?: Maybe<String>;
  postCode_not_starts_with?: Maybe<String>;
  postCode_ends_with?: Maybe<String>;
  postCode_not_ends_with?: Maybe<String>;
  telephoneNumber?: Maybe<String>;
  telephoneNumber_not?: Maybe<String>;
  telephoneNumber_in?: Maybe<String[] | String>;
  telephoneNumber_not_in?: Maybe<String[] | String>;
  telephoneNumber_lt?: Maybe<String>;
  telephoneNumber_lte?: Maybe<String>;
  telephoneNumber_gt?: Maybe<String>;
  telephoneNumber_gte?: Maybe<String>;
  telephoneNumber_contains?: Maybe<String>;
  telephoneNumber_not_contains?: Maybe<String>;
  telephoneNumber_starts_with?: Maybe<String>;
  telephoneNumber_not_starts_with?: Maybe<String>;
  telephoneNumber_ends_with?: Maybe<String>;
  telephoneNumber_not_ends_with?: Maybe<String>;
  establishment?: Maybe<EstablishmentWhereInput>;
  distanceKm?: Maybe<String>;
  distanceKm_not?: Maybe<String>;
  distanceKm_in?: Maybe<String[] | String>;
  distanceKm_not_in?: Maybe<String[] | String>;
  distanceKm_lt?: Maybe<String>;
  distanceKm_lte?: Maybe<String>;
  distanceKm_gt?: Maybe<String>;
  distanceKm_gte?: Maybe<String>;
  distanceKm_contains?: Maybe<String>;
  distanceKm_not_contains?: Maybe<String>;
  distanceKm_starts_with?: Maybe<String>;
  distanceKm_not_starts_with?: Maybe<String>;
  distanceKm_ends_with?: Maybe<String>;
  distanceKm_not_ends_with?: Maybe<String>;
  distanceTime?: Maybe<String>;
  distanceTime_not?: Maybe<String>;
  distanceTime_in?: Maybe<String[] | String>;
  distanceTime_not_in?: Maybe<String[] | String>;
  distanceTime_lt?: Maybe<String>;
  distanceTime_lte?: Maybe<String>;
  distanceTime_gt?: Maybe<String>;
  distanceTime_gte?: Maybe<String>;
  distanceTime_contains?: Maybe<String>;
  distanceTime_not_contains?: Maybe<String>;
  distanceTime_starts_with?: Maybe<String>;
  distanceTime_not_starts_with?: Maybe<String>;
  distanceTime_ends_with?: Maybe<String>;
  distanceTime_not_ends_with?: Maybe<String>;
  AND?: Maybe<ClientWhereInput[] | ClientWhereInput>;
  OR?: Maybe<ClientWhereInput[] | ClientWhereInput>;
  NOT?: Maybe<ClientWhereInput[] | ClientWhereInput>;
}

export interface IncomeWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  workDay?: Maybe<WorkDayWhereInput>;
  reference?: Maybe<String>;
  reference_not?: Maybe<String>;
  reference_in?: Maybe<String[] | String>;
  reference_not_in?: Maybe<String[] | String>;
  reference_lt?: Maybe<String>;
  reference_lte?: Maybe<String>;
  reference_gt?: Maybe<String>;
  reference_gte?: Maybe<String>;
  reference_contains?: Maybe<String>;
  reference_not_contains?: Maybe<String>;
  reference_starts_with?: Maybe<String>;
  reference_not_starts_with?: Maybe<String>;
  reference_ends_with?: Maybe<String>;
  reference_not_ends_with?: Maybe<String>;
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  AND?: Maybe<IncomeWhereInput[] | IncomeWhereInput>;
  OR?: Maybe<IncomeWhereInput[] | IncomeWhereInput>;
  NOT?: Maybe<IncomeWhereInput[] | IncomeWhereInput>;
}

export type CheckDataWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ClientWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  telephoneNumber?: Maybe<String>;
}>;

export type EmployeeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  employeeId?: Maybe<Int>;
}>;

export type EstablishmentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ExpenseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ExpenseItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type IncomeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  reference?: Maybe<String>;
}>;

export type ItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type NCMWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type OrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type OrderItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type OrderPadWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PermissionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TableWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  tableNumber?: Maybe<Int>;
}>;

export type TableDataWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type WorkDayWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type WorkHourWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BillCreateInput {
  closedAt?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  workDay: WorkDayCreateOneWithoutBillsInput;
  tableData: TableDataCreateOneWithoutBillsInput;
  orders?: Maybe<OrderCreateManyWithoutBillInput>;
  status: BillStatus;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  payments?: Maybe<PaymentCreateManyWithoutBillInput>;
  wasReopen?: Maybe<Boolean>;
  reopenBills?: Maybe<BillCreateManyInput>;
  registered?: Maybe<Boolean>;
}

export interface WorkDayCreateOneWithoutBillsInput {
  create?: Maybe<WorkDayCreateWithoutBillsInput>;
  connect?: Maybe<WorkDayWhereUniqueInput>;
}

export interface WorkDayCreateWithoutBillsInput {
  id?: Maybe<ID_Input>;
  establishment?: Maybe<EstablishmentCreateOneWithoutWorkingDaysInput>;
  isCurrent: Boolean;
  openDate: DateTimeInput;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserCreateOneWithoutResponsibleWorkDaysInput>;
  tables?: Maybe<TableDataCreateManyWithoutWorkDayInput>;
  incomes?: Maybe<IncomeCreateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderCreateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadCreateManyWithoutWorkDayInput>;
}

export interface EstablishmentCreateOneWithoutWorkingDaysInput {
  create?: Maybe<EstablishmentCreateWithoutWorkingDaysInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutWorkingDaysInput {
  id?: Maybe<ID_Input>;
  name: String;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId: String;
  valueInCashRegister: Float;
  maximumInCashRegister: Float;
  incomeMaxReference: Int;
  isOpen: Boolean;
  permissions?: Maybe<PermissionCreateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemCreateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeCreateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableCreateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseCreateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentCreatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientCreateManyWithoutEstablishmentInput>;
}

export interface PermissionCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    | PermissionCreateWithoutEstablishmentInput[]
    | PermissionCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<PermissionWhereUniqueInput[] | PermissionWhereUniqueInput>;
}

export interface PermissionCreateWithoutEstablishmentInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutPermissionsInput;
  role: UserRole;
}

export interface UserCreateOneWithoutPermissionsInput {
  create?: Maybe<UserCreateWithoutPermissionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutPermissionsInput {
  id?: Maybe<ID_Input>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  responsibleWorkDays?: Maybe<WorkDayCreateManyWithoutUserResponsibleInput>;
}

export interface WorkDayCreateManyWithoutUserResponsibleInput {
  create?: Maybe<
    | WorkDayCreateWithoutUserResponsibleInput[]
    | WorkDayCreateWithoutUserResponsibleInput
  >;
  connect?: Maybe<WorkDayWhereUniqueInput[] | WorkDayWhereUniqueInput>;
}

export interface WorkDayCreateWithoutUserResponsibleInput {
  id?: Maybe<ID_Input>;
  establishment?: Maybe<EstablishmentCreateOneWithoutWorkingDaysInput>;
  isCurrent: Boolean;
  openDate: DateTimeInput;
  closeDate?: Maybe<DateTimeInput>;
  tables?: Maybe<TableDataCreateManyWithoutWorkDayInput>;
  incomes?: Maybe<IncomeCreateManyWithoutWorkDayInput>;
  bills?: Maybe<BillCreateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderCreateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadCreateManyWithoutWorkDayInput>;
}

export interface TableDataCreateManyWithoutWorkDayInput {
  create?: Maybe<
    TableDataCreateWithoutWorkDayInput[] | TableDataCreateWithoutWorkDayInput
  >;
  connect?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
}

export interface TableDataCreateWithoutWorkDayInput {
  id?: Maybe<ID_Input>;
  totalOccupations: Int;
  table: TableCreateOneWithoutDataInput;
  waiter?: Maybe<EmployeeCreateOneWithoutTablesInput>;
  bills?: Maybe<BillCreateManyWithoutTableDataInput>;
}

export interface TableCreateOneWithoutDataInput {
  create?: Maybe<TableCreateWithoutDataInput>;
  connect?: Maybe<TableWhereUniqueInput>;
}

export interface TableCreateWithoutDataInput {
  id?: Maybe<ID_Input>;
  tableNumber: Int;
  establishment?: Maybe<EstablishmentCreateOneWithoutTablesInput>;
}

export interface EstablishmentCreateOneWithoutTablesInput {
  create?: Maybe<EstablishmentCreateWithoutTablesInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutTablesInput {
  id?: Maybe<ID_Input>;
  name: String;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId: String;
  valueInCashRegister: Float;
  maximumInCashRegister: Float;
  incomeMaxReference: Int;
  isOpen: Boolean;
  workingDays?: Maybe<WorkDayCreateManyWithoutEstablishmentInput>;
  permissions?: Maybe<PermissionCreateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemCreateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeCreateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseCreateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentCreatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientCreateManyWithoutEstablishmentInput>;
}

export interface WorkDayCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    | WorkDayCreateWithoutEstablishmentInput[]
    | WorkDayCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<WorkDayWhereUniqueInput[] | WorkDayWhereUniqueInput>;
}

export interface WorkDayCreateWithoutEstablishmentInput {
  id?: Maybe<ID_Input>;
  isCurrent: Boolean;
  openDate: DateTimeInput;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserCreateOneWithoutResponsibleWorkDaysInput>;
  tables?: Maybe<TableDataCreateManyWithoutWorkDayInput>;
  incomes?: Maybe<IncomeCreateManyWithoutWorkDayInput>;
  bills?: Maybe<BillCreateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderCreateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadCreateManyWithoutWorkDayInput>;
}

export interface UserCreateOneWithoutResponsibleWorkDaysInput {
  create?: Maybe<UserCreateWithoutResponsibleWorkDaysInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutResponsibleWorkDaysInput {
  id?: Maybe<ID_Input>;
  permissions?: Maybe<PermissionCreateManyWithoutUserInput>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface PermissionCreateManyWithoutUserInput {
  create?: Maybe<
    PermissionCreateWithoutUserInput[] | PermissionCreateWithoutUserInput
  >;
  connect?: Maybe<PermissionWhereUniqueInput[] | PermissionWhereUniqueInput>;
}

export interface PermissionCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  establishment: EstablishmentCreateOneWithoutPermissionsInput;
  role: UserRole;
}

export interface EstablishmentCreateOneWithoutPermissionsInput {
  create?: Maybe<EstablishmentCreateWithoutPermissionsInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutPermissionsInput {
  id?: Maybe<ID_Input>;
  name: String;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId: String;
  valueInCashRegister: Float;
  maximumInCashRegister: Float;
  incomeMaxReference: Int;
  isOpen: Boolean;
  workingDays?: Maybe<WorkDayCreateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemCreateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeCreateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableCreateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseCreateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentCreatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientCreateManyWithoutEstablishmentInput>;
}

export interface ItemCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    ItemCreateWithoutEstablishmentInput[] | ItemCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface ItemCreateWithoutEstablishmentInput {
  id?: Maybe<ID_Input>;
  itemId: String;
  name: String;
  price: Float;
  priceToGo?: Maybe<Float>;
  employeePrice?: Maybe<Float>;
  category: String;
  orderItem?: Maybe<OrderItemCreateManyWithoutItemInput>;
  canTakeToGo?: Maybe<Boolean>;
  isActive: Boolean;
  itemNCM?: Maybe<NCMCreateOneWithoutItemsInput>;
  hasTaxSubstitution?: Maybe<Boolean>;
}

export interface OrderItemCreateManyWithoutItemInput {
  create?: Maybe<
    OrderItemCreateWithoutItemInput[] | OrderItemCreateWithoutItemInput
  >;
  connect?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
}

export interface OrderItemCreateWithoutItemInput {
  id?: Maybe<ID_Input>;
  quantity: Int;
  order?: Maybe<OrderCreateOneWithoutOrderItemsInput>;
  employee?: Maybe<EmployeeCreateOneWithoutItemsOrderedInput>;
}

export interface OrderCreateOneWithoutOrderItemsInput {
  create?: Maybe<OrderCreateWithoutOrderItemsInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface OrderCreateWithoutOrderItemsInput {
  id?: Maybe<ID_Input>;
  workDay: WorkDayCreateOneWithoutOrdersInput;
  block: Int;
  orderId: Int;
  bill?: Maybe<BillCreateOneWithoutOrdersInput>;
  cancelled?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  modifiedOrders?: Maybe<OrderCreateManyInput>;
  isEmployeeOrder?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
}

export interface WorkDayCreateOneWithoutOrdersInput {
  create?: Maybe<WorkDayCreateWithoutOrdersInput>;
  connect?: Maybe<WorkDayWhereUniqueInput>;
}

export interface WorkDayCreateWithoutOrdersInput {
  id?: Maybe<ID_Input>;
  establishment?: Maybe<EstablishmentCreateOneWithoutWorkingDaysInput>;
  isCurrent: Boolean;
  openDate: DateTimeInput;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserCreateOneWithoutResponsibleWorkDaysInput>;
  tables?: Maybe<TableDataCreateManyWithoutWorkDayInput>;
  incomes?: Maybe<IncomeCreateManyWithoutWorkDayInput>;
  bills?: Maybe<BillCreateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadCreateManyWithoutWorkDayInput>;
}

export interface IncomeCreateManyWithoutWorkDayInput {
  create?: Maybe<
    IncomeCreateWithoutWorkDayInput[] | IncomeCreateWithoutWorkDayInput
  >;
  connect?: Maybe<IncomeWhereUniqueInput[] | IncomeWhereUniqueInput>;
}

export interface IncomeCreateWithoutWorkDayInput {
  id?: Maybe<ID_Input>;
  reference: String;
  value: Float;
  type?: Maybe<String>;
}

export interface BillCreateManyWithoutWorkDayInput {
  create?: Maybe<
    BillCreateWithoutWorkDayInput[] | BillCreateWithoutWorkDayInput
  >;
  connect?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
}

export interface BillCreateWithoutWorkDayInput {
  closedAt?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  tableData: TableDataCreateOneWithoutBillsInput;
  orders?: Maybe<OrderCreateManyWithoutBillInput>;
  status: BillStatus;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  payments?: Maybe<PaymentCreateManyWithoutBillInput>;
  wasReopen?: Maybe<Boolean>;
  reopenBills?: Maybe<BillCreateManyInput>;
  registered?: Maybe<Boolean>;
}

export interface TableDataCreateOneWithoutBillsInput {
  create?: Maybe<TableDataCreateWithoutBillsInput>;
  connect?: Maybe<TableDataWhereUniqueInput>;
}

export interface TableDataCreateWithoutBillsInput {
  id?: Maybe<ID_Input>;
  totalOccupations: Int;
  table: TableCreateOneWithoutDataInput;
  workDay: WorkDayCreateOneWithoutTablesInput;
  waiter?: Maybe<EmployeeCreateOneWithoutTablesInput>;
}

export interface WorkDayCreateOneWithoutTablesInput {
  create?: Maybe<WorkDayCreateWithoutTablesInput>;
  connect?: Maybe<WorkDayWhereUniqueInput>;
}

export interface WorkDayCreateWithoutTablesInput {
  id?: Maybe<ID_Input>;
  establishment?: Maybe<EstablishmentCreateOneWithoutWorkingDaysInput>;
  isCurrent: Boolean;
  openDate: DateTimeInput;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserCreateOneWithoutResponsibleWorkDaysInput>;
  incomes?: Maybe<IncomeCreateManyWithoutWorkDayInput>;
  bills?: Maybe<BillCreateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderCreateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadCreateManyWithoutWorkDayInput>;
}

export interface OrderCreateManyWithoutWorkDayInput {
  create?: Maybe<
    OrderCreateWithoutWorkDayInput[] | OrderCreateWithoutWorkDayInput
  >;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
}

export interface OrderCreateWithoutWorkDayInput {
  id?: Maybe<ID_Input>;
  block: Int;
  orderId: Int;
  bill?: Maybe<BillCreateOneWithoutOrdersInput>;
  orderItems?: Maybe<OrderItemCreateManyWithoutOrderInput>;
  cancelled?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  modifiedOrders?: Maybe<OrderCreateManyInput>;
  isEmployeeOrder?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
}

export interface BillCreateOneWithoutOrdersInput {
  create?: Maybe<BillCreateWithoutOrdersInput>;
  connect?: Maybe<BillWhereUniqueInput>;
}

export interface BillCreateWithoutOrdersInput {
  closedAt?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  workDay: WorkDayCreateOneWithoutBillsInput;
  tableData: TableDataCreateOneWithoutBillsInput;
  status: BillStatus;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  payments?: Maybe<PaymentCreateManyWithoutBillInput>;
  wasReopen?: Maybe<Boolean>;
  reopenBills?: Maybe<BillCreateManyInput>;
  registered?: Maybe<Boolean>;
}

export interface PaymentCreateManyWithoutBillInput {
  create?: Maybe<
    PaymentCreateWithoutBillInput[] | PaymentCreateWithoutBillInput
  >;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
}

export interface PaymentCreateWithoutBillInput {
  id?: Maybe<ID_Input>;
  value: Float;
  paymentType: String;
  paymentTypeOption?: Maybe<String>;
  checkData?: Maybe<CheckDataCreateOneWithoutPaymentInput>;
  expense?: Maybe<ExpenseCreateOneWithoutPaymentInput>;
  isActive: Boolean;
}

export interface CheckDataCreateOneWithoutPaymentInput {
  create?: Maybe<CheckDataCreateWithoutPaymentInput>;
  connect?: Maybe<CheckDataWhereUniqueInput>;
}

export interface CheckDataCreateWithoutPaymentInput {
  id?: Maybe<ID_Input>;
  checkbookId?: Maybe<String>;
  compensationNumber?: Maybe<Int>;
  bankNumber?: Maybe<Int>;
}

export interface ExpenseCreateOneWithoutPaymentInput {
  create?: Maybe<ExpenseCreateWithoutPaymentInput>;
  connect?: Maybe<ExpenseWhereUniqueInput>;
}

export interface ExpenseCreateWithoutPaymentInput {
  id?: Maybe<ID_Input>;
  establishment?: Maybe<EstablishmentCreateOneWithoutExpensesInput>;
  NFE: Boolean;
  NFEReference?: Maybe<String>;
  expenseItems?: Maybe<ExpenseItemCreateManyInput>;
  date: DateTimeInput;
  executionDate: DateTimeInput;
}

export interface EstablishmentCreateOneWithoutExpensesInput {
  create?: Maybe<EstablishmentCreateWithoutExpensesInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutExpensesInput {
  id?: Maybe<ID_Input>;
  name: String;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId: String;
  valueInCashRegister: Float;
  maximumInCashRegister: Float;
  incomeMaxReference: Int;
  isOpen: Boolean;
  workingDays?: Maybe<WorkDayCreateManyWithoutEstablishmentInput>;
  permissions?: Maybe<PermissionCreateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemCreateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeCreateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableCreateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentCreatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientCreateManyWithoutEstablishmentInput>;
}

export interface EmployeeCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    | EmployeeCreateWithoutEstablishmentInput[]
    | EmployeeCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutEstablishmentInput {
  id?: Maybe<ID_Input>;
  employeeId: Int;
  name: String;
  role: String;
  tables?: Maybe<TableDataCreateManyWithoutWaiterInput>;
  orderPads?: Maybe<OrderPadCreateManyWithoutEmployeeInput>;
  itemsOrdered?: Maybe<OrderItemCreateManyWithoutEmployeeInput>;
  workHours?: Maybe<WorkHourCreateManyWithoutEmployeeInput>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive: Boolean;
}

export interface TableDataCreateManyWithoutWaiterInput {
  create?: Maybe<
    TableDataCreateWithoutWaiterInput[] | TableDataCreateWithoutWaiterInput
  >;
  connect?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
}

export interface TableDataCreateWithoutWaiterInput {
  id?: Maybe<ID_Input>;
  totalOccupations: Int;
  table: TableCreateOneWithoutDataInput;
  workDay: WorkDayCreateOneWithoutTablesInput;
  bills?: Maybe<BillCreateManyWithoutTableDataInput>;
}

export interface BillCreateManyWithoutTableDataInput {
  create?: Maybe<
    BillCreateWithoutTableDataInput[] | BillCreateWithoutTableDataInput
  >;
  connect?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
}

export interface BillCreateWithoutTableDataInput {
  closedAt?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  workDay: WorkDayCreateOneWithoutBillsInput;
  orders?: Maybe<OrderCreateManyWithoutBillInput>;
  status: BillStatus;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  payments?: Maybe<PaymentCreateManyWithoutBillInput>;
  wasReopen?: Maybe<Boolean>;
  reopenBills?: Maybe<BillCreateManyInput>;
  registered?: Maybe<Boolean>;
}

export interface OrderCreateManyWithoutBillInput {
  create?: Maybe<OrderCreateWithoutBillInput[] | OrderCreateWithoutBillInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
}

export interface OrderCreateWithoutBillInput {
  id?: Maybe<ID_Input>;
  workDay: WorkDayCreateOneWithoutOrdersInput;
  block: Int;
  orderId: Int;
  orderItems?: Maybe<OrderItemCreateManyWithoutOrderInput>;
  cancelled?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  modifiedOrders?: Maybe<OrderCreateManyInput>;
  isEmployeeOrder?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
}

export interface OrderItemCreateManyWithoutOrderInput {
  create?: Maybe<
    OrderItemCreateWithoutOrderInput[] | OrderItemCreateWithoutOrderInput
  >;
  connect?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
}

export interface OrderItemCreateWithoutOrderInput {
  id?: Maybe<ID_Input>;
  quantity: Int;
  item: ItemCreateOneWithoutOrderItemInput;
  employee?: Maybe<EmployeeCreateOneWithoutItemsOrderedInput>;
}

export interface ItemCreateOneWithoutOrderItemInput {
  create?: Maybe<ItemCreateWithoutOrderItemInput>;
  connect?: Maybe<ItemWhereUniqueInput>;
}

export interface ItemCreateWithoutOrderItemInput {
  id?: Maybe<ID_Input>;
  itemId: String;
  name: String;
  price: Float;
  priceToGo?: Maybe<Float>;
  employeePrice?: Maybe<Float>;
  category: String;
  establishment?: Maybe<EstablishmentCreateOneWithoutItemsInput>;
  canTakeToGo?: Maybe<Boolean>;
  isActive: Boolean;
  itemNCM?: Maybe<NCMCreateOneWithoutItemsInput>;
  hasTaxSubstitution?: Maybe<Boolean>;
}

export interface EstablishmentCreateOneWithoutItemsInput {
  create?: Maybe<EstablishmentCreateWithoutItemsInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutItemsInput {
  id?: Maybe<ID_Input>;
  name: String;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId: String;
  valueInCashRegister: Float;
  maximumInCashRegister: Float;
  incomeMaxReference: Int;
  isOpen: Boolean;
  workingDays?: Maybe<WorkDayCreateManyWithoutEstablishmentInput>;
  permissions?: Maybe<PermissionCreateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeCreateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableCreateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseCreateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentCreatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientCreateManyWithoutEstablishmentInput>;
}

export interface TableCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    | TableCreateWithoutEstablishmentInput[]
    | TableCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
}

export interface TableCreateWithoutEstablishmentInput {
  id?: Maybe<ID_Input>;
  tableNumber: Int;
  data?: Maybe<TableDataCreateManyWithoutTableInput>;
}

export interface TableDataCreateManyWithoutTableInput {
  create?: Maybe<
    TableDataCreateWithoutTableInput[] | TableDataCreateWithoutTableInput
  >;
  connect?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
}

export interface TableDataCreateWithoutTableInput {
  id?: Maybe<ID_Input>;
  totalOccupations: Int;
  workDay: WorkDayCreateOneWithoutTablesInput;
  waiter?: Maybe<EmployeeCreateOneWithoutTablesInput>;
  bills?: Maybe<BillCreateManyWithoutTableDataInput>;
}

export interface EmployeeCreateOneWithoutTablesInput {
  create?: Maybe<EmployeeCreateWithoutTablesInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutTablesInput {
  id?: Maybe<ID_Input>;
  establishment: EstablishmentCreateOneWithoutEmployeesInput;
  employeeId: Int;
  name: String;
  role: String;
  orderPads?: Maybe<OrderPadCreateManyWithoutEmployeeInput>;
  itemsOrdered?: Maybe<OrderItemCreateManyWithoutEmployeeInput>;
  workHours?: Maybe<WorkHourCreateManyWithoutEmployeeInput>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive: Boolean;
}

export interface EstablishmentCreateOneWithoutEmployeesInput {
  create?: Maybe<EstablishmentCreateWithoutEmployeesInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutEmployeesInput {
  id?: Maybe<ID_Input>;
  name: String;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId: String;
  valueInCashRegister: Float;
  maximumInCashRegister: Float;
  incomeMaxReference: Int;
  isOpen: Boolean;
  workingDays?: Maybe<WorkDayCreateManyWithoutEstablishmentInput>;
  permissions?: Maybe<PermissionCreateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemCreateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableCreateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseCreateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentCreatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientCreateManyWithoutEstablishmentInput>;
}

export interface ExpenseCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    | ExpenseCreateWithoutEstablishmentInput[]
    | ExpenseCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
}

export interface ExpenseCreateWithoutEstablishmentInput {
  id?: Maybe<ID_Input>;
  NFE: Boolean;
  NFEReference?: Maybe<String>;
  expenseItems?: Maybe<ExpenseItemCreateManyInput>;
  date: DateTimeInput;
  executionDate: DateTimeInput;
  payment?: Maybe<PaymentCreateOneWithoutExpenseInput>;
}

export interface ExpenseItemCreateManyInput {
  create?: Maybe<ExpenseItemCreateInput[] | ExpenseItemCreateInput>;
  connect?: Maybe<ExpenseItemWhereUniqueInput[] | ExpenseItemWhereUniqueInput>;
}

export interface ExpenseItemCreateInput {
  id?: Maybe<ID_Input>;
  quantity: Float;
  product: ProductCreateOneInput;
  value: Float;
  details?: Maybe<String>;
}

export interface ProductCreateOneInput {
  create?: Maybe<ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  category: String;
  supplier: String;
  brand?: Maybe<String>;
  unit: String;
}

export interface PaymentCreateOneWithoutExpenseInput {
  create?: Maybe<PaymentCreateWithoutExpenseInput>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentCreateWithoutExpenseInput {
  id?: Maybe<ID_Input>;
  value: Float;
  paymentType: String;
  paymentTypeOption?: Maybe<String>;
  checkData?: Maybe<CheckDataCreateOneWithoutPaymentInput>;
  bill?: Maybe<BillCreateOneWithoutPaymentsInput>;
  isActive: Boolean;
}

export interface BillCreateOneWithoutPaymentsInput {
  create?: Maybe<BillCreateWithoutPaymentsInput>;
  connect?: Maybe<BillWhereUniqueInput>;
}

export interface BillCreateWithoutPaymentsInput {
  closedAt?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  workDay: WorkDayCreateOneWithoutBillsInput;
  tableData: TableDataCreateOneWithoutBillsInput;
  orders?: Maybe<OrderCreateManyWithoutBillInput>;
  status: BillStatus;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  wasReopen?: Maybe<Boolean>;
  reopenBills?: Maybe<BillCreateManyInput>;
  registered?: Maybe<Boolean>;
}

export interface BillCreateManyInput {
  create?: Maybe<BillCreateInput[] | BillCreateInput>;
  connect?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
}

export interface EstablishmentCreatediscountReasonsInput {
  set?: Maybe<String[] | String>;
}

export interface ClientCreateManyWithoutEstablishmentInput {
  create?: Maybe<
    | ClientCreateWithoutEstablishmentInput[]
    | ClientCreateWithoutEstablishmentInput
  >;
  connect?: Maybe<ClientWhereUniqueInput[] | ClientWhereUniqueInput>;
}

export interface ClientCreateWithoutEstablishmentInput {
  id?: Maybe<ID_Input>;
  name: String;
  address: String;
  complement?: Maybe<String>;
  postCode: String;
  telephoneNumber: String;
  distanceKm: String;
  distanceTime: String;
}

export interface OrderPadCreateManyWithoutEmployeeInput {
  create?: Maybe<
    OrderPadCreateWithoutEmployeeInput[] | OrderPadCreateWithoutEmployeeInput
  >;
  connect?: Maybe<OrderPadWhereUniqueInput[] | OrderPadWhereUniqueInput>;
}

export interface OrderPadCreateWithoutEmployeeInput {
  id?: Maybe<ID_Input>;
  workDay?: Maybe<WorkDayCreateOneWithoutOrderPadsInput>;
  block: Int;
  firstOrderId: Int;
  lastOrderId?: Maybe<Int>;
  used: Boolean;
}

export interface WorkDayCreateOneWithoutOrderPadsInput {
  create?: Maybe<WorkDayCreateWithoutOrderPadsInput>;
  connect?: Maybe<WorkDayWhereUniqueInput>;
}

export interface WorkDayCreateWithoutOrderPadsInput {
  id?: Maybe<ID_Input>;
  establishment?: Maybe<EstablishmentCreateOneWithoutWorkingDaysInput>;
  isCurrent: Boolean;
  openDate: DateTimeInput;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserCreateOneWithoutResponsibleWorkDaysInput>;
  tables?: Maybe<TableDataCreateManyWithoutWorkDayInput>;
  incomes?: Maybe<IncomeCreateManyWithoutWorkDayInput>;
  bills?: Maybe<BillCreateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderCreateManyWithoutWorkDayInput>;
}

export interface OrderItemCreateManyWithoutEmployeeInput {
  create?: Maybe<
    OrderItemCreateWithoutEmployeeInput[] | OrderItemCreateWithoutEmployeeInput
  >;
  connect?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
}

export interface OrderItemCreateWithoutEmployeeInput {
  id?: Maybe<ID_Input>;
  quantity: Int;
  item: ItemCreateOneWithoutOrderItemInput;
  order?: Maybe<OrderCreateOneWithoutOrderItemsInput>;
}

export interface WorkHourCreateManyWithoutEmployeeInput {
  create?: Maybe<
    WorkHourCreateWithoutEmployeeInput[] | WorkHourCreateWithoutEmployeeInput
  >;
  connect?: Maybe<WorkHourWhereUniqueInput[] | WorkHourWhereUniqueInput>;
}

export interface WorkHourCreateWithoutEmployeeInput {
  id?: Maybe<ID_Input>;
  weekday: WeekDay;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  isDayOff?: Maybe<Boolean>;
}

export interface NCMCreateOneWithoutItemsInput {
  create?: Maybe<NCMCreateWithoutItemsInput>;
  connect?: Maybe<NCMWhereUniqueInput>;
}

export interface NCMCreateWithoutItemsInput {
  id?: Maybe<ID_Input>;
  identifier: String;
  description?: Maybe<String>;
}

export interface EmployeeCreateOneWithoutItemsOrderedInput {
  create?: Maybe<EmployeeCreateWithoutItemsOrderedInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutItemsOrderedInput {
  id?: Maybe<ID_Input>;
  establishment: EstablishmentCreateOneWithoutEmployeesInput;
  employeeId: Int;
  name: String;
  role: String;
  tables?: Maybe<TableDataCreateManyWithoutWaiterInput>;
  orderPads?: Maybe<OrderPadCreateManyWithoutEmployeeInput>;
  workHours?: Maybe<WorkHourCreateManyWithoutEmployeeInput>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive: Boolean;
}

export interface OrderCreateManyInput {
  create?: Maybe<OrderCreateInput[] | OrderCreateInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
}

export interface OrderCreateInput {
  id?: Maybe<ID_Input>;
  workDay: WorkDayCreateOneWithoutOrdersInput;
  block: Int;
  orderId: Int;
  bill?: Maybe<BillCreateOneWithoutOrdersInput>;
  orderItems?: Maybe<OrderItemCreateManyWithoutOrderInput>;
  cancelled?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  modifiedOrders?: Maybe<OrderCreateManyInput>;
  isEmployeeOrder?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
}

export interface OrderPadCreateManyWithoutWorkDayInput {
  create?: Maybe<
    OrderPadCreateWithoutWorkDayInput[] | OrderPadCreateWithoutWorkDayInput
  >;
  connect?: Maybe<OrderPadWhereUniqueInput[] | OrderPadWhereUniqueInput>;
}

export interface OrderPadCreateWithoutWorkDayInput {
  id?: Maybe<ID_Input>;
  block: Int;
  firstOrderId: Int;
  lastOrderId?: Maybe<Int>;
  employee?: Maybe<EmployeeCreateOneWithoutOrderPadsInput>;
  used: Boolean;
}

export interface EmployeeCreateOneWithoutOrderPadsInput {
  create?: Maybe<EmployeeCreateWithoutOrderPadsInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutOrderPadsInput {
  id?: Maybe<ID_Input>;
  establishment: EstablishmentCreateOneWithoutEmployeesInput;
  employeeId: Int;
  name: String;
  role: String;
  tables?: Maybe<TableDataCreateManyWithoutWaiterInput>;
  itemsOrdered?: Maybe<OrderItemCreateManyWithoutEmployeeInput>;
  workHours?: Maybe<WorkHourCreateManyWithoutEmployeeInput>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive: Boolean;
}

export interface BillUpdateInput {
  closedAt?: Maybe<DateTimeInput>;
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutBillsInput>;
  tableData?: Maybe<TableDataUpdateOneRequiredWithoutBillsInput>;
  orders?: Maybe<OrderUpdateManyWithoutBillInput>;
  status?: Maybe<BillStatus>;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  payments?: Maybe<PaymentUpdateManyWithoutBillInput>;
  wasReopen?: Maybe<Boolean>;
  reopenBills?: Maybe<BillUpdateManyInput>;
  registered?: Maybe<Boolean>;
}

export interface WorkDayUpdateOneRequiredWithoutBillsInput {
  create?: Maybe<WorkDayCreateWithoutBillsInput>;
  update?: Maybe<WorkDayUpdateWithoutBillsDataInput>;
  upsert?: Maybe<WorkDayUpsertWithoutBillsInput>;
  connect?: Maybe<WorkDayWhereUniqueInput>;
}

export interface WorkDayUpdateWithoutBillsDataInput {
  establishment?: Maybe<EstablishmentUpdateOneWithoutWorkingDaysInput>;
  isCurrent?: Maybe<Boolean>;
  openDate?: Maybe<DateTimeInput>;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserUpdateOneWithoutResponsibleWorkDaysInput>;
  tables?: Maybe<TableDataUpdateManyWithoutWorkDayInput>;
  incomes?: Maybe<IncomeUpdateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderUpdateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadUpdateManyWithoutWorkDayInput>;
}

export interface EstablishmentUpdateOneWithoutWorkingDaysInput {
  create?: Maybe<EstablishmentCreateWithoutWorkingDaysInput>;
  update?: Maybe<EstablishmentUpdateWithoutWorkingDaysDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutWorkingDaysInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutWorkingDaysDataInput {
  name?: Maybe<String>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId?: Maybe<String>;
  valueInCashRegister?: Maybe<Float>;
  maximumInCashRegister?: Maybe<Float>;
  incomeMaxReference?: Maybe<Int>;
  isOpen?: Maybe<Boolean>;
  permissions?: Maybe<PermissionUpdateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemUpdateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeUpdateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableUpdateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseUpdateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentUpdatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientUpdateManyWithoutEstablishmentInput>;
}

export interface PermissionUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    | PermissionCreateWithoutEstablishmentInput[]
    | PermissionCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<PermissionWhereUniqueInput[] | PermissionWhereUniqueInput>;
  connect?: Maybe<PermissionWhereUniqueInput[] | PermissionWhereUniqueInput>;
  set?: Maybe<PermissionWhereUniqueInput[] | PermissionWhereUniqueInput>;
  disconnect?: Maybe<PermissionWhereUniqueInput[] | PermissionWhereUniqueInput>;
  update?: Maybe<
    | PermissionUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | PermissionUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | PermissionUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | PermissionUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<PermissionScalarWhereInput[] | PermissionScalarWhereInput>;
  updateMany?: Maybe<
    | PermissionUpdateManyWithWhereNestedInput[]
    | PermissionUpdateManyWithWhereNestedInput
  >;
}

export interface PermissionUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: PermissionWhereUniqueInput;
  data: PermissionUpdateWithoutEstablishmentDataInput;
}

export interface PermissionUpdateWithoutEstablishmentDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutPermissionsInput>;
  role?: Maybe<UserRole>;
}

export interface UserUpdateOneRequiredWithoutPermissionsInput {
  create?: Maybe<UserCreateWithoutPermissionsInput>;
  update?: Maybe<UserUpdateWithoutPermissionsDataInput>;
  upsert?: Maybe<UserUpsertWithoutPermissionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPermissionsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  responsibleWorkDays?: Maybe<WorkDayUpdateManyWithoutUserResponsibleInput>;
}

export interface WorkDayUpdateManyWithoutUserResponsibleInput {
  create?: Maybe<
    | WorkDayCreateWithoutUserResponsibleInput[]
    | WorkDayCreateWithoutUserResponsibleInput
  >;
  delete?: Maybe<WorkDayWhereUniqueInput[] | WorkDayWhereUniqueInput>;
  connect?: Maybe<WorkDayWhereUniqueInput[] | WorkDayWhereUniqueInput>;
  set?: Maybe<WorkDayWhereUniqueInput[] | WorkDayWhereUniqueInput>;
  disconnect?: Maybe<WorkDayWhereUniqueInput[] | WorkDayWhereUniqueInput>;
  update?: Maybe<
    | WorkDayUpdateWithWhereUniqueWithoutUserResponsibleInput[]
    | WorkDayUpdateWithWhereUniqueWithoutUserResponsibleInput
  >;
  upsert?: Maybe<
    | WorkDayUpsertWithWhereUniqueWithoutUserResponsibleInput[]
    | WorkDayUpsertWithWhereUniqueWithoutUserResponsibleInput
  >;
  deleteMany?: Maybe<WorkDayScalarWhereInput[] | WorkDayScalarWhereInput>;
  updateMany?: Maybe<
    | WorkDayUpdateManyWithWhereNestedInput[]
    | WorkDayUpdateManyWithWhereNestedInput
  >;
}

export interface WorkDayUpdateWithWhereUniqueWithoutUserResponsibleInput {
  where: WorkDayWhereUniqueInput;
  data: WorkDayUpdateWithoutUserResponsibleDataInput;
}

export interface WorkDayUpdateWithoutUserResponsibleDataInput {
  establishment?: Maybe<EstablishmentUpdateOneWithoutWorkingDaysInput>;
  isCurrent?: Maybe<Boolean>;
  openDate?: Maybe<DateTimeInput>;
  closeDate?: Maybe<DateTimeInput>;
  tables?: Maybe<TableDataUpdateManyWithoutWorkDayInput>;
  incomes?: Maybe<IncomeUpdateManyWithoutWorkDayInput>;
  bills?: Maybe<BillUpdateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderUpdateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadUpdateManyWithoutWorkDayInput>;
}

export interface TableDataUpdateManyWithoutWorkDayInput {
  create?: Maybe<
    TableDataCreateWithoutWorkDayInput[] | TableDataCreateWithoutWorkDayInput
  >;
  delete?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
  connect?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
  set?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
  disconnect?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
  update?: Maybe<
    | TableDataUpdateWithWhereUniqueWithoutWorkDayInput[]
    | TableDataUpdateWithWhereUniqueWithoutWorkDayInput
  >;
  upsert?: Maybe<
    | TableDataUpsertWithWhereUniqueWithoutWorkDayInput[]
    | TableDataUpsertWithWhereUniqueWithoutWorkDayInput
  >;
  deleteMany?: Maybe<TableDataScalarWhereInput[] | TableDataScalarWhereInput>;
  updateMany?: Maybe<
    | TableDataUpdateManyWithWhereNestedInput[]
    | TableDataUpdateManyWithWhereNestedInput
  >;
}

export interface TableDataUpdateWithWhereUniqueWithoutWorkDayInput {
  where: TableDataWhereUniqueInput;
  data: TableDataUpdateWithoutWorkDayDataInput;
}

export interface TableDataUpdateWithoutWorkDayDataInput {
  totalOccupations?: Maybe<Int>;
  table?: Maybe<TableUpdateOneRequiredWithoutDataInput>;
  waiter?: Maybe<EmployeeUpdateOneWithoutTablesInput>;
  bills?: Maybe<BillUpdateManyWithoutTableDataInput>;
}

export interface TableUpdateOneRequiredWithoutDataInput {
  create?: Maybe<TableCreateWithoutDataInput>;
  update?: Maybe<TableUpdateWithoutDataDataInput>;
  upsert?: Maybe<TableUpsertWithoutDataInput>;
  connect?: Maybe<TableWhereUniqueInput>;
}

export interface TableUpdateWithoutDataDataInput {
  tableNumber?: Maybe<Int>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutTablesInput>;
}

export interface EstablishmentUpdateOneWithoutTablesInput {
  create?: Maybe<EstablishmentCreateWithoutTablesInput>;
  update?: Maybe<EstablishmentUpdateWithoutTablesDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutTablesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutTablesDataInput {
  name?: Maybe<String>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId?: Maybe<String>;
  valueInCashRegister?: Maybe<Float>;
  maximumInCashRegister?: Maybe<Float>;
  incomeMaxReference?: Maybe<Int>;
  isOpen?: Maybe<Boolean>;
  workingDays?: Maybe<WorkDayUpdateManyWithoutEstablishmentInput>;
  permissions?: Maybe<PermissionUpdateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemUpdateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeUpdateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseUpdateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentUpdatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientUpdateManyWithoutEstablishmentInput>;
}

export interface WorkDayUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    | WorkDayCreateWithoutEstablishmentInput[]
    | WorkDayCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<WorkDayWhereUniqueInput[] | WorkDayWhereUniqueInput>;
  connect?: Maybe<WorkDayWhereUniqueInput[] | WorkDayWhereUniqueInput>;
  set?: Maybe<WorkDayWhereUniqueInput[] | WorkDayWhereUniqueInput>;
  disconnect?: Maybe<WorkDayWhereUniqueInput[] | WorkDayWhereUniqueInput>;
  update?: Maybe<
    | WorkDayUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | WorkDayUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | WorkDayUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | WorkDayUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<WorkDayScalarWhereInput[] | WorkDayScalarWhereInput>;
  updateMany?: Maybe<
    | WorkDayUpdateManyWithWhereNestedInput[]
    | WorkDayUpdateManyWithWhereNestedInput
  >;
}

export interface WorkDayUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: WorkDayWhereUniqueInput;
  data: WorkDayUpdateWithoutEstablishmentDataInput;
}

export interface WorkDayUpdateWithoutEstablishmentDataInput {
  isCurrent?: Maybe<Boolean>;
  openDate?: Maybe<DateTimeInput>;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserUpdateOneWithoutResponsibleWorkDaysInput>;
  tables?: Maybe<TableDataUpdateManyWithoutWorkDayInput>;
  incomes?: Maybe<IncomeUpdateManyWithoutWorkDayInput>;
  bills?: Maybe<BillUpdateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderUpdateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadUpdateManyWithoutWorkDayInput>;
}

export interface UserUpdateOneWithoutResponsibleWorkDaysInput {
  create?: Maybe<UserCreateWithoutResponsibleWorkDaysInput>;
  update?: Maybe<UserUpdateWithoutResponsibleWorkDaysDataInput>;
  upsert?: Maybe<UserUpsertWithoutResponsibleWorkDaysInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutResponsibleWorkDaysDataInput {
  permissions?: Maybe<PermissionUpdateManyWithoutUserInput>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface PermissionUpdateManyWithoutUserInput {
  create?: Maybe<
    PermissionCreateWithoutUserInput[] | PermissionCreateWithoutUserInput
  >;
  delete?: Maybe<PermissionWhereUniqueInput[] | PermissionWhereUniqueInput>;
  connect?: Maybe<PermissionWhereUniqueInput[] | PermissionWhereUniqueInput>;
  set?: Maybe<PermissionWhereUniqueInput[] | PermissionWhereUniqueInput>;
  disconnect?: Maybe<PermissionWhereUniqueInput[] | PermissionWhereUniqueInput>;
  update?: Maybe<
    | PermissionUpdateWithWhereUniqueWithoutUserInput[]
    | PermissionUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | PermissionUpsertWithWhereUniqueWithoutUserInput[]
    | PermissionUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<PermissionScalarWhereInput[] | PermissionScalarWhereInput>;
  updateMany?: Maybe<
    | PermissionUpdateManyWithWhereNestedInput[]
    | PermissionUpdateManyWithWhereNestedInput
  >;
}

export interface PermissionUpdateWithWhereUniqueWithoutUserInput {
  where: PermissionWhereUniqueInput;
  data: PermissionUpdateWithoutUserDataInput;
}

export interface PermissionUpdateWithoutUserDataInput {
  establishment?: Maybe<EstablishmentUpdateOneRequiredWithoutPermissionsInput>;
  role?: Maybe<UserRole>;
}

export interface EstablishmentUpdateOneRequiredWithoutPermissionsInput {
  create?: Maybe<EstablishmentCreateWithoutPermissionsInput>;
  update?: Maybe<EstablishmentUpdateWithoutPermissionsDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutPermissionsInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutPermissionsDataInput {
  name?: Maybe<String>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId?: Maybe<String>;
  valueInCashRegister?: Maybe<Float>;
  maximumInCashRegister?: Maybe<Float>;
  incomeMaxReference?: Maybe<Int>;
  isOpen?: Maybe<Boolean>;
  workingDays?: Maybe<WorkDayUpdateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemUpdateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeUpdateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableUpdateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseUpdateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentUpdatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientUpdateManyWithoutEstablishmentInput>;
}

export interface ItemUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    ItemCreateWithoutEstablishmentInput[] | ItemCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | ItemUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | ItemUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface ItemUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutEstablishmentDataInput;
}

export interface ItemUpdateWithoutEstablishmentDataInput {
  itemId?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  priceToGo?: Maybe<Float>;
  employeePrice?: Maybe<Float>;
  category?: Maybe<String>;
  orderItem?: Maybe<OrderItemUpdateManyWithoutItemInput>;
  canTakeToGo?: Maybe<Boolean>;
  isActive?: Maybe<Boolean>;
  itemNCM?: Maybe<NCMUpdateOneWithoutItemsInput>;
  hasTaxSubstitution?: Maybe<Boolean>;
}

export interface OrderItemUpdateManyWithoutItemInput {
  create?: Maybe<
    OrderItemCreateWithoutItemInput[] | OrderItemCreateWithoutItemInput
  >;
  delete?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
  connect?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
  set?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
  disconnect?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
  update?: Maybe<
    | OrderItemUpdateWithWhereUniqueWithoutItemInput[]
    | OrderItemUpdateWithWhereUniqueWithoutItemInput
  >;
  upsert?: Maybe<
    | OrderItemUpsertWithWhereUniqueWithoutItemInput[]
    | OrderItemUpsertWithWhereUniqueWithoutItemInput
  >;
  deleteMany?: Maybe<OrderItemScalarWhereInput[] | OrderItemScalarWhereInput>;
  updateMany?: Maybe<
    | OrderItemUpdateManyWithWhereNestedInput[]
    | OrderItemUpdateManyWithWhereNestedInput
  >;
}

export interface OrderItemUpdateWithWhereUniqueWithoutItemInput {
  where: OrderItemWhereUniqueInput;
  data: OrderItemUpdateWithoutItemDataInput;
}

export interface OrderItemUpdateWithoutItemDataInput {
  quantity?: Maybe<Int>;
  order?: Maybe<OrderUpdateOneWithoutOrderItemsInput>;
  employee?: Maybe<EmployeeUpdateOneWithoutItemsOrderedInput>;
}

export interface OrderUpdateOneWithoutOrderItemsInput {
  create?: Maybe<OrderCreateWithoutOrderItemsInput>;
  update?: Maybe<OrderUpdateWithoutOrderItemsDataInput>;
  upsert?: Maybe<OrderUpsertWithoutOrderItemsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface OrderUpdateWithoutOrderItemsDataInput {
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutOrdersInput>;
  block?: Maybe<Int>;
  orderId?: Maybe<Int>;
  bill?: Maybe<BillUpdateOneWithoutOrdersInput>;
  cancelled?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  modifiedOrders?: Maybe<OrderUpdateManyInput>;
  isEmployeeOrder?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
}

export interface WorkDayUpdateOneRequiredWithoutOrdersInput {
  create?: Maybe<WorkDayCreateWithoutOrdersInput>;
  update?: Maybe<WorkDayUpdateWithoutOrdersDataInput>;
  upsert?: Maybe<WorkDayUpsertWithoutOrdersInput>;
  connect?: Maybe<WorkDayWhereUniqueInput>;
}

export interface WorkDayUpdateWithoutOrdersDataInput {
  establishment?: Maybe<EstablishmentUpdateOneWithoutWorkingDaysInput>;
  isCurrent?: Maybe<Boolean>;
  openDate?: Maybe<DateTimeInput>;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserUpdateOneWithoutResponsibleWorkDaysInput>;
  tables?: Maybe<TableDataUpdateManyWithoutWorkDayInput>;
  incomes?: Maybe<IncomeUpdateManyWithoutWorkDayInput>;
  bills?: Maybe<BillUpdateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadUpdateManyWithoutWorkDayInput>;
}

export interface IncomeUpdateManyWithoutWorkDayInput {
  create?: Maybe<
    IncomeCreateWithoutWorkDayInput[] | IncomeCreateWithoutWorkDayInput
  >;
  delete?: Maybe<IncomeWhereUniqueInput[] | IncomeWhereUniqueInput>;
  connect?: Maybe<IncomeWhereUniqueInput[] | IncomeWhereUniqueInput>;
  set?: Maybe<IncomeWhereUniqueInput[] | IncomeWhereUniqueInput>;
  disconnect?: Maybe<IncomeWhereUniqueInput[] | IncomeWhereUniqueInput>;
  update?: Maybe<
    | IncomeUpdateWithWhereUniqueWithoutWorkDayInput[]
    | IncomeUpdateWithWhereUniqueWithoutWorkDayInput
  >;
  upsert?: Maybe<
    | IncomeUpsertWithWhereUniqueWithoutWorkDayInput[]
    | IncomeUpsertWithWhereUniqueWithoutWorkDayInput
  >;
  deleteMany?: Maybe<IncomeScalarWhereInput[] | IncomeScalarWhereInput>;
  updateMany?: Maybe<
    | IncomeUpdateManyWithWhereNestedInput[]
    | IncomeUpdateManyWithWhereNestedInput
  >;
}

export interface IncomeUpdateWithWhereUniqueWithoutWorkDayInput {
  where: IncomeWhereUniqueInput;
  data: IncomeUpdateWithoutWorkDayDataInput;
}

export interface IncomeUpdateWithoutWorkDayDataInput {
  reference?: Maybe<String>;
  value?: Maybe<Float>;
  type?: Maybe<String>;
}

export interface IncomeUpsertWithWhereUniqueWithoutWorkDayInput {
  where: IncomeWhereUniqueInput;
  update: IncomeUpdateWithoutWorkDayDataInput;
  create: IncomeCreateWithoutWorkDayInput;
}

export interface IncomeScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  reference?: Maybe<String>;
  reference_not?: Maybe<String>;
  reference_in?: Maybe<String[] | String>;
  reference_not_in?: Maybe<String[] | String>;
  reference_lt?: Maybe<String>;
  reference_lte?: Maybe<String>;
  reference_gt?: Maybe<String>;
  reference_gte?: Maybe<String>;
  reference_contains?: Maybe<String>;
  reference_not_contains?: Maybe<String>;
  reference_starts_with?: Maybe<String>;
  reference_not_starts_with?: Maybe<String>;
  reference_ends_with?: Maybe<String>;
  reference_not_ends_with?: Maybe<String>;
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  AND?: Maybe<IncomeScalarWhereInput[] | IncomeScalarWhereInput>;
  OR?: Maybe<IncomeScalarWhereInput[] | IncomeScalarWhereInput>;
  NOT?: Maybe<IncomeScalarWhereInput[] | IncomeScalarWhereInput>;
}

export interface IncomeUpdateManyWithWhereNestedInput {
  where: IncomeScalarWhereInput;
  data: IncomeUpdateManyDataInput;
}

export interface IncomeUpdateManyDataInput {
  reference?: Maybe<String>;
  value?: Maybe<Float>;
  type?: Maybe<String>;
}

export interface BillUpdateManyWithoutWorkDayInput {
  create?: Maybe<
    BillCreateWithoutWorkDayInput[] | BillCreateWithoutWorkDayInput
  >;
  delete?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
  connect?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
  set?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
  disconnect?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
  update?: Maybe<
    | BillUpdateWithWhereUniqueWithoutWorkDayInput[]
    | BillUpdateWithWhereUniqueWithoutWorkDayInput
  >;
  upsert?: Maybe<
    | BillUpsertWithWhereUniqueWithoutWorkDayInput[]
    | BillUpsertWithWhereUniqueWithoutWorkDayInput
  >;
  deleteMany?: Maybe<BillScalarWhereInput[] | BillScalarWhereInput>;
  updateMany?: Maybe<
    BillUpdateManyWithWhereNestedInput[] | BillUpdateManyWithWhereNestedInput
  >;
}

export interface BillUpdateWithWhereUniqueWithoutWorkDayInput {
  where: BillWhereUniqueInput;
  data: BillUpdateWithoutWorkDayDataInput;
}

export interface BillUpdateWithoutWorkDayDataInput {
  closedAt?: Maybe<DateTimeInput>;
  tableData?: Maybe<TableDataUpdateOneRequiredWithoutBillsInput>;
  orders?: Maybe<OrderUpdateManyWithoutBillInput>;
  status?: Maybe<BillStatus>;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  payments?: Maybe<PaymentUpdateManyWithoutBillInput>;
  wasReopen?: Maybe<Boolean>;
  reopenBills?: Maybe<BillUpdateManyInput>;
  registered?: Maybe<Boolean>;
}

export interface TableDataUpdateOneRequiredWithoutBillsInput {
  create?: Maybe<TableDataCreateWithoutBillsInput>;
  update?: Maybe<TableDataUpdateWithoutBillsDataInput>;
  upsert?: Maybe<TableDataUpsertWithoutBillsInput>;
  connect?: Maybe<TableDataWhereUniqueInput>;
}

export interface TableDataUpdateWithoutBillsDataInput {
  totalOccupations?: Maybe<Int>;
  table?: Maybe<TableUpdateOneRequiredWithoutDataInput>;
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutTablesInput>;
  waiter?: Maybe<EmployeeUpdateOneWithoutTablesInput>;
}

export interface WorkDayUpdateOneRequiredWithoutTablesInput {
  create?: Maybe<WorkDayCreateWithoutTablesInput>;
  update?: Maybe<WorkDayUpdateWithoutTablesDataInput>;
  upsert?: Maybe<WorkDayUpsertWithoutTablesInput>;
  connect?: Maybe<WorkDayWhereUniqueInput>;
}

export interface WorkDayUpdateWithoutTablesDataInput {
  establishment?: Maybe<EstablishmentUpdateOneWithoutWorkingDaysInput>;
  isCurrent?: Maybe<Boolean>;
  openDate?: Maybe<DateTimeInput>;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserUpdateOneWithoutResponsibleWorkDaysInput>;
  incomes?: Maybe<IncomeUpdateManyWithoutWorkDayInput>;
  bills?: Maybe<BillUpdateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderUpdateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadUpdateManyWithoutWorkDayInput>;
}

export interface OrderUpdateManyWithoutWorkDayInput {
  create?: Maybe<
    OrderCreateWithoutWorkDayInput[] | OrderCreateWithoutWorkDayInput
  >;
  delete?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  set?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  disconnect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  update?: Maybe<
    | OrderUpdateWithWhereUniqueWithoutWorkDayInput[]
    | OrderUpdateWithWhereUniqueWithoutWorkDayInput
  >;
  upsert?: Maybe<
    | OrderUpsertWithWhereUniqueWithoutWorkDayInput[]
    | OrderUpsertWithWhereUniqueWithoutWorkDayInput
  >;
  deleteMany?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  updateMany?: Maybe<
    OrderUpdateManyWithWhereNestedInput[] | OrderUpdateManyWithWhereNestedInput
  >;
}

export interface OrderUpdateWithWhereUniqueWithoutWorkDayInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutWorkDayDataInput;
}

export interface OrderUpdateWithoutWorkDayDataInput {
  block?: Maybe<Int>;
  orderId?: Maybe<Int>;
  bill?: Maybe<BillUpdateOneWithoutOrdersInput>;
  orderItems?: Maybe<OrderItemUpdateManyWithoutOrderInput>;
  cancelled?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  modifiedOrders?: Maybe<OrderUpdateManyInput>;
  isEmployeeOrder?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
}

export interface BillUpdateOneWithoutOrdersInput {
  create?: Maybe<BillCreateWithoutOrdersInput>;
  update?: Maybe<BillUpdateWithoutOrdersDataInput>;
  upsert?: Maybe<BillUpsertWithoutOrdersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BillWhereUniqueInput>;
}

export interface BillUpdateWithoutOrdersDataInput {
  closedAt?: Maybe<DateTimeInput>;
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutBillsInput>;
  tableData?: Maybe<TableDataUpdateOneRequiredWithoutBillsInput>;
  status?: Maybe<BillStatus>;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  payments?: Maybe<PaymentUpdateManyWithoutBillInput>;
  wasReopen?: Maybe<Boolean>;
  reopenBills?: Maybe<BillUpdateManyInput>;
  registered?: Maybe<Boolean>;
}

export interface PaymentUpdateManyWithoutBillInput {
  create?: Maybe<
    PaymentCreateWithoutBillInput[] | PaymentCreateWithoutBillInput
  >;
  delete?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  set?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  disconnect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  update?: Maybe<
    | PaymentUpdateWithWhereUniqueWithoutBillInput[]
    | PaymentUpdateWithWhereUniqueWithoutBillInput
  >;
  upsert?: Maybe<
    | PaymentUpsertWithWhereUniqueWithoutBillInput[]
    | PaymentUpsertWithWhereUniqueWithoutBillInput
  >;
  deleteMany?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  updateMany?: Maybe<
    | PaymentUpdateManyWithWhereNestedInput[]
    | PaymentUpdateManyWithWhereNestedInput
  >;
}

export interface PaymentUpdateWithWhereUniqueWithoutBillInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutBillDataInput;
}

export interface PaymentUpdateWithoutBillDataInput {
  value?: Maybe<Float>;
  paymentType?: Maybe<String>;
  paymentTypeOption?: Maybe<String>;
  checkData?: Maybe<CheckDataUpdateOneWithoutPaymentInput>;
  expense?: Maybe<ExpenseUpdateOneWithoutPaymentInput>;
  isActive?: Maybe<Boolean>;
}

export interface CheckDataUpdateOneWithoutPaymentInput {
  create?: Maybe<CheckDataCreateWithoutPaymentInput>;
  update?: Maybe<CheckDataUpdateWithoutPaymentDataInput>;
  upsert?: Maybe<CheckDataUpsertWithoutPaymentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CheckDataWhereUniqueInput>;
}

export interface CheckDataUpdateWithoutPaymentDataInput {
  checkbookId?: Maybe<String>;
  compensationNumber?: Maybe<Int>;
  bankNumber?: Maybe<Int>;
}

export interface CheckDataUpsertWithoutPaymentInput {
  update: CheckDataUpdateWithoutPaymentDataInput;
  create: CheckDataCreateWithoutPaymentInput;
}

export interface ExpenseUpdateOneWithoutPaymentInput {
  create?: Maybe<ExpenseCreateWithoutPaymentInput>;
  update?: Maybe<ExpenseUpdateWithoutPaymentDataInput>;
  upsert?: Maybe<ExpenseUpsertWithoutPaymentInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ExpenseWhereUniqueInput>;
}

export interface ExpenseUpdateWithoutPaymentDataInput {
  establishment?: Maybe<EstablishmentUpdateOneWithoutExpensesInput>;
  NFE?: Maybe<Boolean>;
  NFEReference?: Maybe<String>;
  expenseItems?: Maybe<ExpenseItemUpdateManyInput>;
  date?: Maybe<DateTimeInput>;
  executionDate?: Maybe<DateTimeInput>;
}

export interface EstablishmentUpdateOneWithoutExpensesInput {
  create?: Maybe<EstablishmentCreateWithoutExpensesInput>;
  update?: Maybe<EstablishmentUpdateWithoutExpensesDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutExpensesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutExpensesDataInput {
  name?: Maybe<String>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId?: Maybe<String>;
  valueInCashRegister?: Maybe<Float>;
  maximumInCashRegister?: Maybe<Float>;
  incomeMaxReference?: Maybe<Int>;
  isOpen?: Maybe<Boolean>;
  workingDays?: Maybe<WorkDayUpdateManyWithoutEstablishmentInput>;
  permissions?: Maybe<PermissionUpdateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemUpdateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeUpdateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableUpdateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentUpdatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientUpdateManyWithoutEstablishmentInput>;
}

export interface EmployeeUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    | EmployeeCreateWithoutEstablishmentInput[]
    | EmployeeCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput>;
  connect?: Maybe<EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput>;
  set?: Maybe<EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput>;
  disconnect?: Maybe<EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput>;
  update?: Maybe<
    | EmployeeUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | EmployeeUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | EmployeeUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | EmployeeUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<EmployeeScalarWhereInput[] | EmployeeScalarWhereInput>;
  updateMany?: Maybe<
    | EmployeeUpdateManyWithWhereNestedInput[]
    | EmployeeUpdateManyWithWhereNestedInput
  >;
}

export interface EmployeeUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: EmployeeWhereUniqueInput;
  data: EmployeeUpdateWithoutEstablishmentDataInput;
}

export interface EmployeeUpdateWithoutEstablishmentDataInput {
  employeeId?: Maybe<Int>;
  name?: Maybe<String>;
  role?: Maybe<String>;
  tables?: Maybe<TableDataUpdateManyWithoutWaiterInput>;
  orderPads?: Maybe<OrderPadUpdateManyWithoutEmployeeInput>;
  itemsOrdered?: Maybe<OrderItemUpdateManyWithoutEmployeeInput>;
  workHours?: Maybe<WorkHourUpdateManyWithoutEmployeeInput>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
}

export interface TableDataUpdateManyWithoutWaiterInput {
  create?: Maybe<
    TableDataCreateWithoutWaiterInput[] | TableDataCreateWithoutWaiterInput
  >;
  delete?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
  connect?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
  set?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
  disconnect?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
  update?: Maybe<
    | TableDataUpdateWithWhereUniqueWithoutWaiterInput[]
    | TableDataUpdateWithWhereUniqueWithoutWaiterInput
  >;
  upsert?: Maybe<
    | TableDataUpsertWithWhereUniqueWithoutWaiterInput[]
    | TableDataUpsertWithWhereUniqueWithoutWaiterInput
  >;
  deleteMany?: Maybe<TableDataScalarWhereInput[] | TableDataScalarWhereInput>;
  updateMany?: Maybe<
    | TableDataUpdateManyWithWhereNestedInput[]
    | TableDataUpdateManyWithWhereNestedInput
  >;
}

export interface TableDataUpdateWithWhereUniqueWithoutWaiterInput {
  where: TableDataWhereUniqueInput;
  data: TableDataUpdateWithoutWaiterDataInput;
}

export interface TableDataUpdateWithoutWaiterDataInput {
  totalOccupations?: Maybe<Int>;
  table?: Maybe<TableUpdateOneRequiredWithoutDataInput>;
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutTablesInput>;
  bills?: Maybe<BillUpdateManyWithoutTableDataInput>;
}

export interface BillUpdateManyWithoutTableDataInput {
  create?: Maybe<
    BillCreateWithoutTableDataInput[] | BillCreateWithoutTableDataInput
  >;
  delete?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
  connect?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
  set?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
  disconnect?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
  update?: Maybe<
    | BillUpdateWithWhereUniqueWithoutTableDataInput[]
    | BillUpdateWithWhereUniqueWithoutTableDataInput
  >;
  upsert?: Maybe<
    | BillUpsertWithWhereUniqueWithoutTableDataInput[]
    | BillUpsertWithWhereUniqueWithoutTableDataInput
  >;
  deleteMany?: Maybe<BillScalarWhereInput[] | BillScalarWhereInput>;
  updateMany?: Maybe<
    BillUpdateManyWithWhereNestedInput[] | BillUpdateManyWithWhereNestedInput
  >;
}

export interface BillUpdateWithWhereUniqueWithoutTableDataInput {
  where: BillWhereUniqueInput;
  data: BillUpdateWithoutTableDataDataInput;
}

export interface BillUpdateWithoutTableDataDataInput {
  closedAt?: Maybe<DateTimeInput>;
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutBillsInput>;
  orders?: Maybe<OrderUpdateManyWithoutBillInput>;
  status?: Maybe<BillStatus>;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  payments?: Maybe<PaymentUpdateManyWithoutBillInput>;
  wasReopen?: Maybe<Boolean>;
  reopenBills?: Maybe<BillUpdateManyInput>;
  registered?: Maybe<Boolean>;
}

export interface OrderUpdateManyWithoutBillInput {
  create?: Maybe<OrderCreateWithoutBillInput[] | OrderCreateWithoutBillInput>;
  delete?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  set?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  disconnect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  update?: Maybe<
    | OrderUpdateWithWhereUniqueWithoutBillInput[]
    | OrderUpdateWithWhereUniqueWithoutBillInput
  >;
  upsert?: Maybe<
    | OrderUpsertWithWhereUniqueWithoutBillInput[]
    | OrderUpsertWithWhereUniqueWithoutBillInput
  >;
  deleteMany?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  updateMany?: Maybe<
    OrderUpdateManyWithWhereNestedInput[] | OrderUpdateManyWithWhereNestedInput
  >;
}

export interface OrderUpdateWithWhereUniqueWithoutBillInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutBillDataInput;
}

export interface OrderUpdateWithoutBillDataInput {
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutOrdersInput>;
  block?: Maybe<Int>;
  orderId?: Maybe<Int>;
  orderItems?: Maybe<OrderItemUpdateManyWithoutOrderInput>;
  cancelled?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  modifiedOrders?: Maybe<OrderUpdateManyInput>;
  isEmployeeOrder?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
}

export interface OrderItemUpdateManyWithoutOrderInput {
  create?: Maybe<
    OrderItemCreateWithoutOrderInput[] | OrderItemCreateWithoutOrderInput
  >;
  delete?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
  connect?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
  set?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
  disconnect?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
  update?: Maybe<
    | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    | OrderItemUpdateWithWhereUniqueWithoutOrderInput
  >;
  upsert?: Maybe<
    | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    | OrderItemUpsertWithWhereUniqueWithoutOrderInput
  >;
  deleteMany?: Maybe<OrderItemScalarWhereInput[] | OrderItemScalarWhereInput>;
  updateMany?: Maybe<
    | OrderItemUpdateManyWithWhereNestedInput[]
    | OrderItemUpdateManyWithWhereNestedInput
  >;
}

export interface OrderItemUpdateWithWhereUniqueWithoutOrderInput {
  where: OrderItemWhereUniqueInput;
  data: OrderItemUpdateWithoutOrderDataInput;
}

export interface OrderItemUpdateWithoutOrderDataInput {
  quantity?: Maybe<Int>;
  item?: Maybe<ItemUpdateOneRequiredWithoutOrderItemInput>;
  employee?: Maybe<EmployeeUpdateOneWithoutItemsOrderedInput>;
}

export interface ItemUpdateOneRequiredWithoutOrderItemInput {
  create?: Maybe<ItemCreateWithoutOrderItemInput>;
  update?: Maybe<ItemUpdateWithoutOrderItemDataInput>;
  upsert?: Maybe<ItemUpsertWithoutOrderItemInput>;
  connect?: Maybe<ItemWhereUniqueInput>;
}

export interface ItemUpdateWithoutOrderItemDataInput {
  itemId?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  priceToGo?: Maybe<Float>;
  employeePrice?: Maybe<Float>;
  category?: Maybe<String>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutItemsInput>;
  canTakeToGo?: Maybe<Boolean>;
  isActive?: Maybe<Boolean>;
  itemNCM?: Maybe<NCMUpdateOneWithoutItemsInput>;
  hasTaxSubstitution?: Maybe<Boolean>;
}

export interface EstablishmentUpdateOneWithoutItemsInput {
  create?: Maybe<EstablishmentCreateWithoutItemsInput>;
  update?: Maybe<EstablishmentUpdateWithoutItemsDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutItemsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutItemsDataInput {
  name?: Maybe<String>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId?: Maybe<String>;
  valueInCashRegister?: Maybe<Float>;
  maximumInCashRegister?: Maybe<Float>;
  incomeMaxReference?: Maybe<Int>;
  isOpen?: Maybe<Boolean>;
  workingDays?: Maybe<WorkDayUpdateManyWithoutEstablishmentInput>;
  permissions?: Maybe<PermissionUpdateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeUpdateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableUpdateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseUpdateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentUpdatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientUpdateManyWithoutEstablishmentInput>;
}

export interface TableUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    | TableCreateWithoutEstablishmentInput[]
    | TableCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  connect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  set?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  disconnect?: Maybe<TableWhereUniqueInput[] | TableWhereUniqueInput>;
  update?: Maybe<
    | TableUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | TableUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | TableUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | TableUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
  updateMany?: Maybe<
    TableUpdateManyWithWhereNestedInput[] | TableUpdateManyWithWhereNestedInput
  >;
}

export interface TableUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: TableWhereUniqueInput;
  data: TableUpdateWithoutEstablishmentDataInput;
}

export interface TableUpdateWithoutEstablishmentDataInput {
  tableNumber?: Maybe<Int>;
  data?: Maybe<TableDataUpdateManyWithoutTableInput>;
}

export interface TableDataUpdateManyWithoutTableInput {
  create?: Maybe<
    TableDataCreateWithoutTableInput[] | TableDataCreateWithoutTableInput
  >;
  delete?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
  connect?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
  set?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
  disconnect?: Maybe<TableDataWhereUniqueInput[] | TableDataWhereUniqueInput>;
  update?: Maybe<
    | TableDataUpdateWithWhereUniqueWithoutTableInput[]
    | TableDataUpdateWithWhereUniqueWithoutTableInput
  >;
  upsert?: Maybe<
    | TableDataUpsertWithWhereUniqueWithoutTableInput[]
    | TableDataUpsertWithWhereUniqueWithoutTableInput
  >;
  deleteMany?: Maybe<TableDataScalarWhereInput[] | TableDataScalarWhereInput>;
  updateMany?: Maybe<
    | TableDataUpdateManyWithWhereNestedInput[]
    | TableDataUpdateManyWithWhereNestedInput
  >;
}

export interface TableDataUpdateWithWhereUniqueWithoutTableInput {
  where: TableDataWhereUniqueInput;
  data: TableDataUpdateWithoutTableDataInput;
}

export interface TableDataUpdateWithoutTableDataInput {
  totalOccupations?: Maybe<Int>;
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutTablesInput>;
  waiter?: Maybe<EmployeeUpdateOneWithoutTablesInput>;
  bills?: Maybe<BillUpdateManyWithoutTableDataInput>;
}

export interface EmployeeUpdateOneWithoutTablesInput {
  create?: Maybe<EmployeeCreateWithoutTablesInput>;
  update?: Maybe<EmployeeUpdateWithoutTablesDataInput>;
  upsert?: Maybe<EmployeeUpsertWithoutTablesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeUpdateWithoutTablesDataInput {
  establishment?: Maybe<EstablishmentUpdateOneRequiredWithoutEmployeesInput>;
  employeeId?: Maybe<Int>;
  name?: Maybe<String>;
  role?: Maybe<String>;
  orderPads?: Maybe<OrderPadUpdateManyWithoutEmployeeInput>;
  itemsOrdered?: Maybe<OrderItemUpdateManyWithoutEmployeeInput>;
  workHours?: Maybe<WorkHourUpdateManyWithoutEmployeeInput>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
}

export interface EstablishmentUpdateOneRequiredWithoutEmployeesInput {
  create?: Maybe<EstablishmentCreateWithoutEmployeesInput>;
  update?: Maybe<EstablishmentUpdateWithoutEmployeesDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutEmployeesInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutEmployeesDataInput {
  name?: Maybe<String>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId?: Maybe<String>;
  valueInCashRegister?: Maybe<Float>;
  maximumInCashRegister?: Maybe<Float>;
  incomeMaxReference?: Maybe<Int>;
  isOpen?: Maybe<Boolean>;
  workingDays?: Maybe<WorkDayUpdateManyWithoutEstablishmentInput>;
  permissions?: Maybe<PermissionUpdateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemUpdateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableUpdateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseUpdateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentUpdatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientUpdateManyWithoutEstablishmentInput>;
}

export interface ExpenseUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    | ExpenseCreateWithoutEstablishmentInput[]
    | ExpenseCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
  connect?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
  set?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
  disconnect?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
  update?: Maybe<
    | ExpenseUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | ExpenseUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | ExpenseUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | ExpenseUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<ExpenseScalarWhereInput[] | ExpenseScalarWhereInput>;
  updateMany?: Maybe<
    | ExpenseUpdateManyWithWhereNestedInput[]
    | ExpenseUpdateManyWithWhereNestedInput
  >;
}

export interface ExpenseUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: ExpenseWhereUniqueInput;
  data: ExpenseUpdateWithoutEstablishmentDataInput;
}

export interface ExpenseUpdateWithoutEstablishmentDataInput {
  NFE?: Maybe<Boolean>;
  NFEReference?: Maybe<String>;
  expenseItems?: Maybe<ExpenseItemUpdateManyInput>;
  date?: Maybe<DateTimeInput>;
  executionDate?: Maybe<DateTimeInput>;
  payment?: Maybe<PaymentUpdateOneWithoutExpenseInput>;
}

export interface ExpenseItemUpdateManyInput {
  create?: Maybe<ExpenseItemCreateInput[] | ExpenseItemCreateInput>;
  update?: Maybe<
    | ExpenseItemUpdateWithWhereUniqueNestedInput[]
    | ExpenseItemUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ExpenseItemUpsertWithWhereUniqueNestedInput[]
    | ExpenseItemUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ExpenseItemWhereUniqueInput[] | ExpenseItemWhereUniqueInput>;
  connect?: Maybe<ExpenseItemWhereUniqueInput[] | ExpenseItemWhereUniqueInput>;
  set?: Maybe<ExpenseItemWhereUniqueInput[] | ExpenseItemWhereUniqueInput>;
  disconnect?: Maybe<
    ExpenseItemWhereUniqueInput[] | ExpenseItemWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ExpenseItemScalarWhereInput[] | ExpenseItemScalarWhereInput
  >;
  updateMany?: Maybe<
    | ExpenseItemUpdateManyWithWhereNestedInput[]
    | ExpenseItemUpdateManyWithWhereNestedInput
  >;
}

export interface ExpenseItemUpdateWithWhereUniqueNestedInput {
  where: ExpenseItemWhereUniqueInput;
  data: ExpenseItemUpdateDataInput;
}

export interface ExpenseItemUpdateDataInput {
  quantity?: Maybe<Float>;
  product?: Maybe<ProductUpdateOneRequiredInput>;
  value?: Maybe<Float>;
  details?: Maybe<String>;
}

export interface ProductUpdateOneRequiredInput {
  create?: Maybe<ProductCreateInput>;
  update?: Maybe<ProductUpdateDataInput>;
  upsert?: Maybe<ProductUpsertNestedInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductUpdateDataInput {
  name?: Maybe<String>;
  category?: Maybe<String>;
  supplier?: Maybe<String>;
  brand?: Maybe<String>;
  unit?: Maybe<String>;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface ExpenseItemUpsertWithWhereUniqueNestedInput {
  where: ExpenseItemWhereUniqueInput;
  update: ExpenseItemUpdateDataInput;
  create: ExpenseItemCreateInput;
}

export interface ExpenseItemScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<Float>;
  quantity_not?: Maybe<Float>;
  quantity_in?: Maybe<Float[] | Float>;
  quantity_not_in?: Maybe<Float[] | Float>;
  quantity_lt?: Maybe<Float>;
  quantity_lte?: Maybe<Float>;
  quantity_gt?: Maybe<Float>;
  quantity_gte?: Maybe<Float>;
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  details?: Maybe<String>;
  details_not?: Maybe<String>;
  details_in?: Maybe<String[] | String>;
  details_not_in?: Maybe<String[] | String>;
  details_lt?: Maybe<String>;
  details_lte?: Maybe<String>;
  details_gt?: Maybe<String>;
  details_gte?: Maybe<String>;
  details_contains?: Maybe<String>;
  details_not_contains?: Maybe<String>;
  details_starts_with?: Maybe<String>;
  details_not_starts_with?: Maybe<String>;
  details_ends_with?: Maybe<String>;
  details_not_ends_with?: Maybe<String>;
  AND?: Maybe<ExpenseItemScalarWhereInput[] | ExpenseItemScalarWhereInput>;
  OR?: Maybe<ExpenseItemScalarWhereInput[] | ExpenseItemScalarWhereInput>;
  NOT?: Maybe<ExpenseItemScalarWhereInput[] | ExpenseItemScalarWhereInput>;
}

export interface ExpenseItemUpdateManyWithWhereNestedInput {
  where: ExpenseItemScalarWhereInput;
  data: ExpenseItemUpdateManyDataInput;
}

export interface ExpenseItemUpdateManyDataInput {
  quantity?: Maybe<Float>;
  value?: Maybe<Float>;
  details?: Maybe<String>;
}

export interface PaymentUpdateOneWithoutExpenseInput {
  create?: Maybe<PaymentCreateWithoutExpenseInput>;
  update?: Maybe<PaymentUpdateWithoutExpenseDataInput>;
  upsert?: Maybe<PaymentUpsertWithoutExpenseInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentUpdateWithoutExpenseDataInput {
  value?: Maybe<Float>;
  paymentType?: Maybe<String>;
  paymentTypeOption?: Maybe<String>;
  checkData?: Maybe<CheckDataUpdateOneWithoutPaymentInput>;
  bill?: Maybe<BillUpdateOneWithoutPaymentsInput>;
  isActive?: Maybe<Boolean>;
}

export interface BillUpdateOneWithoutPaymentsInput {
  create?: Maybe<BillCreateWithoutPaymentsInput>;
  update?: Maybe<BillUpdateWithoutPaymentsDataInput>;
  upsert?: Maybe<BillUpsertWithoutPaymentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BillWhereUniqueInput>;
}

export interface BillUpdateWithoutPaymentsDataInput {
  closedAt?: Maybe<DateTimeInput>;
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutBillsInput>;
  tableData?: Maybe<TableDataUpdateOneRequiredWithoutBillsInput>;
  orders?: Maybe<OrderUpdateManyWithoutBillInput>;
  status?: Maybe<BillStatus>;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  wasReopen?: Maybe<Boolean>;
  reopenBills?: Maybe<BillUpdateManyInput>;
  registered?: Maybe<Boolean>;
}

export interface BillUpdateManyInput {
  create?: Maybe<BillCreateInput[] | BillCreateInput>;
  update?: Maybe<
    | BillUpdateWithWhereUniqueNestedInput[]
    | BillUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | BillUpsertWithWhereUniqueNestedInput[]
    | BillUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
  connect?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
  set?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
  disconnect?: Maybe<BillWhereUniqueInput[] | BillWhereUniqueInput>;
  deleteMany?: Maybe<BillScalarWhereInput[] | BillScalarWhereInput>;
  updateMany?: Maybe<
    BillUpdateManyWithWhereNestedInput[] | BillUpdateManyWithWhereNestedInput
  >;
}

export interface BillUpdateWithWhereUniqueNestedInput {
  where: BillWhereUniqueInput;
  data: BillUpdateDataInput;
}

export interface BillUpdateDataInput {
  closedAt?: Maybe<DateTimeInput>;
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutBillsInput>;
  tableData?: Maybe<TableDataUpdateOneRequiredWithoutBillsInput>;
  orders?: Maybe<OrderUpdateManyWithoutBillInput>;
  status?: Maybe<BillStatus>;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  payments?: Maybe<PaymentUpdateManyWithoutBillInput>;
  wasReopen?: Maybe<Boolean>;
  reopenBills?: Maybe<BillUpdateManyInput>;
  registered?: Maybe<Boolean>;
}

export interface BillUpsertWithWhereUniqueNestedInput {
  where: BillWhereUniqueInput;
  update: BillUpdateDataInput;
  create: BillCreateInput;
}

export interface BillScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  closedAt_not?: Maybe<DateTimeInput>;
  closedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closedAt_lt?: Maybe<DateTimeInput>;
  closedAt_lte?: Maybe<DateTimeInput>;
  closedAt_gt?: Maybe<DateTimeInput>;
  closedAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<BillStatus>;
  status_not?: Maybe<BillStatus>;
  status_in?: Maybe<BillStatus[] | BillStatus>;
  status_not_in?: Maybe<BillStatus[] | BillStatus>;
  discount?: Maybe<Float>;
  discount_not?: Maybe<Float>;
  discount_in?: Maybe<Float[] | Float>;
  discount_not_in?: Maybe<Float[] | Float>;
  discount_lt?: Maybe<Float>;
  discount_lte?: Maybe<Float>;
  discount_gt?: Maybe<Float>;
  discount_gte?: Maybe<Float>;
  discountReason?: Maybe<String>;
  discountReason_not?: Maybe<String>;
  discountReason_in?: Maybe<String[] | String>;
  discountReason_not_in?: Maybe<String[] | String>;
  discountReason_lt?: Maybe<String>;
  discountReason_lte?: Maybe<String>;
  discountReason_gt?: Maybe<String>;
  discountReason_gte?: Maybe<String>;
  discountReason_contains?: Maybe<String>;
  discountReason_not_contains?: Maybe<String>;
  discountReason_starts_with?: Maybe<String>;
  discountReason_not_starts_with?: Maybe<String>;
  discountReason_ends_with?: Maybe<String>;
  discountReason_not_ends_with?: Maybe<String>;
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  wasReopen?: Maybe<Boolean>;
  wasReopen_not?: Maybe<Boolean>;
  registered?: Maybe<Boolean>;
  registered_not?: Maybe<Boolean>;
  AND?: Maybe<BillScalarWhereInput[] | BillScalarWhereInput>;
  OR?: Maybe<BillScalarWhereInput[] | BillScalarWhereInput>;
  NOT?: Maybe<BillScalarWhereInput[] | BillScalarWhereInput>;
}

export interface BillUpdateManyWithWhereNestedInput {
  where: BillScalarWhereInput;
  data: BillUpdateManyDataInput;
}

export interface BillUpdateManyDataInput {
  closedAt?: Maybe<DateTimeInput>;
  status?: Maybe<BillStatus>;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  wasReopen?: Maybe<Boolean>;
  registered?: Maybe<Boolean>;
}

export interface BillUpsertWithoutPaymentsInput {
  update: BillUpdateWithoutPaymentsDataInput;
  create: BillCreateWithoutPaymentsInput;
}

export interface PaymentUpsertWithoutExpenseInput {
  update: PaymentUpdateWithoutExpenseDataInput;
  create: PaymentCreateWithoutExpenseInput;
}

export interface ExpenseUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: ExpenseWhereUniqueInput;
  update: ExpenseUpdateWithoutEstablishmentDataInput;
  create: ExpenseCreateWithoutEstablishmentInput;
}

export interface ExpenseScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  NFE?: Maybe<Boolean>;
  NFE_not?: Maybe<Boolean>;
  NFEReference?: Maybe<String>;
  NFEReference_not?: Maybe<String>;
  NFEReference_in?: Maybe<String[] | String>;
  NFEReference_not_in?: Maybe<String[] | String>;
  NFEReference_lt?: Maybe<String>;
  NFEReference_lte?: Maybe<String>;
  NFEReference_gt?: Maybe<String>;
  NFEReference_gte?: Maybe<String>;
  NFEReference_contains?: Maybe<String>;
  NFEReference_not_contains?: Maybe<String>;
  NFEReference_starts_with?: Maybe<String>;
  NFEReference_not_starts_with?: Maybe<String>;
  NFEReference_ends_with?: Maybe<String>;
  NFEReference_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  executionDate?: Maybe<DateTimeInput>;
  executionDate_not?: Maybe<DateTimeInput>;
  executionDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  executionDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  executionDate_lt?: Maybe<DateTimeInput>;
  executionDate_lte?: Maybe<DateTimeInput>;
  executionDate_gt?: Maybe<DateTimeInput>;
  executionDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExpenseScalarWhereInput[] | ExpenseScalarWhereInput>;
  OR?: Maybe<ExpenseScalarWhereInput[] | ExpenseScalarWhereInput>;
  NOT?: Maybe<ExpenseScalarWhereInput[] | ExpenseScalarWhereInput>;
}

export interface ExpenseUpdateManyWithWhereNestedInput {
  where: ExpenseScalarWhereInput;
  data: ExpenseUpdateManyDataInput;
}

export interface ExpenseUpdateManyDataInput {
  NFE?: Maybe<Boolean>;
  NFEReference?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  executionDate?: Maybe<DateTimeInput>;
}

export interface EstablishmentUpdatediscountReasonsInput {
  set?: Maybe<String[] | String>;
}

export interface ClientUpdateManyWithoutEstablishmentInput {
  create?: Maybe<
    | ClientCreateWithoutEstablishmentInput[]
    | ClientCreateWithoutEstablishmentInput
  >;
  delete?: Maybe<ClientWhereUniqueInput[] | ClientWhereUniqueInput>;
  connect?: Maybe<ClientWhereUniqueInput[] | ClientWhereUniqueInput>;
  set?: Maybe<ClientWhereUniqueInput[] | ClientWhereUniqueInput>;
  disconnect?: Maybe<ClientWhereUniqueInput[] | ClientWhereUniqueInput>;
  update?: Maybe<
    | ClientUpdateWithWhereUniqueWithoutEstablishmentInput[]
    | ClientUpdateWithWhereUniqueWithoutEstablishmentInput
  >;
  upsert?: Maybe<
    | ClientUpsertWithWhereUniqueWithoutEstablishmentInput[]
    | ClientUpsertWithWhereUniqueWithoutEstablishmentInput
  >;
  deleteMany?: Maybe<ClientScalarWhereInput[] | ClientScalarWhereInput>;
  updateMany?: Maybe<
    | ClientUpdateManyWithWhereNestedInput[]
    | ClientUpdateManyWithWhereNestedInput
  >;
}

export interface ClientUpdateWithWhereUniqueWithoutEstablishmentInput {
  where: ClientWhereUniqueInput;
  data: ClientUpdateWithoutEstablishmentDataInput;
}

export interface ClientUpdateWithoutEstablishmentDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  complement?: Maybe<String>;
  postCode?: Maybe<String>;
  telephoneNumber?: Maybe<String>;
  distanceKm?: Maybe<String>;
  distanceTime?: Maybe<String>;
}

export interface ClientUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: ClientWhereUniqueInput;
  update: ClientUpdateWithoutEstablishmentDataInput;
  create: ClientCreateWithoutEstablishmentInput;
}

export interface ClientScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  complement?: Maybe<String>;
  complement_not?: Maybe<String>;
  complement_in?: Maybe<String[] | String>;
  complement_not_in?: Maybe<String[] | String>;
  complement_lt?: Maybe<String>;
  complement_lte?: Maybe<String>;
  complement_gt?: Maybe<String>;
  complement_gte?: Maybe<String>;
  complement_contains?: Maybe<String>;
  complement_not_contains?: Maybe<String>;
  complement_starts_with?: Maybe<String>;
  complement_not_starts_with?: Maybe<String>;
  complement_ends_with?: Maybe<String>;
  complement_not_ends_with?: Maybe<String>;
  postCode?: Maybe<String>;
  postCode_not?: Maybe<String>;
  postCode_in?: Maybe<String[] | String>;
  postCode_not_in?: Maybe<String[] | String>;
  postCode_lt?: Maybe<String>;
  postCode_lte?: Maybe<String>;
  postCode_gt?: Maybe<String>;
  postCode_gte?: Maybe<String>;
  postCode_contains?: Maybe<String>;
  postCode_not_contains?: Maybe<String>;
  postCode_starts_with?: Maybe<String>;
  postCode_not_starts_with?: Maybe<String>;
  postCode_ends_with?: Maybe<String>;
  postCode_not_ends_with?: Maybe<String>;
  telephoneNumber?: Maybe<String>;
  telephoneNumber_not?: Maybe<String>;
  telephoneNumber_in?: Maybe<String[] | String>;
  telephoneNumber_not_in?: Maybe<String[] | String>;
  telephoneNumber_lt?: Maybe<String>;
  telephoneNumber_lte?: Maybe<String>;
  telephoneNumber_gt?: Maybe<String>;
  telephoneNumber_gte?: Maybe<String>;
  telephoneNumber_contains?: Maybe<String>;
  telephoneNumber_not_contains?: Maybe<String>;
  telephoneNumber_starts_with?: Maybe<String>;
  telephoneNumber_not_starts_with?: Maybe<String>;
  telephoneNumber_ends_with?: Maybe<String>;
  telephoneNumber_not_ends_with?: Maybe<String>;
  distanceKm?: Maybe<String>;
  distanceKm_not?: Maybe<String>;
  distanceKm_in?: Maybe<String[] | String>;
  distanceKm_not_in?: Maybe<String[] | String>;
  distanceKm_lt?: Maybe<String>;
  distanceKm_lte?: Maybe<String>;
  distanceKm_gt?: Maybe<String>;
  distanceKm_gte?: Maybe<String>;
  distanceKm_contains?: Maybe<String>;
  distanceKm_not_contains?: Maybe<String>;
  distanceKm_starts_with?: Maybe<String>;
  distanceKm_not_starts_with?: Maybe<String>;
  distanceKm_ends_with?: Maybe<String>;
  distanceKm_not_ends_with?: Maybe<String>;
  distanceTime?: Maybe<String>;
  distanceTime_not?: Maybe<String>;
  distanceTime_in?: Maybe<String[] | String>;
  distanceTime_not_in?: Maybe<String[] | String>;
  distanceTime_lt?: Maybe<String>;
  distanceTime_lte?: Maybe<String>;
  distanceTime_gt?: Maybe<String>;
  distanceTime_gte?: Maybe<String>;
  distanceTime_contains?: Maybe<String>;
  distanceTime_not_contains?: Maybe<String>;
  distanceTime_starts_with?: Maybe<String>;
  distanceTime_not_starts_with?: Maybe<String>;
  distanceTime_ends_with?: Maybe<String>;
  distanceTime_not_ends_with?: Maybe<String>;
  AND?: Maybe<ClientScalarWhereInput[] | ClientScalarWhereInput>;
  OR?: Maybe<ClientScalarWhereInput[] | ClientScalarWhereInput>;
  NOT?: Maybe<ClientScalarWhereInput[] | ClientScalarWhereInput>;
}

export interface ClientUpdateManyWithWhereNestedInput {
  where: ClientScalarWhereInput;
  data: ClientUpdateManyDataInput;
}

export interface ClientUpdateManyDataInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  complement?: Maybe<String>;
  postCode?: Maybe<String>;
  telephoneNumber?: Maybe<String>;
  distanceKm?: Maybe<String>;
  distanceTime?: Maybe<String>;
}

export interface EstablishmentUpsertWithoutEmployeesInput {
  update: EstablishmentUpdateWithoutEmployeesDataInput;
  create: EstablishmentCreateWithoutEmployeesInput;
}

export interface OrderPadUpdateManyWithoutEmployeeInput {
  create?: Maybe<
    OrderPadCreateWithoutEmployeeInput[] | OrderPadCreateWithoutEmployeeInput
  >;
  delete?: Maybe<OrderPadWhereUniqueInput[] | OrderPadWhereUniqueInput>;
  connect?: Maybe<OrderPadWhereUniqueInput[] | OrderPadWhereUniqueInput>;
  set?: Maybe<OrderPadWhereUniqueInput[] | OrderPadWhereUniqueInput>;
  disconnect?: Maybe<OrderPadWhereUniqueInput[] | OrderPadWhereUniqueInput>;
  update?: Maybe<
    | OrderPadUpdateWithWhereUniqueWithoutEmployeeInput[]
    | OrderPadUpdateWithWhereUniqueWithoutEmployeeInput
  >;
  upsert?: Maybe<
    | OrderPadUpsertWithWhereUniqueWithoutEmployeeInput[]
    | OrderPadUpsertWithWhereUniqueWithoutEmployeeInput
  >;
  deleteMany?: Maybe<OrderPadScalarWhereInput[] | OrderPadScalarWhereInput>;
  updateMany?: Maybe<
    | OrderPadUpdateManyWithWhereNestedInput[]
    | OrderPadUpdateManyWithWhereNestedInput
  >;
}

export interface OrderPadUpdateWithWhereUniqueWithoutEmployeeInput {
  where: OrderPadWhereUniqueInput;
  data: OrderPadUpdateWithoutEmployeeDataInput;
}

export interface OrderPadUpdateWithoutEmployeeDataInput {
  workDay?: Maybe<WorkDayUpdateOneWithoutOrderPadsInput>;
  block?: Maybe<Int>;
  firstOrderId?: Maybe<Int>;
  lastOrderId?: Maybe<Int>;
  used?: Maybe<Boolean>;
}

export interface WorkDayUpdateOneWithoutOrderPadsInput {
  create?: Maybe<WorkDayCreateWithoutOrderPadsInput>;
  update?: Maybe<WorkDayUpdateWithoutOrderPadsDataInput>;
  upsert?: Maybe<WorkDayUpsertWithoutOrderPadsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<WorkDayWhereUniqueInput>;
}

export interface WorkDayUpdateWithoutOrderPadsDataInput {
  establishment?: Maybe<EstablishmentUpdateOneWithoutWorkingDaysInput>;
  isCurrent?: Maybe<Boolean>;
  openDate?: Maybe<DateTimeInput>;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserUpdateOneWithoutResponsibleWorkDaysInput>;
  tables?: Maybe<TableDataUpdateManyWithoutWorkDayInput>;
  incomes?: Maybe<IncomeUpdateManyWithoutWorkDayInput>;
  bills?: Maybe<BillUpdateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderUpdateManyWithoutWorkDayInput>;
}

export interface WorkDayUpsertWithoutOrderPadsInput {
  update: WorkDayUpdateWithoutOrderPadsDataInput;
  create: WorkDayCreateWithoutOrderPadsInput;
}

export interface OrderPadUpsertWithWhereUniqueWithoutEmployeeInput {
  where: OrderPadWhereUniqueInput;
  update: OrderPadUpdateWithoutEmployeeDataInput;
  create: OrderPadCreateWithoutEmployeeInput;
}

export interface OrderPadScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  block?: Maybe<Int>;
  block_not?: Maybe<Int>;
  block_in?: Maybe<Int[] | Int>;
  block_not_in?: Maybe<Int[] | Int>;
  block_lt?: Maybe<Int>;
  block_lte?: Maybe<Int>;
  block_gt?: Maybe<Int>;
  block_gte?: Maybe<Int>;
  firstOrderId?: Maybe<Int>;
  firstOrderId_not?: Maybe<Int>;
  firstOrderId_in?: Maybe<Int[] | Int>;
  firstOrderId_not_in?: Maybe<Int[] | Int>;
  firstOrderId_lt?: Maybe<Int>;
  firstOrderId_lte?: Maybe<Int>;
  firstOrderId_gt?: Maybe<Int>;
  firstOrderId_gte?: Maybe<Int>;
  lastOrderId?: Maybe<Int>;
  lastOrderId_not?: Maybe<Int>;
  lastOrderId_in?: Maybe<Int[] | Int>;
  lastOrderId_not_in?: Maybe<Int[] | Int>;
  lastOrderId_lt?: Maybe<Int>;
  lastOrderId_lte?: Maybe<Int>;
  lastOrderId_gt?: Maybe<Int>;
  lastOrderId_gte?: Maybe<Int>;
  used?: Maybe<Boolean>;
  used_not?: Maybe<Boolean>;
  AND?: Maybe<OrderPadScalarWhereInput[] | OrderPadScalarWhereInput>;
  OR?: Maybe<OrderPadScalarWhereInput[] | OrderPadScalarWhereInput>;
  NOT?: Maybe<OrderPadScalarWhereInput[] | OrderPadScalarWhereInput>;
}

export interface OrderPadUpdateManyWithWhereNestedInput {
  where: OrderPadScalarWhereInput;
  data: OrderPadUpdateManyDataInput;
}

export interface OrderPadUpdateManyDataInput {
  block?: Maybe<Int>;
  firstOrderId?: Maybe<Int>;
  lastOrderId?: Maybe<Int>;
  used?: Maybe<Boolean>;
}

export interface OrderItemUpdateManyWithoutEmployeeInput {
  create?: Maybe<
    OrderItemCreateWithoutEmployeeInput[] | OrderItemCreateWithoutEmployeeInput
  >;
  delete?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
  connect?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
  set?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
  disconnect?: Maybe<OrderItemWhereUniqueInput[] | OrderItemWhereUniqueInput>;
  update?: Maybe<
    | OrderItemUpdateWithWhereUniqueWithoutEmployeeInput[]
    | OrderItemUpdateWithWhereUniqueWithoutEmployeeInput
  >;
  upsert?: Maybe<
    | OrderItemUpsertWithWhereUniqueWithoutEmployeeInput[]
    | OrderItemUpsertWithWhereUniqueWithoutEmployeeInput
  >;
  deleteMany?: Maybe<OrderItemScalarWhereInput[] | OrderItemScalarWhereInput>;
  updateMany?: Maybe<
    | OrderItemUpdateManyWithWhereNestedInput[]
    | OrderItemUpdateManyWithWhereNestedInput
  >;
}

export interface OrderItemUpdateWithWhereUniqueWithoutEmployeeInput {
  where: OrderItemWhereUniqueInput;
  data: OrderItemUpdateWithoutEmployeeDataInput;
}

export interface OrderItemUpdateWithoutEmployeeDataInput {
  quantity?: Maybe<Int>;
  item?: Maybe<ItemUpdateOneRequiredWithoutOrderItemInput>;
  order?: Maybe<OrderUpdateOneWithoutOrderItemsInput>;
}

export interface OrderItemUpsertWithWhereUniqueWithoutEmployeeInput {
  where: OrderItemWhereUniqueInput;
  update: OrderItemUpdateWithoutEmployeeDataInput;
  create: OrderItemCreateWithoutEmployeeInput;
}

export interface OrderItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  AND?: Maybe<OrderItemScalarWhereInput[] | OrderItemScalarWhereInput>;
  OR?: Maybe<OrderItemScalarWhereInput[] | OrderItemScalarWhereInput>;
  NOT?: Maybe<OrderItemScalarWhereInput[] | OrderItemScalarWhereInput>;
}

export interface OrderItemUpdateManyWithWhereNestedInput {
  where: OrderItemScalarWhereInput;
  data: OrderItemUpdateManyDataInput;
}

export interface OrderItemUpdateManyDataInput {
  quantity?: Maybe<Int>;
}

export interface WorkHourUpdateManyWithoutEmployeeInput {
  create?: Maybe<
    WorkHourCreateWithoutEmployeeInput[] | WorkHourCreateWithoutEmployeeInput
  >;
  delete?: Maybe<WorkHourWhereUniqueInput[] | WorkHourWhereUniqueInput>;
  connect?: Maybe<WorkHourWhereUniqueInput[] | WorkHourWhereUniqueInput>;
  set?: Maybe<WorkHourWhereUniqueInput[] | WorkHourWhereUniqueInput>;
  disconnect?: Maybe<WorkHourWhereUniqueInput[] | WorkHourWhereUniqueInput>;
  update?: Maybe<
    | WorkHourUpdateWithWhereUniqueWithoutEmployeeInput[]
    | WorkHourUpdateWithWhereUniqueWithoutEmployeeInput
  >;
  upsert?: Maybe<
    | WorkHourUpsertWithWhereUniqueWithoutEmployeeInput[]
    | WorkHourUpsertWithWhereUniqueWithoutEmployeeInput
  >;
  deleteMany?: Maybe<WorkHourScalarWhereInput[] | WorkHourScalarWhereInput>;
  updateMany?: Maybe<
    | WorkHourUpdateManyWithWhereNestedInput[]
    | WorkHourUpdateManyWithWhereNestedInput
  >;
}

export interface WorkHourUpdateWithWhereUniqueWithoutEmployeeInput {
  where: WorkHourWhereUniqueInput;
  data: WorkHourUpdateWithoutEmployeeDataInput;
}

export interface WorkHourUpdateWithoutEmployeeDataInput {
  weekday?: Maybe<WeekDay>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  isDayOff?: Maybe<Boolean>;
}

export interface WorkHourUpsertWithWhereUniqueWithoutEmployeeInput {
  where: WorkHourWhereUniqueInput;
  update: WorkHourUpdateWithoutEmployeeDataInput;
  create: WorkHourCreateWithoutEmployeeInput;
}

export interface WorkHourScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  weekday?: Maybe<WeekDay>;
  weekday_not?: Maybe<WeekDay>;
  weekday_in?: Maybe<WeekDay[] | WeekDay>;
  weekday_not_in?: Maybe<WeekDay[] | WeekDay>;
  startTime?: Maybe<String>;
  startTime_not?: Maybe<String>;
  startTime_in?: Maybe<String[] | String>;
  startTime_not_in?: Maybe<String[] | String>;
  startTime_lt?: Maybe<String>;
  startTime_lte?: Maybe<String>;
  startTime_gt?: Maybe<String>;
  startTime_gte?: Maybe<String>;
  startTime_contains?: Maybe<String>;
  startTime_not_contains?: Maybe<String>;
  startTime_starts_with?: Maybe<String>;
  startTime_not_starts_with?: Maybe<String>;
  startTime_ends_with?: Maybe<String>;
  startTime_not_ends_with?: Maybe<String>;
  endTime?: Maybe<String>;
  endTime_not?: Maybe<String>;
  endTime_in?: Maybe<String[] | String>;
  endTime_not_in?: Maybe<String[] | String>;
  endTime_lt?: Maybe<String>;
  endTime_lte?: Maybe<String>;
  endTime_gt?: Maybe<String>;
  endTime_gte?: Maybe<String>;
  endTime_contains?: Maybe<String>;
  endTime_not_contains?: Maybe<String>;
  endTime_starts_with?: Maybe<String>;
  endTime_not_starts_with?: Maybe<String>;
  endTime_ends_with?: Maybe<String>;
  endTime_not_ends_with?: Maybe<String>;
  isDayOff?: Maybe<Boolean>;
  isDayOff_not?: Maybe<Boolean>;
  AND?: Maybe<WorkHourScalarWhereInput[] | WorkHourScalarWhereInput>;
  OR?: Maybe<WorkHourScalarWhereInput[] | WorkHourScalarWhereInput>;
  NOT?: Maybe<WorkHourScalarWhereInput[] | WorkHourScalarWhereInput>;
}

export interface WorkHourUpdateManyWithWhereNestedInput {
  where: WorkHourScalarWhereInput;
  data: WorkHourUpdateManyDataInput;
}

export interface WorkHourUpdateManyDataInput {
  weekday?: Maybe<WeekDay>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  isDayOff?: Maybe<Boolean>;
}

export interface EmployeeUpsertWithoutTablesInput {
  update: EmployeeUpdateWithoutTablesDataInput;
  create: EmployeeCreateWithoutTablesInput;
}

export interface TableDataUpsertWithWhereUniqueWithoutTableInput {
  where: TableDataWhereUniqueInput;
  update: TableDataUpdateWithoutTableDataInput;
  create: TableDataCreateWithoutTableInput;
}

export interface TableDataScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  totalOccupations?: Maybe<Int>;
  totalOccupations_not?: Maybe<Int>;
  totalOccupations_in?: Maybe<Int[] | Int>;
  totalOccupations_not_in?: Maybe<Int[] | Int>;
  totalOccupations_lt?: Maybe<Int>;
  totalOccupations_lte?: Maybe<Int>;
  totalOccupations_gt?: Maybe<Int>;
  totalOccupations_gte?: Maybe<Int>;
  AND?: Maybe<TableDataScalarWhereInput[] | TableDataScalarWhereInput>;
  OR?: Maybe<TableDataScalarWhereInput[] | TableDataScalarWhereInput>;
  NOT?: Maybe<TableDataScalarWhereInput[] | TableDataScalarWhereInput>;
}

export interface TableDataUpdateManyWithWhereNestedInput {
  where: TableDataScalarWhereInput;
  data: TableDataUpdateManyDataInput;
}

export interface TableDataUpdateManyDataInput {
  totalOccupations?: Maybe<Int>;
}

export interface TableUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: TableWhereUniqueInput;
  update: TableUpdateWithoutEstablishmentDataInput;
  create: TableCreateWithoutEstablishmentInput;
}

export interface TableScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  tableNumber?: Maybe<Int>;
  tableNumber_not?: Maybe<Int>;
  tableNumber_in?: Maybe<Int[] | Int>;
  tableNumber_not_in?: Maybe<Int[] | Int>;
  tableNumber_lt?: Maybe<Int>;
  tableNumber_lte?: Maybe<Int>;
  tableNumber_gt?: Maybe<Int>;
  tableNumber_gte?: Maybe<Int>;
  AND?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
  OR?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
  NOT?: Maybe<TableScalarWhereInput[] | TableScalarWhereInput>;
}

export interface TableUpdateManyWithWhereNestedInput {
  where: TableScalarWhereInput;
  data: TableUpdateManyDataInput;
}

export interface TableUpdateManyDataInput {
  tableNumber?: Maybe<Int>;
}

export interface EstablishmentUpsertWithoutItemsInput {
  update: EstablishmentUpdateWithoutItemsDataInput;
  create: EstablishmentCreateWithoutItemsInput;
}

export interface NCMUpdateOneWithoutItemsInput {
  create?: Maybe<NCMCreateWithoutItemsInput>;
  update?: Maybe<NCMUpdateWithoutItemsDataInput>;
  upsert?: Maybe<NCMUpsertWithoutItemsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<NCMWhereUniqueInput>;
}

export interface NCMUpdateWithoutItemsDataInput {
  identifier?: Maybe<String>;
  description?: Maybe<String>;
}

export interface NCMUpsertWithoutItemsInput {
  update: NCMUpdateWithoutItemsDataInput;
  create: NCMCreateWithoutItemsInput;
}

export interface ItemUpsertWithoutOrderItemInput {
  update: ItemUpdateWithoutOrderItemDataInput;
  create: ItemCreateWithoutOrderItemInput;
}

export interface EmployeeUpdateOneWithoutItemsOrderedInput {
  create?: Maybe<EmployeeCreateWithoutItemsOrderedInput>;
  update?: Maybe<EmployeeUpdateWithoutItemsOrderedDataInput>;
  upsert?: Maybe<EmployeeUpsertWithoutItemsOrderedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeUpdateWithoutItemsOrderedDataInput {
  establishment?: Maybe<EstablishmentUpdateOneRequiredWithoutEmployeesInput>;
  employeeId?: Maybe<Int>;
  name?: Maybe<String>;
  role?: Maybe<String>;
  tables?: Maybe<TableDataUpdateManyWithoutWaiterInput>;
  orderPads?: Maybe<OrderPadUpdateManyWithoutEmployeeInput>;
  workHours?: Maybe<WorkHourUpdateManyWithoutEmployeeInput>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
}

export interface EmployeeUpsertWithoutItemsOrderedInput {
  update: EmployeeUpdateWithoutItemsOrderedDataInput;
  create: EmployeeCreateWithoutItemsOrderedInput;
}

export interface OrderItemUpsertWithWhereUniqueWithoutOrderInput {
  where: OrderItemWhereUniqueInput;
  update: OrderItemUpdateWithoutOrderDataInput;
  create: OrderItemCreateWithoutOrderInput;
}

export interface OrderUpdateManyInput {
  create?: Maybe<OrderCreateInput[] | OrderCreateInput>;
  update?: Maybe<
    | OrderUpdateWithWhereUniqueNestedInput[]
    | OrderUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | OrderUpsertWithWhereUniqueNestedInput[]
    | OrderUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  set?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  disconnect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  deleteMany?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  updateMany?: Maybe<
    OrderUpdateManyWithWhereNestedInput[] | OrderUpdateManyWithWhereNestedInput
  >;
}

export interface OrderUpdateWithWhereUniqueNestedInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateDataInput;
}

export interface OrderUpdateDataInput {
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutOrdersInput>;
  block?: Maybe<Int>;
  orderId?: Maybe<Int>;
  bill?: Maybe<BillUpdateOneWithoutOrdersInput>;
  orderItems?: Maybe<OrderItemUpdateManyWithoutOrderInput>;
  cancelled?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  modifiedOrders?: Maybe<OrderUpdateManyInput>;
  isEmployeeOrder?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
}

export interface OrderUpsertWithWhereUniqueNestedInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateDataInput;
  create: OrderCreateInput;
}

export interface OrderScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  block?: Maybe<Int>;
  block_not?: Maybe<Int>;
  block_in?: Maybe<Int[] | Int>;
  block_not_in?: Maybe<Int[] | Int>;
  block_lt?: Maybe<Int>;
  block_lte?: Maybe<Int>;
  block_gt?: Maybe<Int>;
  block_gte?: Maybe<Int>;
  orderId?: Maybe<Int>;
  orderId_not?: Maybe<Int>;
  orderId_in?: Maybe<Int[] | Int>;
  orderId_not_in?: Maybe<Int[] | Int>;
  orderId_lt?: Maybe<Int>;
  orderId_lte?: Maybe<Int>;
  orderId_gt?: Maybe<Int>;
  orderId_gte?: Maybe<Int>;
  cancelled?: Maybe<Boolean>;
  cancelled_not?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  cancelationJustification_not?: Maybe<String>;
  cancelationJustification_in?: Maybe<String[] | String>;
  cancelationJustification_not_in?: Maybe<String[] | String>;
  cancelationJustification_lt?: Maybe<String>;
  cancelationJustification_lte?: Maybe<String>;
  cancelationJustification_gt?: Maybe<String>;
  cancelationJustification_gte?: Maybe<String>;
  cancelationJustification_contains?: Maybe<String>;
  cancelationJustification_not_contains?: Maybe<String>;
  cancelationJustification_starts_with?: Maybe<String>;
  cancelationJustification_not_starts_with?: Maybe<String>;
  cancelationJustification_ends_with?: Maybe<String>;
  cancelationJustification_not_ends_with?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  wasModified_not?: Maybe<Boolean>;
  isEmployeeOrder?: Maybe<Boolean>;
  isEmployeeOrder_not?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  reuse_not?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  isToGo_not?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
  toGoReference_not?: Maybe<String>;
  toGoReference_in?: Maybe<String[] | String>;
  toGoReference_not_in?: Maybe<String[] | String>;
  toGoReference_lt?: Maybe<String>;
  toGoReference_lte?: Maybe<String>;
  toGoReference_gt?: Maybe<String>;
  toGoReference_gte?: Maybe<String>;
  toGoReference_contains?: Maybe<String>;
  toGoReference_not_contains?: Maybe<String>;
  toGoReference_starts_with?: Maybe<String>;
  toGoReference_not_starts_with?: Maybe<String>;
  toGoReference_ends_with?: Maybe<String>;
  toGoReference_not_ends_with?: Maybe<String>;
  AND?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  OR?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  NOT?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
}

export interface OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput;
  data: OrderUpdateManyDataInput;
}

export interface OrderUpdateManyDataInput {
  block?: Maybe<Int>;
  orderId?: Maybe<Int>;
  cancelled?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  isEmployeeOrder?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
}

export interface OrderUpsertWithWhereUniqueWithoutBillInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutBillDataInput;
  create: OrderCreateWithoutBillInput;
}

export interface BillUpsertWithWhereUniqueWithoutTableDataInput {
  where: BillWhereUniqueInput;
  update: BillUpdateWithoutTableDataDataInput;
  create: BillCreateWithoutTableDataInput;
}

export interface TableDataUpsertWithWhereUniqueWithoutWaiterInput {
  where: TableDataWhereUniqueInput;
  update: TableDataUpdateWithoutWaiterDataInput;
  create: TableDataCreateWithoutWaiterInput;
}

export interface EmployeeUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: EmployeeWhereUniqueInput;
  update: EmployeeUpdateWithoutEstablishmentDataInput;
  create: EmployeeCreateWithoutEstablishmentInput;
}

export interface EmployeeScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  employeeId?: Maybe<Int>;
  employeeId_not?: Maybe<Int>;
  employeeId_in?: Maybe<Int[] | Int>;
  employeeId_not_in?: Maybe<Int[] | Int>;
  employeeId_lt?: Maybe<Int>;
  employeeId_lte?: Maybe<Int>;
  employeeId_gt?: Maybe<Int>;
  employeeId_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  role?: Maybe<String>;
  role_not?: Maybe<String>;
  role_in?: Maybe<String[] | String>;
  role_not_in?: Maybe<String[] | String>;
  role_lt?: Maybe<String>;
  role_lte?: Maybe<String>;
  role_gt?: Maybe<String>;
  role_gte?: Maybe<String>;
  role_contains?: Maybe<String>;
  role_not_contains?: Maybe<String>;
  role_starts_with?: Maybe<String>;
  role_not_starts_with?: Maybe<String>;
  role_ends_with?: Maybe<String>;
  role_not_ends_with?: Maybe<String>;
  admissionDate?: Maybe<DateTimeInput>;
  admissionDate_not?: Maybe<DateTimeInput>;
  admissionDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  admissionDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  admissionDate_lt?: Maybe<DateTimeInput>;
  admissionDate_lte?: Maybe<DateTimeInput>;
  admissionDate_gt?: Maybe<DateTimeInput>;
  admissionDate_gte?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  terminationDate_not?: Maybe<DateTimeInput>;
  terminationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  terminationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  terminationDate_lt?: Maybe<DateTimeInput>;
  terminationDate_lte?: Maybe<DateTimeInput>;
  terminationDate_gt?: Maybe<DateTimeInput>;
  terminationDate_gte?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
  isActive_not?: Maybe<Boolean>;
  AND?: Maybe<EmployeeScalarWhereInput[] | EmployeeScalarWhereInput>;
  OR?: Maybe<EmployeeScalarWhereInput[] | EmployeeScalarWhereInput>;
  NOT?: Maybe<EmployeeScalarWhereInput[] | EmployeeScalarWhereInput>;
}

export interface EmployeeUpdateManyWithWhereNestedInput {
  where: EmployeeScalarWhereInput;
  data: EmployeeUpdateManyDataInput;
}

export interface EmployeeUpdateManyDataInput {
  employeeId?: Maybe<Int>;
  name?: Maybe<String>;
  role?: Maybe<String>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
}

export interface EstablishmentUpsertWithoutExpensesInput {
  update: EstablishmentUpdateWithoutExpensesDataInput;
  create: EstablishmentCreateWithoutExpensesInput;
}

export interface ExpenseUpsertWithoutPaymentInput {
  update: ExpenseUpdateWithoutPaymentDataInput;
  create: ExpenseCreateWithoutPaymentInput;
}

export interface PaymentUpsertWithWhereUniqueWithoutBillInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutBillDataInput;
  create: PaymentCreateWithoutBillInput;
}

export interface PaymentScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  value?: Maybe<Float>;
  value_not?: Maybe<Float>;
  value_in?: Maybe<Float[] | Float>;
  value_not_in?: Maybe<Float[] | Float>;
  value_lt?: Maybe<Float>;
  value_lte?: Maybe<Float>;
  value_gt?: Maybe<Float>;
  value_gte?: Maybe<Float>;
  paymentType?: Maybe<String>;
  paymentType_not?: Maybe<String>;
  paymentType_in?: Maybe<String[] | String>;
  paymentType_not_in?: Maybe<String[] | String>;
  paymentType_lt?: Maybe<String>;
  paymentType_lte?: Maybe<String>;
  paymentType_gt?: Maybe<String>;
  paymentType_gte?: Maybe<String>;
  paymentType_contains?: Maybe<String>;
  paymentType_not_contains?: Maybe<String>;
  paymentType_starts_with?: Maybe<String>;
  paymentType_not_starts_with?: Maybe<String>;
  paymentType_ends_with?: Maybe<String>;
  paymentType_not_ends_with?: Maybe<String>;
  paymentTypeOption?: Maybe<String>;
  paymentTypeOption_not?: Maybe<String>;
  paymentTypeOption_in?: Maybe<String[] | String>;
  paymentTypeOption_not_in?: Maybe<String[] | String>;
  paymentTypeOption_lt?: Maybe<String>;
  paymentTypeOption_lte?: Maybe<String>;
  paymentTypeOption_gt?: Maybe<String>;
  paymentTypeOption_gte?: Maybe<String>;
  paymentTypeOption_contains?: Maybe<String>;
  paymentTypeOption_not_contains?: Maybe<String>;
  paymentTypeOption_starts_with?: Maybe<String>;
  paymentTypeOption_not_starts_with?: Maybe<String>;
  paymentTypeOption_ends_with?: Maybe<String>;
  paymentTypeOption_not_ends_with?: Maybe<String>;
  isActive?: Maybe<Boolean>;
  isActive_not?: Maybe<Boolean>;
  AND?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  OR?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  NOT?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
}

export interface PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput;
  data: PaymentUpdateManyDataInput;
}

export interface PaymentUpdateManyDataInput {
  value?: Maybe<Float>;
  paymentType?: Maybe<String>;
  paymentTypeOption?: Maybe<String>;
  isActive?: Maybe<Boolean>;
}

export interface BillUpsertWithoutOrdersInput {
  update: BillUpdateWithoutOrdersDataInput;
  create: BillCreateWithoutOrdersInput;
}

export interface OrderUpsertWithWhereUniqueWithoutWorkDayInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutWorkDayDataInput;
  create: OrderCreateWithoutWorkDayInput;
}

export interface OrderPadUpdateManyWithoutWorkDayInput {
  create?: Maybe<
    OrderPadCreateWithoutWorkDayInput[] | OrderPadCreateWithoutWorkDayInput
  >;
  delete?: Maybe<OrderPadWhereUniqueInput[] | OrderPadWhereUniqueInput>;
  connect?: Maybe<OrderPadWhereUniqueInput[] | OrderPadWhereUniqueInput>;
  set?: Maybe<OrderPadWhereUniqueInput[] | OrderPadWhereUniqueInput>;
  disconnect?: Maybe<OrderPadWhereUniqueInput[] | OrderPadWhereUniqueInput>;
  update?: Maybe<
    | OrderPadUpdateWithWhereUniqueWithoutWorkDayInput[]
    | OrderPadUpdateWithWhereUniqueWithoutWorkDayInput
  >;
  upsert?: Maybe<
    | OrderPadUpsertWithWhereUniqueWithoutWorkDayInput[]
    | OrderPadUpsertWithWhereUniqueWithoutWorkDayInput
  >;
  deleteMany?: Maybe<OrderPadScalarWhereInput[] | OrderPadScalarWhereInput>;
  updateMany?: Maybe<
    | OrderPadUpdateManyWithWhereNestedInput[]
    | OrderPadUpdateManyWithWhereNestedInput
  >;
}

export interface OrderPadUpdateWithWhereUniqueWithoutWorkDayInput {
  where: OrderPadWhereUniqueInput;
  data: OrderPadUpdateWithoutWorkDayDataInput;
}

export interface OrderPadUpdateWithoutWorkDayDataInput {
  block?: Maybe<Int>;
  firstOrderId?: Maybe<Int>;
  lastOrderId?: Maybe<Int>;
  employee?: Maybe<EmployeeUpdateOneWithoutOrderPadsInput>;
  used?: Maybe<Boolean>;
}

export interface EmployeeUpdateOneWithoutOrderPadsInput {
  create?: Maybe<EmployeeCreateWithoutOrderPadsInput>;
  update?: Maybe<EmployeeUpdateWithoutOrderPadsDataInput>;
  upsert?: Maybe<EmployeeUpsertWithoutOrderPadsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeUpdateWithoutOrderPadsDataInput {
  establishment?: Maybe<EstablishmentUpdateOneRequiredWithoutEmployeesInput>;
  employeeId?: Maybe<Int>;
  name?: Maybe<String>;
  role?: Maybe<String>;
  tables?: Maybe<TableDataUpdateManyWithoutWaiterInput>;
  itemsOrdered?: Maybe<OrderItemUpdateManyWithoutEmployeeInput>;
  workHours?: Maybe<WorkHourUpdateManyWithoutEmployeeInput>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
}

export interface EmployeeUpsertWithoutOrderPadsInput {
  update: EmployeeUpdateWithoutOrderPadsDataInput;
  create: EmployeeCreateWithoutOrderPadsInput;
}

export interface OrderPadUpsertWithWhereUniqueWithoutWorkDayInput {
  where: OrderPadWhereUniqueInput;
  update: OrderPadUpdateWithoutWorkDayDataInput;
  create: OrderPadCreateWithoutWorkDayInput;
}

export interface WorkDayUpsertWithoutTablesInput {
  update: WorkDayUpdateWithoutTablesDataInput;
  create: WorkDayCreateWithoutTablesInput;
}

export interface TableDataUpsertWithoutBillsInput {
  update: TableDataUpdateWithoutBillsDataInput;
  create: TableDataCreateWithoutBillsInput;
}

export interface BillUpsertWithWhereUniqueWithoutWorkDayInput {
  where: BillWhereUniqueInput;
  update: BillUpdateWithoutWorkDayDataInput;
  create: BillCreateWithoutWorkDayInput;
}

export interface WorkDayUpsertWithoutOrdersInput {
  update: WorkDayUpdateWithoutOrdersDataInput;
  create: WorkDayCreateWithoutOrdersInput;
}

export interface OrderUpsertWithoutOrderItemsInput {
  update: OrderUpdateWithoutOrderItemsDataInput;
  create: OrderCreateWithoutOrderItemsInput;
}

export interface OrderItemUpsertWithWhereUniqueWithoutItemInput {
  where: OrderItemWhereUniqueInput;
  update: OrderItemUpdateWithoutItemDataInput;
  create: OrderItemCreateWithoutItemInput;
}

export interface ItemUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutEstablishmentDataInput;
  create: ItemCreateWithoutEstablishmentInput;
}

export interface ItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  itemId?: Maybe<String>;
  itemId_not?: Maybe<String>;
  itemId_in?: Maybe<String[] | String>;
  itemId_not_in?: Maybe<String[] | String>;
  itemId_lt?: Maybe<String>;
  itemId_lte?: Maybe<String>;
  itemId_gt?: Maybe<String>;
  itemId_gte?: Maybe<String>;
  itemId_contains?: Maybe<String>;
  itemId_not_contains?: Maybe<String>;
  itemId_starts_with?: Maybe<String>;
  itemId_not_starts_with?: Maybe<String>;
  itemId_ends_with?: Maybe<String>;
  itemId_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  priceToGo?: Maybe<Float>;
  priceToGo_not?: Maybe<Float>;
  priceToGo_in?: Maybe<Float[] | Float>;
  priceToGo_not_in?: Maybe<Float[] | Float>;
  priceToGo_lt?: Maybe<Float>;
  priceToGo_lte?: Maybe<Float>;
  priceToGo_gt?: Maybe<Float>;
  priceToGo_gte?: Maybe<Float>;
  employeePrice?: Maybe<Float>;
  employeePrice_not?: Maybe<Float>;
  employeePrice_in?: Maybe<Float[] | Float>;
  employeePrice_not_in?: Maybe<Float[] | Float>;
  employeePrice_lt?: Maybe<Float>;
  employeePrice_lte?: Maybe<Float>;
  employeePrice_gt?: Maybe<Float>;
  employeePrice_gte?: Maybe<Float>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  canTakeToGo?: Maybe<Boolean>;
  canTakeToGo_not?: Maybe<Boolean>;
  isActive?: Maybe<Boolean>;
  isActive_not?: Maybe<Boolean>;
  hasTaxSubstitution?: Maybe<Boolean>;
  hasTaxSubstitution_not?: Maybe<Boolean>;
  AND?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  OR?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  NOT?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
}

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export interface ItemUpdateManyDataInput {
  itemId?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  priceToGo?: Maybe<Float>;
  employeePrice?: Maybe<Float>;
  category?: Maybe<String>;
  canTakeToGo?: Maybe<Boolean>;
  isActive?: Maybe<Boolean>;
  hasTaxSubstitution?: Maybe<Boolean>;
}

export interface EstablishmentUpsertWithoutPermissionsInput {
  update: EstablishmentUpdateWithoutPermissionsDataInput;
  create: EstablishmentCreateWithoutPermissionsInput;
}

export interface PermissionUpsertWithWhereUniqueWithoutUserInput {
  where: PermissionWhereUniqueInput;
  update: PermissionUpdateWithoutUserDataInput;
  create: PermissionCreateWithoutUserInput;
}

export interface PermissionScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  role?: Maybe<UserRole>;
  role_not?: Maybe<UserRole>;
  role_in?: Maybe<UserRole[] | UserRole>;
  role_not_in?: Maybe<UserRole[] | UserRole>;
  AND?: Maybe<PermissionScalarWhereInput[] | PermissionScalarWhereInput>;
  OR?: Maybe<PermissionScalarWhereInput[] | PermissionScalarWhereInput>;
  NOT?: Maybe<PermissionScalarWhereInput[] | PermissionScalarWhereInput>;
}

export interface PermissionUpdateManyWithWhereNestedInput {
  where: PermissionScalarWhereInput;
  data: PermissionUpdateManyDataInput;
}

export interface PermissionUpdateManyDataInput {
  role?: Maybe<UserRole>;
}

export interface UserUpsertWithoutResponsibleWorkDaysInput {
  update: UserUpdateWithoutResponsibleWorkDaysDataInput;
  create: UserCreateWithoutResponsibleWorkDaysInput;
}

export interface WorkDayUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: WorkDayWhereUniqueInput;
  update: WorkDayUpdateWithoutEstablishmentDataInput;
  create: WorkDayCreateWithoutEstablishmentInput;
}

export interface WorkDayScalarWhereInput {
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  isCurrent?: Maybe<Boolean>;
  isCurrent_not?: Maybe<Boolean>;
  openDate?: Maybe<DateTimeInput>;
  openDate_not?: Maybe<DateTimeInput>;
  openDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  openDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  openDate_lt?: Maybe<DateTimeInput>;
  openDate_lte?: Maybe<DateTimeInput>;
  openDate_gt?: Maybe<DateTimeInput>;
  openDate_gte?: Maybe<DateTimeInput>;
  closeDate?: Maybe<DateTimeInput>;
  closeDate_not?: Maybe<DateTimeInput>;
  closeDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closeDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closeDate_lt?: Maybe<DateTimeInput>;
  closeDate_lte?: Maybe<DateTimeInput>;
  closeDate_gt?: Maybe<DateTimeInput>;
  closeDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<WorkDayScalarWhereInput[] | WorkDayScalarWhereInput>;
  OR?: Maybe<WorkDayScalarWhereInput[] | WorkDayScalarWhereInput>;
  NOT?: Maybe<WorkDayScalarWhereInput[] | WorkDayScalarWhereInput>;
}

export interface WorkDayUpdateManyWithWhereNestedInput {
  where: WorkDayScalarWhereInput;
  data: WorkDayUpdateManyDataInput;
}

export interface WorkDayUpdateManyDataInput {
  isCurrent?: Maybe<Boolean>;
  openDate?: Maybe<DateTimeInput>;
  closeDate?: Maybe<DateTimeInput>;
}

export interface EstablishmentUpsertWithoutTablesInput {
  update: EstablishmentUpdateWithoutTablesDataInput;
  create: EstablishmentCreateWithoutTablesInput;
}

export interface TableUpsertWithoutDataInput {
  update: TableUpdateWithoutDataDataInput;
  create: TableCreateWithoutDataInput;
}

export interface TableDataUpsertWithWhereUniqueWithoutWorkDayInput {
  where: TableDataWhereUniqueInput;
  update: TableDataUpdateWithoutWorkDayDataInput;
  create: TableDataCreateWithoutWorkDayInput;
}

export interface WorkDayUpsertWithWhereUniqueWithoutUserResponsibleInput {
  where: WorkDayWhereUniqueInput;
  update: WorkDayUpdateWithoutUserResponsibleDataInput;
  create: WorkDayCreateWithoutUserResponsibleInput;
}

export interface UserUpsertWithoutPermissionsInput {
  update: UserUpdateWithoutPermissionsDataInput;
  create: UserCreateWithoutPermissionsInput;
}

export interface PermissionUpsertWithWhereUniqueWithoutEstablishmentInput {
  where: PermissionWhereUniqueInput;
  update: PermissionUpdateWithoutEstablishmentDataInput;
  create: PermissionCreateWithoutEstablishmentInput;
}

export interface EstablishmentUpsertWithoutWorkingDaysInput {
  update: EstablishmentUpdateWithoutWorkingDaysDataInput;
  create: EstablishmentCreateWithoutWorkingDaysInput;
}

export interface WorkDayUpsertWithoutBillsInput {
  update: WorkDayUpdateWithoutBillsDataInput;
  create: WorkDayCreateWithoutBillsInput;
}

export interface BillUpdateManyMutationInput {
  closedAt?: Maybe<DateTimeInput>;
  status?: Maybe<BillStatus>;
  discount?: Maybe<Float>;
  discountReason?: Maybe<String>;
  value?: Maybe<Float>;
  wasReopen?: Maybe<Boolean>;
  registered?: Maybe<Boolean>;
}

export interface CheckDataCreateInput {
  id?: Maybe<ID_Input>;
  payment: PaymentCreateOneWithoutCheckDataInput;
  checkbookId?: Maybe<String>;
  compensationNumber?: Maybe<Int>;
  bankNumber?: Maybe<Int>;
}

export interface PaymentCreateOneWithoutCheckDataInput {
  create?: Maybe<PaymentCreateWithoutCheckDataInput>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentCreateWithoutCheckDataInput {
  id?: Maybe<ID_Input>;
  value: Float;
  paymentType: String;
  paymentTypeOption?: Maybe<String>;
  bill?: Maybe<BillCreateOneWithoutPaymentsInput>;
  expense?: Maybe<ExpenseCreateOneWithoutPaymentInput>;
  isActive: Boolean;
}

export interface CheckDataUpdateInput {
  payment?: Maybe<PaymentUpdateOneRequiredWithoutCheckDataInput>;
  checkbookId?: Maybe<String>;
  compensationNumber?: Maybe<Int>;
  bankNumber?: Maybe<Int>;
}

export interface PaymentUpdateOneRequiredWithoutCheckDataInput {
  create?: Maybe<PaymentCreateWithoutCheckDataInput>;
  update?: Maybe<PaymentUpdateWithoutCheckDataDataInput>;
  upsert?: Maybe<PaymentUpsertWithoutCheckDataInput>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentUpdateWithoutCheckDataDataInput {
  value?: Maybe<Float>;
  paymentType?: Maybe<String>;
  paymentTypeOption?: Maybe<String>;
  bill?: Maybe<BillUpdateOneWithoutPaymentsInput>;
  expense?: Maybe<ExpenseUpdateOneWithoutPaymentInput>;
  isActive?: Maybe<Boolean>;
}

export interface PaymentUpsertWithoutCheckDataInput {
  update: PaymentUpdateWithoutCheckDataDataInput;
  create: PaymentCreateWithoutCheckDataInput;
}

export interface CheckDataUpdateManyMutationInput {
  checkbookId?: Maybe<String>;
  compensationNumber?: Maybe<Int>;
  bankNumber?: Maybe<Int>;
}

export interface ClientCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  address: String;
  complement?: Maybe<String>;
  postCode: String;
  telephoneNumber: String;
  establishment: EstablishmentCreateOneWithoutClientsInput;
  distanceKm: String;
  distanceTime: String;
}

export interface EstablishmentCreateOneWithoutClientsInput {
  create?: Maybe<EstablishmentCreateWithoutClientsInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentCreateWithoutClientsInput {
  id?: Maybe<ID_Input>;
  name: String;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId: String;
  valueInCashRegister: Float;
  maximumInCashRegister: Float;
  incomeMaxReference: Int;
  isOpen: Boolean;
  workingDays?: Maybe<WorkDayCreateManyWithoutEstablishmentInput>;
  permissions?: Maybe<PermissionCreateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemCreateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeCreateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableCreateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseCreateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentCreatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
}

export interface ClientUpdateInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  complement?: Maybe<String>;
  postCode?: Maybe<String>;
  telephoneNumber?: Maybe<String>;
  establishment?: Maybe<EstablishmentUpdateOneRequiredWithoutClientsInput>;
  distanceKm?: Maybe<String>;
  distanceTime?: Maybe<String>;
}

export interface EstablishmentUpdateOneRequiredWithoutClientsInput {
  create?: Maybe<EstablishmentCreateWithoutClientsInput>;
  update?: Maybe<EstablishmentUpdateWithoutClientsDataInput>;
  upsert?: Maybe<EstablishmentUpsertWithoutClientsInput>;
  connect?: Maybe<EstablishmentWhereUniqueInput>;
}

export interface EstablishmentUpdateWithoutClientsDataInput {
  name?: Maybe<String>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId?: Maybe<String>;
  valueInCashRegister?: Maybe<Float>;
  maximumInCashRegister?: Maybe<Float>;
  incomeMaxReference?: Maybe<Int>;
  isOpen?: Maybe<Boolean>;
  workingDays?: Maybe<WorkDayUpdateManyWithoutEstablishmentInput>;
  permissions?: Maybe<PermissionUpdateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemUpdateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeUpdateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableUpdateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseUpdateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentUpdatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
}

export interface EstablishmentUpsertWithoutClientsInput {
  update: EstablishmentUpdateWithoutClientsDataInput;
  create: EstablishmentCreateWithoutClientsInput;
}

export interface ClientUpdateManyMutationInput {
  name?: Maybe<String>;
  address?: Maybe<String>;
  complement?: Maybe<String>;
  postCode?: Maybe<String>;
  telephoneNumber?: Maybe<String>;
  distanceKm?: Maybe<String>;
  distanceTime?: Maybe<String>;
}

export interface EmployeeCreateInput {
  id?: Maybe<ID_Input>;
  establishment: EstablishmentCreateOneWithoutEmployeesInput;
  employeeId: Int;
  name: String;
  role: String;
  tables?: Maybe<TableDataCreateManyWithoutWaiterInput>;
  orderPads?: Maybe<OrderPadCreateManyWithoutEmployeeInput>;
  itemsOrdered?: Maybe<OrderItemCreateManyWithoutEmployeeInput>;
  workHours?: Maybe<WorkHourCreateManyWithoutEmployeeInput>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive: Boolean;
}

export interface EmployeeUpdateInput {
  establishment?: Maybe<EstablishmentUpdateOneRequiredWithoutEmployeesInput>;
  employeeId?: Maybe<Int>;
  name?: Maybe<String>;
  role?: Maybe<String>;
  tables?: Maybe<TableDataUpdateManyWithoutWaiterInput>;
  orderPads?: Maybe<OrderPadUpdateManyWithoutEmployeeInput>;
  itemsOrdered?: Maybe<OrderItemUpdateManyWithoutEmployeeInput>;
  workHours?: Maybe<WorkHourUpdateManyWithoutEmployeeInput>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
}

export interface EmployeeUpdateManyMutationInput {
  employeeId?: Maybe<Int>;
  name?: Maybe<String>;
  role?: Maybe<String>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
}

export interface EstablishmentCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId: String;
  valueInCashRegister: Float;
  maximumInCashRegister: Float;
  incomeMaxReference: Int;
  isOpen: Boolean;
  workingDays?: Maybe<WorkDayCreateManyWithoutEstablishmentInput>;
  permissions?: Maybe<PermissionCreateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemCreateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeCreateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableCreateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseCreateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentCreatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientCreateManyWithoutEstablishmentInput>;
}

export interface EstablishmentUpdateInput {
  name?: Maybe<String>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId?: Maybe<String>;
  valueInCashRegister?: Maybe<Float>;
  maximumInCashRegister?: Maybe<Float>;
  incomeMaxReference?: Maybe<Int>;
  isOpen?: Maybe<Boolean>;
  workingDays?: Maybe<WorkDayUpdateManyWithoutEstablishmentInput>;
  permissions?: Maybe<PermissionUpdateManyWithoutEstablishmentInput>;
  items?: Maybe<ItemUpdateManyWithoutEstablishmentInput>;
  employees?: Maybe<EmployeeUpdateManyWithoutEstablishmentInput>;
  tables?: Maybe<TableUpdateManyWithoutEstablishmentInput>;
  expenses?: Maybe<ExpenseUpdateManyWithoutEstablishmentInput>;
  discountReasons?: Maybe<EstablishmentUpdatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
  clients?: Maybe<ClientUpdateManyWithoutEstablishmentInput>;
}

export interface EstablishmentUpdateManyMutationInput {
  name?: Maybe<String>;
  lat?: Maybe<Float>;
  long?: Maybe<Float>;
  restaurantId?: Maybe<String>;
  valueInCashRegister?: Maybe<Float>;
  maximumInCashRegister?: Maybe<Float>;
  incomeMaxReference?: Maybe<Int>;
  isOpen?: Maybe<Boolean>;
  discountReasons?: Maybe<EstablishmentUpdatediscountReasonsInput>;
  totalInvoices?: Maybe<Int>;
}

export interface ExpenseCreateInput {
  id?: Maybe<ID_Input>;
  establishment?: Maybe<EstablishmentCreateOneWithoutExpensesInput>;
  NFE: Boolean;
  NFEReference?: Maybe<String>;
  expenseItems?: Maybe<ExpenseItemCreateManyInput>;
  date: DateTimeInput;
  executionDate: DateTimeInput;
  payment?: Maybe<PaymentCreateOneWithoutExpenseInput>;
}

export interface ExpenseUpdateInput {
  establishment?: Maybe<EstablishmentUpdateOneWithoutExpensesInput>;
  NFE?: Maybe<Boolean>;
  NFEReference?: Maybe<String>;
  expenseItems?: Maybe<ExpenseItemUpdateManyInput>;
  date?: Maybe<DateTimeInput>;
  executionDate?: Maybe<DateTimeInput>;
  payment?: Maybe<PaymentUpdateOneWithoutExpenseInput>;
}

export interface ExpenseUpdateManyMutationInput {
  NFE?: Maybe<Boolean>;
  NFEReference?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  executionDate?: Maybe<DateTimeInput>;
}

export interface ExpenseItemUpdateInput {
  quantity?: Maybe<Float>;
  product?: Maybe<ProductUpdateOneRequiredInput>;
  value?: Maybe<Float>;
  details?: Maybe<String>;
}

export interface ExpenseItemUpdateManyMutationInput {
  quantity?: Maybe<Float>;
  value?: Maybe<Float>;
  details?: Maybe<String>;
}

export interface IncomeCreateInput {
  id?: Maybe<ID_Input>;
  workDay?: Maybe<WorkDayCreateOneWithoutIncomesInput>;
  reference: String;
  value: Float;
  type?: Maybe<String>;
}

export interface WorkDayCreateOneWithoutIncomesInput {
  create?: Maybe<WorkDayCreateWithoutIncomesInput>;
  connect?: Maybe<WorkDayWhereUniqueInput>;
}

export interface WorkDayCreateWithoutIncomesInput {
  id?: Maybe<ID_Input>;
  establishment?: Maybe<EstablishmentCreateOneWithoutWorkingDaysInput>;
  isCurrent: Boolean;
  openDate: DateTimeInput;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserCreateOneWithoutResponsibleWorkDaysInput>;
  tables?: Maybe<TableDataCreateManyWithoutWorkDayInput>;
  bills?: Maybe<BillCreateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderCreateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadCreateManyWithoutWorkDayInput>;
}

export interface IncomeUpdateInput {
  workDay?: Maybe<WorkDayUpdateOneWithoutIncomesInput>;
  reference?: Maybe<String>;
  value?: Maybe<Float>;
  type?: Maybe<String>;
}

export interface WorkDayUpdateOneWithoutIncomesInput {
  create?: Maybe<WorkDayCreateWithoutIncomesInput>;
  update?: Maybe<WorkDayUpdateWithoutIncomesDataInput>;
  upsert?: Maybe<WorkDayUpsertWithoutIncomesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<WorkDayWhereUniqueInput>;
}

export interface WorkDayUpdateWithoutIncomesDataInput {
  establishment?: Maybe<EstablishmentUpdateOneWithoutWorkingDaysInput>;
  isCurrent?: Maybe<Boolean>;
  openDate?: Maybe<DateTimeInput>;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserUpdateOneWithoutResponsibleWorkDaysInput>;
  tables?: Maybe<TableDataUpdateManyWithoutWorkDayInput>;
  bills?: Maybe<BillUpdateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderUpdateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadUpdateManyWithoutWorkDayInput>;
}

export interface WorkDayUpsertWithoutIncomesInput {
  update: WorkDayUpdateWithoutIncomesDataInput;
  create: WorkDayCreateWithoutIncomesInput;
}

export interface IncomeUpdateManyMutationInput {
  reference?: Maybe<String>;
  value?: Maybe<Float>;
  type?: Maybe<String>;
}

export interface ItemCreateInput {
  id?: Maybe<ID_Input>;
  itemId: String;
  name: String;
  price: Float;
  priceToGo?: Maybe<Float>;
  employeePrice?: Maybe<Float>;
  category: String;
  orderItem?: Maybe<OrderItemCreateManyWithoutItemInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutItemsInput>;
  canTakeToGo?: Maybe<Boolean>;
  isActive: Boolean;
  itemNCM?: Maybe<NCMCreateOneWithoutItemsInput>;
  hasTaxSubstitution?: Maybe<Boolean>;
}

export interface ItemUpdateInput {
  itemId?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  priceToGo?: Maybe<Float>;
  employeePrice?: Maybe<Float>;
  category?: Maybe<String>;
  orderItem?: Maybe<OrderItemUpdateManyWithoutItemInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutItemsInput>;
  canTakeToGo?: Maybe<Boolean>;
  isActive?: Maybe<Boolean>;
  itemNCM?: Maybe<NCMUpdateOneWithoutItemsInput>;
  hasTaxSubstitution?: Maybe<Boolean>;
}

export interface ItemUpdateManyMutationInput {
  itemId?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  priceToGo?: Maybe<Float>;
  employeePrice?: Maybe<Float>;
  category?: Maybe<String>;
  canTakeToGo?: Maybe<Boolean>;
  isActive?: Maybe<Boolean>;
  hasTaxSubstitution?: Maybe<Boolean>;
}

export interface NCMCreateInput {
  id?: Maybe<ID_Input>;
  identifier: String;
  description?: Maybe<String>;
  items?: Maybe<ItemCreateManyWithoutItemNCMInput>;
}

export interface ItemCreateManyWithoutItemNCMInput {
  create?: Maybe<
    ItemCreateWithoutItemNCMInput[] | ItemCreateWithoutItemNCMInput
  >;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface ItemCreateWithoutItemNCMInput {
  id?: Maybe<ID_Input>;
  itemId: String;
  name: String;
  price: Float;
  priceToGo?: Maybe<Float>;
  employeePrice?: Maybe<Float>;
  category: String;
  orderItem?: Maybe<OrderItemCreateManyWithoutItemInput>;
  establishment?: Maybe<EstablishmentCreateOneWithoutItemsInput>;
  canTakeToGo?: Maybe<Boolean>;
  isActive: Boolean;
  hasTaxSubstitution?: Maybe<Boolean>;
}

export interface NCMUpdateInput {
  identifier?: Maybe<String>;
  description?: Maybe<String>;
  items?: Maybe<ItemUpdateManyWithoutItemNCMInput>;
}

export interface ItemUpdateManyWithoutItemNCMInput {
  create?: Maybe<
    ItemCreateWithoutItemNCMInput[] | ItemCreateWithoutItemNCMInput
  >;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueWithoutItemNCMInput[]
    | ItemUpdateWithWhereUniqueWithoutItemNCMInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueWithoutItemNCMInput[]
    | ItemUpsertWithWhereUniqueWithoutItemNCMInput
  >;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface ItemUpdateWithWhereUniqueWithoutItemNCMInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutItemNCMDataInput;
}

export interface ItemUpdateWithoutItemNCMDataInput {
  itemId?: Maybe<String>;
  name?: Maybe<String>;
  price?: Maybe<Float>;
  priceToGo?: Maybe<Float>;
  employeePrice?: Maybe<Float>;
  category?: Maybe<String>;
  orderItem?: Maybe<OrderItemUpdateManyWithoutItemInput>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutItemsInput>;
  canTakeToGo?: Maybe<Boolean>;
  isActive?: Maybe<Boolean>;
  hasTaxSubstitution?: Maybe<Boolean>;
}

export interface ItemUpsertWithWhereUniqueWithoutItemNCMInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutItemNCMDataInput;
  create: ItemCreateWithoutItemNCMInput;
}

export interface NCMUpdateManyMutationInput {
  identifier?: Maybe<String>;
  description?: Maybe<String>;
}

export interface OrderUpdateInput {
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutOrdersInput>;
  block?: Maybe<Int>;
  orderId?: Maybe<Int>;
  bill?: Maybe<BillUpdateOneWithoutOrdersInput>;
  orderItems?: Maybe<OrderItemUpdateManyWithoutOrderInput>;
  cancelled?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  modifiedOrders?: Maybe<OrderUpdateManyInput>;
  isEmployeeOrder?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
}

export interface OrderUpdateManyMutationInput {
  block?: Maybe<Int>;
  orderId?: Maybe<Int>;
  cancelled?: Maybe<Boolean>;
  cancelationJustification?: Maybe<String>;
  wasModified?: Maybe<Boolean>;
  isEmployeeOrder?: Maybe<Boolean>;
  reuse?: Maybe<Boolean>;
  isToGo?: Maybe<Boolean>;
  toGoReference?: Maybe<String>;
}

export interface OrderItemCreateInput {
  id?: Maybe<ID_Input>;
  quantity: Int;
  item: ItemCreateOneWithoutOrderItemInput;
  order?: Maybe<OrderCreateOneWithoutOrderItemsInput>;
  employee?: Maybe<EmployeeCreateOneWithoutItemsOrderedInput>;
}

export interface OrderItemUpdateInput {
  quantity?: Maybe<Int>;
  item?: Maybe<ItemUpdateOneRequiredWithoutOrderItemInput>;
  order?: Maybe<OrderUpdateOneWithoutOrderItemsInput>;
  employee?: Maybe<EmployeeUpdateOneWithoutItemsOrderedInput>;
}

export interface OrderItemUpdateManyMutationInput {
  quantity?: Maybe<Int>;
}

export interface OrderPadCreateInput {
  id?: Maybe<ID_Input>;
  workDay?: Maybe<WorkDayCreateOneWithoutOrderPadsInput>;
  block: Int;
  firstOrderId: Int;
  lastOrderId?: Maybe<Int>;
  employee?: Maybe<EmployeeCreateOneWithoutOrderPadsInput>;
  used: Boolean;
}

export interface OrderPadUpdateInput {
  workDay?: Maybe<WorkDayUpdateOneWithoutOrderPadsInput>;
  block?: Maybe<Int>;
  firstOrderId?: Maybe<Int>;
  lastOrderId?: Maybe<Int>;
  employee?: Maybe<EmployeeUpdateOneWithoutOrderPadsInput>;
  used?: Maybe<Boolean>;
}

export interface OrderPadUpdateManyMutationInput {
  block?: Maybe<Int>;
  firstOrderId?: Maybe<Int>;
  lastOrderId?: Maybe<Int>;
  used?: Maybe<Boolean>;
}

export interface PaymentCreateInput {
  id?: Maybe<ID_Input>;
  value: Float;
  paymentType: String;
  paymentTypeOption?: Maybe<String>;
  checkData?: Maybe<CheckDataCreateOneWithoutPaymentInput>;
  bill?: Maybe<BillCreateOneWithoutPaymentsInput>;
  expense?: Maybe<ExpenseCreateOneWithoutPaymentInput>;
  isActive: Boolean;
}

export interface PaymentUpdateInput {
  value?: Maybe<Float>;
  paymentType?: Maybe<String>;
  paymentTypeOption?: Maybe<String>;
  checkData?: Maybe<CheckDataUpdateOneWithoutPaymentInput>;
  bill?: Maybe<BillUpdateOneWithoutPaymentsInput>;
  expense?: Maybe<ExpenseUpdateOneWithoutPaymentInput>;
  isActive?: Maybe<Boolean>;
}

export interface PaymentUpdateManyMutationInput {
  value?: Maybe<Float>;
  paymentType?: Maybe<String>;
  paymentTypeOption?: Maybe<String>;
  isActive?: Maybe<Boolean>;
}

export interface PermissionCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutPermissionsInput;
  establishment: EstablishmentCreateOneWithoutPermissionsInput;
  role: UserRole;
}

export interface PermissionUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutPermissionsInput>;
  establishment?: Maybe<EstablishmentUpdateOneRequiredWithoutPermissionsInput>;
  role?: Maybe<UserRole>;
}

export interface PermissionUpdateManyMutationInput {
  role?: Maybe<UserRole>;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
  category?: Maybe<String>;
  supplier?: Maybe<String>;
  brand?: Maybe<String>;
  unit?: Maybe<String>;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
  category?: Maybe<String>;
  supplier?: Maybe<String>;
  brand?: Maybe<String>;
  unit?: Maybe<String>;
}

export interface TableCreateInput {
  id?: Maybe<ID_Input>;
  tableNumber: Int;
  establishment?: Maybe<EstablishmentCreateOneWithoutTablesInput>;
  data?: Maybe<TableDataCreateManyWithoutTableInput>;
}

export interface TableUpdateInput {
  tableNumber?: Maybe<Int>;
  establishment?: Maybe<EstablishmentUpdateOneWithoutTablesInput>;
  data?: Maybe<TableDataUpdateManyWithoutTableInput>;
}

export interface TableUpdateManyMutationInput {
  tableNumber?: Maybe<Int>;
}

export interface TableDataCreateInput {
  id?: Maybe<ID_Input>;
  totalOccupations: Int;
  table: TableCreateOneWithoutDataInput;
  workDay: WorkDayCreateOneWithoutTablesInput;
  waiter?: Maybe<EmployeeCreateOneWithoutTablesInput>;
  bills?: Maybe<BillCreateManyWithoutTableDataInput>;
}

export interface TableDataUpdateInput {
  totalOccupations?: Maybe<Int>;
  table?: Maybe<TableUpdateOneRequiredWithoutDataInput>;
  workDay?: Maybe<WorkDayUpdateOneRequiredWithoutTablesInput>;
  waiter?: Maybe<EmployeeUpdateOneWithoutTablesInput>;
  bills?: Maybe<BillUpdateManyWithoutTableDataInput>;
}

export interface TableDataUpdateManyMutationInput {
  totalOccupations?: Maybe<Int>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  permissions?: Maybe<PermissionCreateManyWithoutUserInput>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  responsibleWorkDays?: Maybe<WorkDayCreateManyWithoutUserResponsibleInput>;
}

export interface UserUpdateInput {
  permissions?: Maybe<PermissionUpdateManyWithoutUserInput>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  responsibleWorkDays?: Maybe<WorkDayUpdateManyWithoutUserResponsibleInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface WorkDayCreateInput {
  id?: Maybe<ID_Input>;
  establishment?: Maybe<EstablishmentCreateOneWithoutWorkingDaysInput>;
  isCurrent: Boolean;
  openDate: DateTimeInput;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserCreateOneWithoutResponsibleWorkDaysInput>;
  tables?: Maybe<TableDataCreateManyWithoutWorkDayInput>;
  incomes?: Maybe<IncomeCreateManyWithoutWorkDayInput>;
  bills?: Maybe<BillCreateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderCreateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadCreateManyWithoutWorkDayInput>;
}

export interface WorkDayUpdateInput {
  establishment?: Maybe<EstablishmentUpdateOneWithoutWorkingDaysInput>;
  isCurrent?: Maybe<Boolean>;
  openDate?: Maybe<DateTimeInput>;
  closeDate?: Maybe<DateTimeInput>;
  userResponsible?: Maybe<UserUpdateOneWithoutResponsibleWorkDaysInput>;
  tables?: Maybe<TableDataUpdateManyWithoutWorkDayInput>;
  incomes?: Maybe<IncomeUpdateManyWithoutWorkDayInput>;
  bills?: Maybe<BillUpdateManyWithoutWorkDayInput>;
  orders?: Maybe<OrderUpdateManyWithoutWorkDayInput>;
  orderPads?: Maybe<OrderPadUpdateManyWithoutWorkDayInput>;
}

export interface WorkDayUpdateManyMutationInput {
  isCurrent?: Maybe<Boolean>;
  openDate?: Maybe<DateTimeInput>;
  closeDate?: Maybe<DateTimeInput>;
}

export interface WorkHourCreateInput {
  id?: Maybe<ID_Input>;
  weekday: WeekDay;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  isDayOff?: Maybe<Boolean>;
  employee: EmployeeCreateOneWithoutWorkHoursInput;
}

export interface EmployeeCreateOneWithoutWorkHoursInput {
  create?: Maybe<EmployeeCreateWithoutWorkHoursInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeCreateWithoutWorkHoursInput {
  id?: Maybe<ID_Input>;
  establishment: EstablishmentCreateOneWithoutEmployeesInput;
  employeeId: Int;
  name: String;
  role: String;
  tables?: Maybe<TableDataCreateManyWithoutWaiterInput>;
  orderPads?: Maybe<OrderPadCreateManyWithoutEmployeeInput>;
  itemsOrdered?: Maybe<OrderItemCreateManyWithoutEmployeeInput>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive: Boolean;
}

export interface WorkHourUpdateInput {
  weekday?: Maybe<WeekDay>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  isDayOff?: Maybe<Boolean>;
  employee?: Maybe<EmployeeUpdateOneRequiredWithoutWorkHoursInput>;
}

export interface EmployeeUpdateOneRequiredWithoutWorkHoursInput {
  create?: Maybe<EmployeeCreateWithoutWorkHoursInput>;
  update?: Maybe<EmployeeUpdateWithoutWorkHoursDataInput>;
  upsert?: Maybe<EmployeeUpsertWithoutWorkHoursInput>;
  connect?: Maybe<EmployeeWhereUniqueInput>;
}

export interface EmployeeUpdateWithoutWorkHoursDataInput {
  establishment?: Maybe<EstablishmentUpdateOneRequiredWithoutEmployeesInput>;
  employeeId?: Maybe<Int>;
  name?: Maybe<String>;
  role?: Maybe<String>;
  tables?: Maybe<TableDataUpdateManyWithoutWaiterInput>;
  orderPads?: Maybe<OrderPadUpdateManyWithoutEmployeeInput>;
  itemsOrdered?: Maybe<OrderItemUpdateManyWithoutEmployeeInput>;
  admissionDate?: Maybe<DateTimeInput>;
  terminationDate?: Maybe<DateTimeInput>;
  isActive?: Maybe<Boolean>;
}

export interface EmployeeUpsertWithoutWorkHoursInput {
  update: EmployeeUpdateWithoutWorkHoursDataInput;
  create: EmployeeCreateWithoutWorkHoursInput;
}

export interface WorkHourUpdateManyMutationInput {
  weekday?: Maybe<WeekDay>;
  startTime?: Maybe<String>;
  endTime?: Maybe<String>;
  isDayOff?: Maybe<Boolean>;
}

export interface BillSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BillWhereInput>;
  AND?: Maybe<BillSubscriptionWhereInput[] | BillSubscriptionWhereInput>;
  OR?: Maybe<BillSubscriptionWhereInput[] | BillSubscriptionWhereInput>;
  NOT?: Maybe<BillSubscriptionWhereInput[] | BillSubscriptionWhereInput>;
}

export interface CheckDataSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CheckDataWhereInput>;
  AND?: Maybe<
    CheckDataSubscriptionWhereInput[] | CheckDataSubscriptionWhereInput
  >;
  OR?: Maybe<
    CheckDataSubscriptionWhereInput[] | CheckDataSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CheckDataSubscriptionWhereInput[] | CheckDataSubscriptionWhereInput
  >;
}

export interface ClientSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClientWhereInput>;
  AND?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
  OR?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
  NOT?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
}

export interface EmployeeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmployeeWhereInput>;
  AND?: Maybe<
    EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput
  >;
  OR?: Maybe<EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput>;
  NOT?: Maybe<
    EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput
  >;
}

export interface EstablishmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EstablishmentWhereInput>;
  AND?: Maybe<
    EstablishmentSubscriptionWhereInput[] | EstablishmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    EstablishmentSubscriptionWhereInput[] | EstablishmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    EstablishmentSubscriptionWhereInput[] | EstablishmentSubscriptionWhereInput
  >;
}

export interface ExpenseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpenseWhereInput>;
  AND?: Maybe<ExpenseSubscriptionWhereInput[] | ExpenseSubscriptionWhereInput>;
  OR?: Maybe<ExpenseSubscriptionWhereInput[] | ExpenseSubscriptionWhereInput>;
  NOT?: Maybe<ExpenseSubscriptionWhereInput[] | ExpenseSubscriptionWhereInput>;
}

export interface ExpenseItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpenseItemWhereInput>;
  AND?: Maybe<
    ExpenseItemSubscriptionWhereInput[] | ExpenseItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    ExpenseItemSubscriptionWhereInput[] | ExpenseItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ExpenseItemSubscriptionWhereInput[] | ExpenseItemSubscriptionWhereInput
  >;
}

export interface IncomeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<IncomeWhereInput>;
  AND?: Maybe<IncomeSubscriptionWhereInput[] | IncomeSubscriptionWhereInput>;
  OR?: Maybe<IncomeSubscriptionWhereInput[] | IncomeSubscriptionWhereInput>;
  NOT?: Maybe<IncomeSubscriptionWhereInput[] | IncomeSubscriptionWhereInput>;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface NCMSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NCMWhereInput>;
  AND?: Maybe<NCMSubscriptionWhereInput[] | NCMSubscriptionWhereInput>;
  OR?: Maybe<NCMSubscriptionWhereInput[] | NCMSubscriptionWhereInput>;
  NOT?: Maybe<NCMSubscriptionWhereInput[] | NCMSubscriptionWhereInput>;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderWhereInput>;
  AND?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  OR?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  NOT?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
}

export interface OrderItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderItemWhereInput>;
  AND?: Maybe<
    OrderItemSubscriptionWhereInput[] | OrderItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    OrderItemSubscriptionWhereInput[] | OrderItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    OrderItemSubscriptionWhereInput[] | OrderItemSubscriptionWhereInput
  >;
}

export interface OrderPadSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderPadWhereInput>;
  AND?: Maybe<
    OrderPadSubscriptionWhereInput[] | OrderPadSubscriptionWhereInput
  >;
  OR?: Maybe<OrderPadSubscriptionWhereInput[] | OrderPadSubscriptionWhereInput>;
  NOT?: Maybe<
    OrderPadSubscriptionWhereInput[] | OrderPadSubscriptionWhereInput
  >;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PaymentWhereInput>;
  AND?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  OR?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  NOT?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
}

export interface PermissionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PermissionWhereInput>;
  AND?: Maybe<
    PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput
  >;
  OR?: Maybe<
    PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput
  >;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface TableSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TableWhereInput>;
  AND?: Maybe<TableSubscriptionWhereInput[] | TableSubscriptionWhereInput>;
  OR?: Maybe<TableSubscriptionWhereInput[] | TableSubscriptionWhereInput>;
  NOT?: Maybe<TableSubscriptionWhereInput[] | TableSubscriptionWhereInput>;
}

export interface TableDataSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TableDataWhereInput>;
  AND?: Maybe<
    TableDataSubscriptionWhereInput[] | TableDataSubscriptionWhereInput
  >;
  OR?: Maybe<
    TableDataSubscriptionWhereInput[] | TableDataSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TableDataSubscriptionWhereInput[] | TableDataSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface WorkDaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WorkDayWhereInput>;
  AND?: Maybe<WorkDaySubscriptionWhereInput[] | WorkDaySubscriptionWhereInput>;
  OR?: Maybe<WorkDaySubscriptionWhereInput[] | WorkDaySubscriptionWhereInput>;
  NOT?: Maybe<WorkDaySubscriptionWhereInput[] | WorkDaySubscriptionWhereInput>;
}

export interface WorkHourSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<WorkHourWhereInput>;
  AND?: Maybe<
    WorkHourSubscriptionWhereInput[] | WorkHourSubscriptionWhereInput
  >;
  OR?: Maybe<WorkHourSubscriptionWhereInput[] | WorkHourSubscriptionWhereInput>;
  NOT?: Maybe<
    WorkHourSubscriptionWhereInput[] | WorkHourSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Bill {
  createdAt: DateTimeOutput;
  closedAt?: DateTimeOutput;
  id: ID_Output;
  status: BillStatus;
  discount?: Float;
  discountReason?: String;
  value?: Float;
  wasReopen?: Boolean;
  registered?: Boolean;
}

export interface BillPromise extends Promise<Bill>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  closedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  workDay: <T = WorkDayPromise>() => T;
  tableData: <T = TableDataPromise>() => T;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<BillStatus>;
  discount: () => Promise<Float>;
  discountReason: () => Promise<String>;
  value: () => Promise<Float>;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  wasReopen: () => Promise<Boolean>;
  reopenBills: <T = FragmentableArray<Bill>>(args?: {
    where?: BillWhereInput;
    orderBy?: BillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  registered: () => Promise<Boolean>;
}

export interface BillSubscription
  extends Promise<AsyncIterator<Bill>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  closedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  workDay: <T = WorkDaySubscription>() => T;
  tableData: <T = TableDataSubscription>() => T;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<AsyncIterator<BillStatus>>;
  discount: () => Promise<AsyncIterator<Float>>;
  discountReason: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<Float>>;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  wasReopen: () => Promise<AsyncIterator<Boolean>>;
  reopenBills: <T = Promise<AsyncIterator<BillSubscription>>>(args?: {
    where?: BillWhereInput;
    orderBy?: BillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  registered: () => Promise<AsyncIterator<Boolean>>;
}

export interface BillNullablePromise
  extends Promise<Bill | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  closedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  workDay: <T = WorkDayPromise>() => T;
  tableData: <T = TableDataPromise>() => T;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<BillStatus>;
  discount: () => Promise<Float>;
  discountReason: () => Promise<String>;
  value: () => Promise<Float>;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  wasReopen: () => Promise<Boolean>;
  reopenBills: <T = FragmentableArray<Bill>>(args?: {
    where?: BillWhereInput;
    orderBy?: BillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  registered: () => Promise<Boolean>;
}

export interface WorkDay {
  createdAt: DateTimeOutput;
  id: ID_Output;
  isCurrent: Boolean;
  openDate: DateTimeOutput;
  closeDate?: DateTimeOutput;
}

export interface WorkDayPromise extends Promise<WorkDay>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  establishment: <T = EstablishmentPromise>() => T;
  isCurrent: () => Promise<Boolean>;
  openDate: () => Promise<DateTimeOutput>;
  closeDate: () => Promise<DateTimeOutput>;
  userResponsible: <T = UserPromise>() => T;
  tables: <T = FragmentableArray<TableData>>(args?: {
    where?: TableDataWhereInput;
    orderBy?: TableDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  incomes: <T = FragmentableArray<Income>>(args?: {
    where?: IncomeWhereInput;
    orderBy?: IncomeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bills: <T = FragmentableArray<Bill>>(args?: {
    where?: BillWhereInput;
    orderBy?: BillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orderPads: <T = FragmentableArray<OrderPad>>(args?: {
    where?: OrderPadWhereInput;
    orderBy?: OrderPadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WorkDaySubscription
  extends Promise<AsyncIterator<WorkDay>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  establishment: <T = EstablishmentSubscription>() => T;
  isCurrent: () => Promise<AsyncIterator<Boolean>>;
  openDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  closeDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  userResponsible: <T = UserSubscription>() => T;
  tables: <T = Promise<AsyncIterator<TableDataSubscription>>>(args?: {
    where?: TableDataWhereInput;
    orderBy?: TableDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  incomes: <T = Promise<AsyncIterator<IncomeSubscription>>>(args?: {
    where?: IncomeWhereInput;
    orderBy?: IncomeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bills: <T = Promise<AsyncIterator<BillSubscription>>>(args?: {
    where?: BillWhereInput;
    orderBy?: BillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orderPads: <T = Promise<AsyncIterator<OrderPadSubscription>>>(args?: {
    where?: OrderPadWhereInput;
    orderBy?: OrderPadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WorkDayNullablePromise
  extends Promise<WorkDay | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  establishment: <T = EstablishmentPromise>() => T;
  isCurrent: () => Promise<Boolean>;
  openDate: () => Promise<DateTimeOutput>;
  closeDate: () => Promise<DateTimeOutput>;
  userResponsible: <T = UserPromise>() => T;
  tables: <T = FragmentableArray<TableData>>(args?: {
    where?: TableDataWhereInput;
    orderBy?: TableDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  incomes: <T = FragmentableArray<Income>>(args?: {
    where?: IncomeWhereInput;
    orderBy?: IncomeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bills: <T = FragmentableArray<Bill>>(args?: {
    where?: BillWhereInput;
    orderBy?: BillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orderPads: <T = FragmentableArray<OrderPad>>(args?: {
    where?: OrderPadWhereInput;
    orderBy?: OrderPadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Establishment {
  createdAt: DateTimeOutput;
  id: ID_Output;
  name: String;
  lat: Float;
  long: Float;
  restaurantId: String;
  valueInCashRegister: Float;
  maximumInCashRegister: Float;
  incomeMaxReference: Int;
  isOpen: Boolean;
  discountReasons: String[];
  totalInvoices?: Int;
}

export interface EstablishmentPromise
  extends Promise<Establishment>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  lat: () => Promise<Float>;
  long: () => Promise<Float>;
  restaurantId: () => Promise<String>;
  valueInCashRegister: () => Promise<Float>;
  maximumInCashRegister: () => Promise<Float>;
  incomeMaxReference: () => Promise<Int>;
  isOpen: () => Promise<Boolean>;
  workingDays: <T = FragmentableArray<WorkDay>>(args?: {
    where?: WorkDayWhereInput;
    orderBy?: WorkDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  permissions: <T = FragmentableArray<Permission>>(args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  employees: <T = FragmentableArray<Employee>>(args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tables: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  expenses: <T = FragmentableArray<Expense>>(args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  discountReasons: () => Promise<String[]>;
  totalInvoices: () => Promise<Int>;
  clients: <T = FragmentableArray<Client>>(args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EstablishmentSubscription
  extends Promise<AsyncIterator<Establishment>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  lat: () => Promise<AsyncIterator<Float>>;
  long: () => Promise<AsyncIterator<Float>>;
  restaurantId: () => Promise<AsyncIterator<String>>;
  valueInCashRegister: () => Promise<AsyncIterator<Float>>;
  maximumInCashRegister: () => Promise<AsyncIterator<Float>>;
  incomeMaxReference: () => Promise<AsyncIterator<Int>>;
  isOpen: () => Promise<AsyncIterator<Boolean>>;
  workingDays: <T = Promise<AsyncIterator<WorkDaySubscription>>>(args?: {
    where?: WorkDayWhereInput;
    orderBy?: WorkDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  permissions: <T = Promise<AsyncIterator<PermissionSubscription>>>(args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  employees: <T = Promise<AsyncIterator<EmployeeSubscription>>>(args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tables: <T = Promise<AsyncIterator<TableSubscription>>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  expenses: <T = Promise<AsyncIterator<ExpenseSubscription>>>(args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  discountReasons: () => Promise<AsyncIterator<String[]>>;
  totalInvoices: () => Promise<AsyncIterator<Int>>;
  clients: <T = Promise<AsyncIterator<ClientSubscription>>>(args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EstablishmentNullablePromise
  extends Promise<Establishment | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  lat: () => Promise<Float>;
  long: () => Promise<Float>;
  restaurantId: () => Promise<String>;
  valueInCashRegister: () => Promise<Float>;
  maximumInCashRegister: () => Promise<Float>;
  incomeMaxReference: () => Promise<Int>;
  isOpen: () => Promise<Boolean>;
  workingDays: <T = FragmentableArray<WorkDay>>(args?: {
    where?: WorkDayWhereInput;
    orderBy?: WorkDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  permissions: <T = FragmentableArray<Permission>>(args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  employees: <T = FragmentableArray<Employee>>(args?: {
    where?: EmployeeWhereInput;
    orderBy?: EmployeeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tables: <T = FragmentableArray<Table>>(args?: {
    where?: TableWhereInput;
    orderBy?: TableOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  expenses: <T = FragmentableArray<Expense>>(args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  discountReasons: () => Promise<String[]>;
  totalInvoices: () => Promise<Int>;
  clients: <T = FragmentableArray<Client>>(args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Permission {
  createdAt: DateTimeOutput;
  id: ID_Output;
  role: UserRole;
}

export interface PermissionPromise extends Promise<Permission>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  establishment: <T = EstablishmentPromise>() => T;
  role: () => Promise<UserRole>;
}

export interface PermissionSubscription
  extends Promise<AsyncIterator<Permission>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  establishment: <T = EstablishmentSubscription>() => T;
  role: () => Promise<AsyncIterator<UserRole>>;
}

export interface PermissionNullablePromise
  extends Promise<Permission | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  establishment: <T = EstablishmentPromise>() => T;
  role: () => Promise<UserRole>;
}

export interface User {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  email?: String;
  password?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  permissions: <T = FragmentableArray<Permission>>(args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<String>;
  password: () => Promise<String>;
  responsibleWorkDays: <T = FragmentableArray<WorkDay>>(args?: {
    where?: WorkDayWhereInput;
    orderBy?: WorkDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  permissions: <T = Promise<AsyncIterator<PermissionSubscription>>>(args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  responsibleWorkDays: <
    T = Promise<AsyncIterator<WorkDaySubscription>>
  >(args?: {
    where?: WorkDayWhereInput;
    orderBy?: WorkDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  permissions: <T = FragmentableArray<Permission>>(args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<String>;
  password: () => Promise<String>;
  responsibleWorkDays: <T = FragmentableArray<WorkDay>>(args?: {
    where?: WorkDayWhereInput;
    orderBy?: WorkDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Item {
  id: ID_Output;
  itemId: String;
  name: String;
  price: Float;
  priceToGo?: Float;
  employeePrice?: Float;
  category: String;
  canTakeToGo?: Boolean;
  isActive: Boolean;
  hasTaxSubstitution?: Boolean;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  itemId: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  priceToGo: () => Promise<Float>;
  employeePrice: () => Promise<Float>;
  category: () => Promise<String>;
  orderItem: <T = FragmentableArray<OrderItem>>(args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  establishment: <T = EstablishmentPromise>() => T;
  canTakeToGo: () => Promise<Boolean>;
  isActive: () => Promise<Boolean>;
  itemNCM: <T = NCMPromise>() => T;
  hasTaxSubstitution: () => Promise<Boolean>;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  itemId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  priceToGo: () => Promise<AsyncIterator<Float>>;
  employeePrice: () => Promise<AsyncIterator<Float>>;
  category: () => Promise<AsyncIterator<String>>;
  orderItem: <T = Promise<AsyncIterator<OrderItemSubscription>>>(args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  establishment: <T = EstablishmentSubscription>() => T;
  canTakeToGo: () => Promise<AsyncIterator<Boolean>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  itemNCM: <T = NCMSubscription>() => T;
  hasTaxSubstitution: () => Promise<AsyncIterator<Boolean>>;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  itemId: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  priceToGo: () => Promise<Float>;
  employeePrice: () => Promise<Float>;
  category: () => Promise<String>;
  orderItem: <T = FragmentableArray<OrderItem>>(args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  establishment: <T = EstablishmentPromise>() => T;
  canTakeToGo: () => Promise<Boolean>;
  isActive: () => Promise<Boolean>;
  itemNCM: <T = NCMPromise>() => T;
  hasTaxSubstitution: () => Promise<Boolean>;
}

export interface OrderItem {
  id: ID_Output;
  quantity: Int;
}

export interface OrderItemPromise extends Promise<OrderItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
  item: <T = ItemPromise>() => T;
  order: <T = OrderPromise>() => T;
  employee: <T = EmployeePromise>() => T;
}

export interface OrderItemSubscription
  extends Promise<AsyncIterator<OrderItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  item: <T = ItemSubscription>() => T;
  order: <T = OrderSubscription>() => T;
  employee: <T = EmployeeSubscription>() => T;
}

export interface OrderItemNullablePromise
  extends Promise<OrderItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
  item: <T = ItemPromise>() => T;
  order: <T = OrderPromise>() => T;
  employee: <T = EmployeePromise>() => T;
}

export interface Order {
  createdAt: DateTimeOutput;
  id: ID_Output;
  block: Int;
  orderId: Int;
  cancelled?: Boolean;
  cancelationJustification?: String;
  wasModified?: Boolean;
  isEmployeeOrder?: Boolean;
  reuse?: Boolean;
  isToGo?: Boolean;
  toGoReference?: String;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  workDay: <T = WorkDayPromise>() => T;
  block: () => Promise<Int>;
  orderId: () => Promise<Int>;
  bill: <T = BillPromise>() => T;
  orderItems: <T = FragmentableArray<OrderItem>>(args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cancelled: () => Promise<Boolean>;
  cancelationJustification: () => Promise<String>;
  wasModified: () => Promise<Boolean>;
  modifiedOrders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isEmployeeOrder: () => Promise<Boolean>;
  reuse: () => Promise<Boolean>;
  isToGo: () => Promise<Boolean>;
  toGoReference: () => Promise<String>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  workDay: <T = WorkDaySubscription>() => T;
  block: () => Promise<AsyncIterator<Int>>;
  orderId: () => Promise<AsyncIterator<Int>>;
  bill: <T = BillSubscription>() => T;
  orderItems: <T = Promise<AsyncIterator<OrderItemSubscription>>>(args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cancelled: () => Promise<AsyncIterator<Boolean>>;
  cancelationJustification: () => Promise<AsyncIterator<String>>;
  wasModified: () => Promise<AsyncIterator<Boolean>>;
  modifiedOrders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isEmployeeOrder: () => Promise<AsyncIterator<Boolean>>;
  reuse: () => Promise<AsyncIterator<Boolean>>;
  isToGo: () => Promise<AsyncIterator<Boolean>>;
  toGoReference: () => Promise<AsyncIterator<String>>;
}

export interface OrderNullablePromise
  extends Promise<Order | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  workDay: <T = WorkDayPromise>() => T;
  block: () => Promise<Int>;
  orderId: () => Promise<Int>;
  bill: <T = BillPromise>() => T;
  orderItems: <T = FragmentableArray<OrderItem>>(args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cancelled: () => Promise<Boolean>;
  cancelationJustification: () => Promise<String>;
  wasModified: () => Promise<Boolean>;
  modifiedOrders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isEmployeeOrder: () => Promise<Boolean>;
  reuse: () => Promise<Boolean>;
  isToGo: () => Promise<Boolean>;
  toGoReference: () => Promise<String>;
}

export interface Employee {
  createdAt: DateTimeOutput;
  id: ID_Output;
  employeeId: Int;
  name: String;
  role: String;
  admissionDate?: DateTimeOutput;
  terminationDate?: DateTimeOutput;
  isActive: Boolean;
}

export interface EmployeePromise extends Promise<Employee>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  establishment: <T = EstablishmentPromise>() => T;
  employeeId: () => Promise<Int>;
  name: () => Promise<String>;
  role: () => Promise<String>;
  tables: <T = FragmentableArray<TableData>>(args?: {
    where?: TableDataWhereInput;
    orderBy?: TableDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orderPads: <T = FragmentableArray<OrderPad>>(args?: {
    where?: OrderPadWhereInput;
    orderBy?: OrderPadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  itemsOrdered: <T = FragmentableArray<OrderItem>>(args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  workHours: <T = FragmentableArray<WorkHour>>(args?: {
    where?: WorkHourWhereInput;
    orderBy?: WorkHourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admissionDate: () => Promise<DateTimeOutput>;
  terminationDate: () => Promise<DateTimeOutput>;
  isActive: () => Promise<Boolean>;
}

export interface EmployeeSubscription
  extends Promise<AsyncIterator<Employee>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  establishment: <T = EstablishmentSubscription>() => T;
  employeeId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<String>>;
  tables: <T = Promise<AsyncIterator<TableDataSubscription>>>(args?: {
    where?: TableDataWhereInput;
    orderBy?: TableDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orderPads: <T = Promise<AsyncIterator<OrderPadSubscription>>>(args?: {
    where?: OrderPadWhereInput;
    orderBy?: OrderPadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  itemsOrdered: <T = Promise<AsyncIterator<OrderItemSubscription>>>(args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  workHours: <T = Promise<AsyncIterator<WorkHourSubscription>>>(args?: {
    where?: WorkHourWhereInput;
    orderBy?: WorkHourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admissionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  terminationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
}

export interface EmployeeNullablePromise
  extends Promise<Employee | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  establishment: <T = EstablishmentPromise>() => T;
  employeeId: () => Promise<Int>;
  name: () => Promise<String>;
  role: () => Promise<String>;
  tables: <T = FragmentableArray<TableData>>(args?: {
    where?: TableDataWhereInput;
    orderBy?: TableDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  orderPads: <T = FragmentableArray<OrderPad>>(args?: {
    where?: OrderPadWhereInput;
    orderBy?: OrderPadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  itemsOrdered: <T = FragmentableArray<OrderItem>>(args?: {
    where?: OrderItemWhereInput;
    orderBy?: OrderItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  workHours: <T = FragmentableArray<WorkHour>>(args?: {
    where?: WorkHourWhereInput;
    orderBy?: WorkHourOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  admissionDate: () => Promise<DateTimeOutput>;
  terminationDate: () => Promise<DateTimeOutput>;
  isActive: () => Promise<Boolean>;
}

export interface TableData {
  id: ID_Output;
  totalOccupations: Int;
}

export interface TableDataPromise extends Promise<TableData>, Fragmentable {
  id: () => Promise<ID_Output>;
  totalOccupations: () => Promise<Int>;
  table: <T = TablePromise>() => T;
  workDay: <T = WorkDayPromise>() => T;
  waiter: <T = EmployeePromise>() => T;
  bills: <T = FragmentableArray<Bill>>(args?: {
    where?: BillWhereInput;
    orderBy?: BillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TableDataSubscription
  extends Promise<AsyncIterator<TableData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  totalOccupations: () => Promise<AsyncIterator<Int>>;
  table: <T = TableSubscription>() => T;
  workDay: <T = WorkDaySubscription>() => T;
  waiter: <T = EmployeeSubscription>() => T;
  bills: <T = Promise<AsyncIterator<BillSubscription>>>(args?: {
    where?: BillWhereInput;
    orderBy?: BillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TableDataNullablePromise
  extends Promise<TableData | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  totalOccupations: () => Promise<Int>;
  table: <T = TablePromise>() => T;
  workDay: <T = WorkDayPromise>() => T;
  waiter: <T = EmployeePromise>() => T;
  bills: <T = FragmentableArray<Bill>>(args?: {
    where?: BillWhereInput;
    orderBy?: BillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Table {
  id: ID_Output;
  tableNumber: Int;
}

export interface TablePromise extends Promise<Table>, Fragmentable {
  id: () => Promise<ID_Output>;
  tableNumber: () => Promise<Int>;
  establishment: <T = EstablishmentPromise>() => T;
  data: <T = FragmentableArray<TableData>>(args?: {
    where?: TableDataWhereInput;
    orderBy?: TableDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TableSubscription
  extends Promise<AsyncIterator<Table>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  tableNumber: () => Promise<AsyncIterator<Int>>;
  establishment: <T = EstablishmentSubscription>() => T;
  data: <T = Promise<AsyncIterator<TableDataSubscription>>>(args?: {
    where?: TableDataWhereInput;
    orderBy?: TableDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TableNullablePromise
  extends Promise<Table | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  tableNumber: () => Promise<Int>;
  establishment: <T = EstablishmentPromise>() => T;
  data: <T = FragmentableArray<TableData>>(args?: {
    where?: TableDataWhereInput;
    orderBy?: TableDataOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OrderPad {
  id: ID_Output;
  block: Int;
  firstOrderId: Int;
  lastOrderId?: Int;
  used: Boolean;
}

export interface OrderPadPromise extends Promise<OrderPad>, Fragmentable {
  id: () => Promise<ID_Output>;
  workDay: <T = WorkDayPromise>() => T;
  block: () => Promise<Int>;
  firstOrderId: () => Promise<Int>;
  lastOrderId: () => Promise<Int>;
  employee: <T = EmployeePromise>() => T;
  used: () => Promise<Boolean>;
}

export interface OrderPadSubscription
  extends Promise<AsyncIterator<OrderPad>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  workDay: <T = WorkDaySubscription>() => T;
  block: () => Promise<AsyncIterator<Int>>;
  firstOrderId: () => Promise<AsyncIterator<Int>>;
  lastOrderId: () => Promise<AsyncIterator<Int>>;
  employee: <T = EmployeeSubscription>() => T;
  used: () => Promise<AsyncIterator<Boolean>>;
}

export interface OrderPadNullablePromise
  extends Promise<OrderPad | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  workDay: <T = WorkDayPromise>() => T;
  block: () => Promise<Int>;
  firstOrderId: () => Promise<Int>;
  lastOrderId: () => Promise<Int>;
  employee: <T = EmployeePromise>() => T;
  used: () => Promise<Boolean>;
}

export interface WorkHour {
  id: ID_Output;
  weekday: WeekDay;
  startTime?: String;
  endTime?: String;
  isDayOff?: Boolean;
}

export interface WorkHourPromise extends Promise<WorkHour>, Fragmentable {
  id: () => Promise<ID_Output>;
  weekday: () => Promise<WeekDay>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  isDayOff: () => Promise<Boolean>;
  employee: <T = EmployeePromise>() => T;
}

export interface WorkHourSubscription
  extends Promise<AsyncIterator<WorkHour>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weekday: () => Promise<AsyncIterator<WeekDay>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
  isDayOff: () => Promise<AsyncIterator<Boolean>>;
  employee: <T = EmployeeSubscription>() => T;
}

export interface WorkHourNullablePromise
  extends Promise<WorkHour | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  weekday: () => Promise<WeekDay>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  isDayOff: () => Promise<Boolean>;
  employee: <T = EmployeePromise>() => T;
}

export interface NCM {
  id: ID_Output;
  identifier: String;
  description?: String;
}

export interface NCMPromise extends Promise<NCM>, Fragmentable {
  id: () => Promise<ID_Output>;
  identifier: () => Promise<String>;
  description: () => Promise<String>;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NCMSubscription
  extends Promise<AsyncIterator<NCM>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  identifier: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NCMNullablePromise extends Promise<NCM | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  identifier: () => Promise<String>;
  description: () => Promise<String>;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Expense {
  createdAt: DateTimeOutput;
  id: ID_Output;
  NFE: Boolean;
  NFEReference?: String;
  date: DateTimeOutput;
  executionDate: DateTimeOutput;
}

export interface ExpensePromise extends Promise<Expense>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  establishment: <T = EstablishmentPromise>() => T;
  NFE: () => Promise<Boolean>;
  NFEReference: () => Promise<String>;
  expenseItems: <T = FragmentableArray<ExpenseItem>>(args?: {
    where?: ExpenseItemWhereInput;
    orderBy?: ExpenseItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  date: () => Promise<DateTimeOutput>;
  executionDate: () => Promise<DateTimeOutput>;
  payment: <T = PaymentPromise>() => T;
}

export interface ExpenseSubscription
  extends Promise<AsyncIterator<Expense>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  establishment: <T = EstablishmentSubscription>() => T;
  NFE: () => Promise<AsyncIterator<Boolean>>;
  NFEReference: () => Promise<AsyncIterator<String>>;
  expenseItems: <T = Promise<AsyncIterator<ExpenseItemSubscription>>>(args?: {
    where?: ExpenseItemWhereInput;
    orderBy?: ExpenseItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  executionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  payment: <T = PaymentSubscription>() => T;
}

export interface ExpenseNullablePromise
  extends Promise<Expense | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  establishment: <T = EstablishmentPromise>() => T;
  NFE: () => Promise<Boolean>;
  NFEReference: () => Promise<String>;
  expenseItems: <T = FragmentableArray<ExpenseItem>>(args?: {
    where?: ExpenseItemWhereInput;
    orderBy?: ExpenseItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  date: () => Promise<DateTimeOutput>;
  executionDate: () => Promise<DateTimeOutput>;
  payment: <T = PaymentPromise>() => T;
}

export interface ExpenseItem {
  createdAt: DateTimeOutput;
  id: ID_Output;
  quantity: Float;
  value: Float;
  details?: String;
}

export interface ExpenseItemPromise extends Promise<ExpenseItem>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Float>;
  product: <T = ProductPromise>() => T;
  value: () => Promise<Float>;
  details: () => Promise<String>;
}

export interface ExpenseItemSubscription
  extends Promise<AsyncIterator<ExpenseItem>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Float>>;
  product: <T = ProductSubscription>() => T;
  value: () => Promise<AsyncIterator<Float>>;
  details: () => Promise<AsyncIterator<String>>;
}

export interface ExpenseItemNullablePromise
  extends Promise<ExpenseItem | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Float>;
  product: <T = ProductPromise>() => T;
  value: () => Promise<Float>;
  details: () => Promise<String>;
}

export interface Product {
  id: ID_Output;
  name: String;
  category: String;
  supplier: String;
  brand?: String;
  unit: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<String>;
  supplier: () => Promise<String>;
  brand: () => Promise<String>;
  unit: () => Promise<String>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  supplier: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
  unit: () => Promise<AsyncIterator<String>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<String>;
  supplier: () => Promise<String>;
  brand: () => Promise<String>;
  unit: () => Promise<String>;
}

export interface Payment {
  createdAt: DateTimeOutput;
  id: ID_Output;
  value: Float;
  paymentType: String;
  paymentTypeOption?: String;
  isActive: Boolean;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  value: () => Promise<Float>;
  paymentType: () => Promise<String>;
  paymentTypeOption: () => Promise<String>;
  checkData: <T = CheckDataPromise>() => T;
  bill: <T = BillPromise>() => T;
  expense: <T = ExpensePromise>() => T;
  isActive: () => Promise<Boolean>;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Float>>;
  paymentType: () => Promise<AsyncIterator<String>>;
  paymentTypeOption: () => Promise<AsyncIterator<String>>;
  checkData: <T = CheckDataSubscription>() => T;
  bill: <T = BillSubscription>() => T;
  expense: <T = ExpenseSubscription>() => T;
  isActive: () => Promise<AsyncIterator<Boolean>>;
}

export interface PaymentNullablePromise
  extends Promise<Payment | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  value: () => Promise<Float>;
  paymentType: () => Promise<String>;
  paymentTypeOption: () => Promise<String>;
  checkData: <T = CheckDataPromise>() => T;
  bill: <T = BillPromise>() => T;
  expense: <T = ExpensePromise>() => T;
  isActive: () => Promise<Boolean>;
}

export interface CheckData {
  id: ID_Output;
  checkbookId?: String;
  compensationNumber?: Int;
  bankNumber?: Int;
}

export interface CheckDataPromise extends Promise<CheckData>, Fragmentable {
  id: () => Promise<ID_Output>;
  payment: <T = PaymentPromise>() => T;
  checkbookId: () => Promise<String>;
  compensationNumber: () => Promise<Int>;
  bankNumber: () => Promise<Int>;
}

export interface CheckDataSubscription
  extends Promise<AsyncIterator<CheckData>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  payment: <T = PaymentSubscription>() => T;
  checkbookId: () => Promise<AsyncIterator<String>>;
  compensationNumber: () => Promise<AsyncIterator<Int>>;
  bankNumber: () => Promise<AsyncIterator<Int>>;
}

export interface CheckDataNullablePromise
  extends Promise<CheckData | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  payment: <T = PaymentPromise>() => T;
  checkbookId: () => Promise<String>;
  compensationNumber: () => Promise<Int>;
  bankNumber: () => Promise<Int>;
}

export interface Client {
  id: ID_Output;
  name: String;
  address: String;
  complement?: String;
  postCode: String;
  telephoneNumber: String;
  distanceKm: String;
  distanceTime: String;
}

export interface ClientPromise extends Promise<Client>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  complement: () => Promise<String>;
  postCode: () => Promise<String>;
  telephoneNumber: () => Promise<String>;
  establishment: <T = EstablishmentPromise>() => T;
  distanceKm: () => Promise<String>;
  distanceTime: () => Promise<String>;
}

export interface ClientSubscription
  extends Promise<AsyncIterator<Client>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  complement: () => Promise<AsyncIterator<String>>;
  postCode: () => Promise<AsyncIterator<String>>;
  telephoneNumber: () => Promise<AsyncIterator<String>>;
  establishment: <T = EstablishmentSubscription>() => T;
  distanceKm: () => Promise<AsyncIterator<String>>;
  distanceTime: () => Promise<AsyncIterator<String>>;
}

export interface ClientNullablePromise
  extends Promise<Client | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  complement: () => Promise<String>;
  postCode: () => Promise<String>;
  telephoneNumber: () => Promise<String>;
  establishment: <T = EstablishmentPromise>() => T;
  distanceKm: () => Promise<String>;
  distanceTime: () => Promise<String>;
}

export interface Income {
  createdAt: DateTimeOutput;
  id: ID_Output;
  reference: String;
  value: Float;
  type?: String;
}

export interface IncomePromise extends Promise<Income>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  workDay: <T = WorkDayPromise>() => T;
  reference: () => Promise<String>;
  value: () => Promise<Float>;
  type: () => Promise<String>;
}

export interface IncomeSubscription
  extends Promise<AsyncIterator<Income>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  workDay: <T = WorkDaySubscription>() => T;
  reference: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<Float>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface IncomeNullablePromise
  extends Promise<Income | null>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  workDay: <T = WorkDayPromise>() => T;
  reference: () => Promise<String>;
  value: () => Promise<Float>;
  type: () => Promise<String>;
}

export interface BillConnection {
  pageInfo: PageInfo;
  edges: BillEdge[];
}

export interface BillConnectionPromise
  extends Promise<BillConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BillEdge>>() => T;
  aggregate: <T = AggregateBillPromise>() => T;
}

export interface BillConnectionSubscription
  extends Promise<AsyncIterator<BillConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BillEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBillSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BillEdge {
  node: Bill;
  cursor: String;
}

export interface BillEdgePromise extends Promise<BillEdge>, Fragmentable {
  node: <T = BillPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BillEdgeSubscription
  extends Promise<AsyncIterator<BillEdge>>,
    Fragmentable {
  node: <T = BillSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBill {
  count: Int;
}

export interface AggregateBillPromise
  extends Promise<AggregateBill>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBillSubscription
  extends Promise<AsyncIterator<AggregateBill>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CheckDataConnection {
  pageInfo: PageInfo;
  edges: CheckDataEdge[];
}

export interface CheckDataConnectionPromise
  extends Promise<CheckDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CheckDataEdge>>() => T;
  aggregate: <T = AggregateCheckDataPromise>() => T;
}

export interface CheckDataConnectionSubscription
  extends Promise<AsyncIterator<CheckDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CheckDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCheckDataSubscription>() => T;
}

export interface CheckDataEdge {
  node: CheckData;
  cursor: String;
}

export interface CheckDataEdgePromise
  extends Promise<CheckDataEdge>,
    Fragmentable {
  node: <T = CheckDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CheckDataEdgeSubscription
  extends Promise<AsyncIterator<CheckDataEdge>>,
    Fragmentable {
  node: <T = CheckDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCheckData {
  count: Int;
}

export interface AggregateCheckDataPromise
  extends Promise<AggregateCheckData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCheckDataSubscription
  extends Promise<AsyncIterator<AggregateCheckData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClientConnection {
  pageInfo: PageInfo;
  edges: ClientEdge[];
}

export interface ClientConnectionPromise
  extends Promise<ClientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClientEdge>>() => T;
  aggregate: <T = AggregateClientPromise>() => T;
}

export interface ClientConnectionSubscription
  extends Promise<AsyncIterator<ClientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClientSubscription>() => T;
}

export interface ClientEdge {
  node: Client;
  cursor: String;
}

export interface ClientEdgePromise extends Promise<ClientEdge>, Fragmentable {
  node: <T = ClientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClientEdgeSubscription
  extends Promise<AsyncIterator<ClientEdge>>,
    Fragmentable {
  node: <T = ClientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClient {
  count: Int;
}

export interface AggregateClientPromise
  extends Promise<AggregateClient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClientSubscription
  extends Promise<AsyncIterator<AggregateClient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeeConnection {
  pageInfo: PageInfo;
  edges: EmployeeEdge[];
}

export interface EmployeeConnectionPromise
  extends Promise<EmployeeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeeEdge>>() => T;
  aggregate: <T = AggregateEmployeePromise>() => T;
}

export interface EmployeeConnectionSubscription
  extends Promise<AsyncIterator<EmployeeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeeSubscription>() => T;
}

export interface EmployeeEdge {
  node: Employee;
  cursor: String;
}

export interface EmployeeEdgePromise
  extends Promise<EmployeeEdge>,
    Fragmentable {
  node: <T = EmployeePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeeEdgeSubscription
  extends Promise<AsyncIterator<EmployeeEdge>>,
    Fragmentable {
  node: <T = EmployeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmployee {
  count: Int;
}

export interface AggregateEmployeePromise
  extends Promise<AggregateEmployee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeeSubscription
  extends Promise<AsyncIterator<AggregateEmployee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EstablishmentConnection {
  pageInfo: PageInfo;
  edges: EstablishmentEdge[];
}

export interface EstablishmentConnectionPromise
  extends Promise<EstablishmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EstablishmentEdge>>() => T;
  aggregate: <T = AggregateEstablishmentPromise>() => T;
}

export interface EstablishmentConnectionSubscription
  extends Promise<AsyncIterator<EstablishmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EstablishmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEstablishmentSubscription>() => T;
}

export interface EstablishmentEdge {
  node: Establishment;
  cursor: String;
}

export interface EstablishmentEdgePromise
  extends Promise<EstablishmentEdge>,
    Fragmentable {
  node: <T = EstablishmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EstablishmentEdgeSubscription
  extends Promise<AsyncIterator<EstablishmentEdge>>,
    Fragmentable {
  node: <T = EstablishmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEstablishment {
  count: Int;
}

export interface AggregateEstablishmentPromise
  extends Promise<AggregateEstablishment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEstablishmentSubscription
  extends Promise<AsyncIterator<AggregateEstablishment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExpenseConnection {
  pageInfo: PageInfo;
  edges: ExpenseEdge[];
}

export interface ExpenseConnectionPromise
  extends Promise<ExpenseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpenseEdge>>() => T;
  aggregate: <T = AggregateExpensePromise>() => T;
}

export interface ExpenseConnectionSubscription
  extends Promise<AsyncIterator<ExpenseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExpenseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExpenseSubscription>() => T;
}

export interface ExpenseEdge {
  node: Expense;
  cursor: String;
}

export interface ExpenseEdgePromise extends Promise<ExpenseEdge>, Fragmentable {
  node: <T = ExpensePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpenseEdgeSubscription
  extends Promise<AsyncIterator<ExpenseEdge>>,
    Fragmentable {
  node: <T = ExpenseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExpense {
  count: Int;
}

export interface AggregateExpensePromise
  extends Promise<AggregateExpense>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpenseSubscription
  extends Promise<AsyncIterator<AggregateExpense>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExpenseItemConnection {
  pageInfo: PageInfo;
  edges: ExpenseItemEdge[];
}

export interface ExpenseItemConnectionPromise
  extends Promise<ExpenseItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpenseItemEdge>>() => T;
  aggregate: <T = AggregateExpenseItemPromise>() => T;
}

export interface ExpenseItemConnectionSubscription
  extends Promise<AsyncIterator<ExpenseItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExpenseItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExpenseItemSubscription>() => T;
}

export interface ExpenseItemEdge {
  node: ExpenseItem;
  cursor: String;
}

export interface ExpenseItemEdgePromise
  extends Promise<ExpenseItemEdge>,
    Fragmentable {
  node: <T = ExpenseItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpenseItemEdgeSubscription
  extends Promise<AsyncIterator<ExpenseItemEdge>>,
    Fragmentable {
  node: <T = ExpenseItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExpenseItem {
  count: Int;
}

export interface AggregateExpenseItemPromise
  extends Promise<AggregateExpenseItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpenseItemSubscription
  extends Promise<AsyncIterator<AggregateExpenseItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IncomeConnection {
  pageInfo: PageInfo;
  edges: IncomeEdge[];
}

export interface IncomeConnectionPromise
  extends Promise<IncomeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IncomeEdge>>() => T;
  aggregate: <T = AggregateIncomePromise>() => T;
}

export interface IncomeConnectionSubscription
  extends Promise<AsyncIterator<IncomeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IncomeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIncomeSubscription>() => T;
}

export interface IncomeEdge {
  node: Income;
  cursor: String;
}

export interface IncomeEdgePromise extends Promise<IncomeEdge>, Fragmentable {
  node: <T = IncomePromise>() => T;
  cursor: () => Promise<String>;
}

export interface IncomeEdgeSubscription
  extends Promise<AsyncIterator<IncomeEdge>>,
    Fragmentable {
  node: <T = IncomeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateIncome {
  count: Int;
}

export interface AggregateIncomePromise
  extends Promise<AggregateIncome>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIncomeSubscription
  extends Promise<AsyncIterator<AggregateIncome>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NCMConnection {
  pageInfo: PageInfo;
  edges: NCMEdge[];
}

export interface NCMConnectionPromise
  extends Promise<NCMConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NCMEdge>>() => T;
  aggregate: <T = AggregateNCMPromise>() => T;
}

export interface NCMConnectionSubscription
  extends Promise<AsyncIterator<NCMConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NCMEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNCMSubscription>() => T;
}

export interface NCMEdge {
  node: NCM;
  cursor: String;
}

export interface NCMEdgePromise extends Promise<NCMEdge>, Fragmentable {
  node: <T = NCMPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NCMEdgeSubscription
  extends Promise<AsyncIterator<NCMEdge>>,
    Fragmentable {
  node: <T = NCMSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNCM {
  count: Int;
}

export interface AggregateNCMPromise
  extends Promise<AggregateNCM>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNCMSubscription
  extends Promise<AsyncIterator<AggregateNCM>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderItemConnection {
  pageInfo: PageInfo;
  edges: OrderItemEdge[];
}

export interface OrderItemConnectionPromise
  extends Promise<OrderItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderItemEdge>>() => T;
  aggregate: <T = AggregateOrderItemPromise>() => T;
}

export interface OrderItemConnectionSubscription
  extends Promise<AsyncIterator<OrderItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderItemSubscription>() => T;
}

export interface OrderItemEdge {
  node: OrderItem;
  cursor: String;
}

export interface OrderItemEdgePromise
  extends Promise<OrderItemEdge>,
    Fragmentable {
  node: <T = OrderItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderItemEdgeSubscription
  extends Promise<AsyncIterator<OrderItemEdge>>,
    Fragmentable {
  node: <T = OrderItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrderItem {
  count: Int;
}

export interface AggregateOrderItemPromise
  extends Promise<AggregateOrderItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderItemSubscription
  extends Promise<AsyncIterator<AggregateOrderItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderPadConnection {
  pageInfo: PageInfo;
  edges: OrderPadEdge[];
}

export interface OrderPadConnectionPromise
  extends Promise<OrderPadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderPadEdge>>() => T;
  aggregate: <T = AggregateOrderPadPromise>() => T;
}

export interface OrderPadConnectionSubscription
  extends Promise<AsyncIterator<OrderPadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderPadEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderPadSubscription>() => T;
}

export interface OrderPadEdge {
  node: OrderPad;
  cursor: String;
}

export interface OrderPadEdgePromise
  extends Promise<OrderPadEdge>,
    Fragmentable {
  node: <T = OrderPadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderPadEdgeSubscription
  extends Promise<AsyncIterator<OrderPadEdge>>,
    Fragmentable {
  node: <T = OrderPadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrderPad {
  count: Int;
}

export interface AggregateOrderPadPromise
  extends Promise<AggregateOrderPad>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderPadSubscription
  extends Promise<AsyncIterator<AggregateOrderPad>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PermissionConnection {
  pageInfo: PageInfo;
  edges: PermissionEdge[];
}

export interface PermissionConnectionPromise
  extends Promise<PermissionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PermissionEdge>>() => T;
  aggregate: <T = AggregatePermissionPromise>() => T;
}

export interface PermissionConnectionSubscription
  extends Promise<AsyncIterator<PermissionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PermissionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePermissionSubscription>() => T;
}

export interface PermissionEdge {
  node: Permission;
  cursor: String;
}

export interface PermissionEdgePromise
  extends Promise<PermissionEdge>,
    Fragmentable {
  node: <T = PermissionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PermissionEdgeSubscription
  extends Promise<AsyncIterator<PermissionEdge>>,
    Fragmentable {
  node: <T = PermissionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePermission {
  count: Int;
}

export interface AggregatePermissionPromise
  extends Promise<AggregatePermission>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePermissionSubscription
  extends Promise<AsyncIterator<AggregatePermission>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TableConnection {
  pageInfo: PageInfo;
  edges: TableEdge[];
}

export interface TableConnectionPromise
  extends Promise<TableConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TableEdge>>() => T;
  aggregate: <T = AggregateTablePromise>() => T;
}

export interface TableConnectionSubscription
  extends Promise<AsyncIterator<TableConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TableEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTableSubscription>() => T;
}

export interface TableEdge {
  node: Table;
  cursor: String;
}

export interface TableEdgePromise extends Promise<TableEdge>, Fragmentable {
  node: <T = TablePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TableEdgeSubscription
  extends Promise<AsyncIterator<TableEdge>>,
    Fragmentable {
  node: <T = TableSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTable {
  count: Int;
}

export interface AggregateTablePromise
  extends Promise<AggregateTable>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTableSubscription
  extends Promise<AsyncIterator<AggregateTable>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TableDataConnection {
  pageInfo: PageInfo;
  edges: TableDataEdge[];
}

export interface TableDataConnectionPromise
  extends Promise<TableDataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TableDataEdge>>() => T;
  aggregate: <T = AggregateTableDataPromise>() => T;
}

export interface TableDataConnectionSubscription
  extends Promise<AsyncIterator<TableDataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TableDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTableDataSubscription>() => T;
}

export interface TableDataEdge {
  node: TableData;
  cursor: String;
}

export interface TableDataEdgePromise
  extends Promise<TableDataEdge>,
    Fragmentable {
  node: <T = TableDataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TableDataEdgeSubscription
  extends Promise<AsyncIterator<TableDataEdge>>,
    Fragmentable {
  node: <T = TableDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTableData {
  count: Int;
}

export interface AggregateTableDataPromise
  extends Promise<AggregateTableData>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTableDataSubscription
  extends Promise<AsyncIterator<AggregateTableData>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkDayConnection {
  pageInfo: PageInfo;
  edges: WorkDayEdge[];
}

export interface WorkDayConnectionPromise
  extends Promise<WorkDayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkDayEdge>>() => T;
  aggregate: <T = AggregateWorkDayPromise>() => T;
}

export interface WorkDayConnectionSubscription
  extends Promise<AsyncIterator<WorkDayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkDayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkDaySubscription>() => T;
}

export interface WorkDayEdge {
  node: WorkDay;
  cursor: String;
}

export interface WorkDayEdgePromise extends Promise<WorkDayEdge>, Fragmentable {
  node: <T = WorkDayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkDayEdgeSubscription
  extends Promise<AsyncIterator<WorkDayEdge>>,
    Fragmentable {
  node: <T = WorkDaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkDay {
  count: Int;
}

export interface AggregateWorkDayPromise
  extends Promise<AggregateWorkDay>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkDaySubscription
  extends Promise<AsyncIterator<AggregateWorkDay>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkHourConnection {
  pageInfo: PageInfo;
  edges: WorkHourEdge[];
}

export interface WorkHourConnectionPromise
  extends Promise<WorkHourConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkHourEdge>>() => T;
  aggregate: <T = AggregateWorkHourPromise>() => T;
}

export interface WorkHourConnectionSubscription
  extends Promise<AsyncIterator<WorkHourConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkHourEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkHourSubscription>() => T;
}

export interface WorkHourEdge {
  node: WorkHour;
  cursor: String;
}

export interface WorkHourEdgePromise
  extends Promise<WorkHourEdge>,
    Fragmentable {
  node: <T = WorkHourPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkHourEdgeSubscription
  extends Promise<AsyncIterator<WorkHourEdge>>,
    Fragmentable {
  node: <T = WorkHourSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkHour {
  count: Int;
}

export interface AggregateWorkHourPromise
  extends Promise<AggregateWorkHour>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkHourSubscription
  extends Promise<AsyncIterator<AggregateWorkHour>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BillSubscriptionPayload {
  mutation: MutationType;
  node: Bill;
  updatedFields: String[];
  previousValues: BillPreviousValues;
}

export interface BillSubscriptionPayloadPromise
  extends Promise<BillSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BillPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BillPreviousValuesPromise>() => T;
}

export interface BillSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BillSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BillSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BillPreviousValuesSubscription>() => T;
}

export interface BillPreviousValues {
  createdAt: DateTimeOutput;
  closedAt?: DateTimeOutput;
  id: ID_Output;
  status: BillStatus;
  discount?: Float;
  discountReason?: String;
  value?: Float;
  wasReopen?: Boolean;
  registered?: Boolean;
}

export interface BillPreviousValuesPromise
  extends Promise<BillPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  closedAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  status: () => Promise<BillStatus>;
  discount: () => Promise<Float>;
  discountReason: () => Promise<String>;
  value: () => Promise<Float>;
  wasReopen: () => Promise<Boolean>;
  registered: () => Promise<Boolean>;
}

export interface BillPreviousValuesSubscription
  extends Promise<AsyncIterator<BillPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  closedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<BillStatus>>;
  discount: () => Promise<AsyncIterator<Float>>;
  discountReason: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<Float>>;
  wasReopen: () => Promise<AsyncIterator<Boolean>>;
  registered: () => Promise<AsyncIterator<Boolean>>;
}

export interface CheckDataSubscriptionPayload {
  mutation: MutationType;
  node: CheckData;
  updatedFields: String[];
  previousValues: CheckDataPreviousValues;
}

export interface CheckDataSubscriptionPayloadPromise
  extends Promise<CheckDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CheckDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CheckDataPreviousValuesPromise>() => T;
}

export interface CheckDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CheckDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CheckDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CheckDataPreviousValuesSubscription>() => T;
}

export interface CheckDataPreviousValues {
  id: ID_Output;
  checkbookId?: String;
  compensationNumber?: Int;
  bankNumber?: Int;
}

export interface CheckDataPreviousValuesPromise
  extends Promise<CheckDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  checkbookId: () => Promise<String>;
  compensationNumber: () => Promise<Int>;
  bankNumber: () => Promise<Int>;
}

export interface CheckDataPreviousValuesSubscription
  extends Promise<AsyncIterator<CheckDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  checkbookId: () => Promise<AsyncIterator<String>>;
  compensationNumber: () => Promise<AsyncIterator<Int>>;
  bankNumber: () => Promise<AsyncIterator<Int>>;
}

export interface ClientSubscriptionPayload {
  mutation: MutationType;
  node: Client;
  updatedFields: String[];
  previousValues: ClientPreviousValues;
}

export interface ClientSubscriptionPayloadPromise
  extends Promise<ClientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClientPreviousValuesPromise>() => T;
}

export interface ClientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClientPreviousValuesSubscription>() => T;
}

export interface ClientPreviousValues {
  id: ID_Output;
  name: String;
  address: String;
  complement?: String;
  postCode: String;
  telephoneNumber: String;
  distanceKm: String;
  distanceTime: String;
}

export interface ClientPreviousValuesPromise
  extends Promise<ClientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  complement: () => Promise<String>;
  postCode: () => Promise<String>;
  telephoneNumber: () => Promise<String>;
  distanceKm: () => Promise<String>;
  distanceTime: () => Promise<String>;
}

export interface ClientPreviousValuesSubscription
  extends Promise<AsyncIterator<ClientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  complement: () => Promise<AsyncIterator<String>>;
  postCode: () => Promise<AsyncIterator<String>>;
  telephoneNumber: () => Promise<AsyncIterator<String>>;
  distanceKm: () => Promise<AsyncIterator<String>>;
  distanceTime: () => Promise<AsyncIterator<String>>;
}

export interface EmployeeSubscriptionPayload {
  mutation: MutationType;
  node: Employee;
  updatedFields: String[];
  previousValues: EmployeePreviousValues;
}

export interface EmployeeSubscriptionPayloadPromise
  extends Promise<EmployeeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployeePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePreviousValuesPromise>() => T;
}

export interface EmployeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeePreviousValuesSubscription>() => T;
}

export interface EmployeePreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  employeeId: Int;
  name: String;
  role: String;
  admissionDate?: DateTimeOutput;
  terminationDate?: DateTimeOutput;
  isActive: Boolean;
}

export interface EmployeePreviousValuesPromise
  extends Promise<EmployeePreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  employeeId: () => Promise<Int>;
  name: () => Promise<String>;
  role: () => Promise<String>;
  admissionDate: () => Promise<DateTimeOutput>;
  terminationDate: () => Promise<DateTimeOutput>;
  isActive: () => Promise<Boolean>;
}

export interface EmployeePreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  employeeId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<String>>;
  admissionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  terminationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
}

export interface EstablishmentSubscriptionPayload {
  mutation: MutationType;
  node: Establishment;
  updatedFields: String[];
  previousValues: EstablishmentPreviousValues;
}

export interface EstablishmentSubscriptionPayloadPromise
  extends Promise<EstablishmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EstablishmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EstablishmentPreviousValuesPromise>() => T;
}

export interface EstablishmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EstablishmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EstablishmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EstablishmentPreviousValuesSubscription>() => T;
}

export interface EstablishmentPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  name: String;
  lat: Float;
  long: Float;
  restaurantId: String;
  valueInCashRegister: Float;
  maximumInCashRegister: Float;
  incomeMaxReference: Int;
  isOpen: Boolean;
  discountReasons: String[];
  totalInvoices?: Int;
}

export interface EstablishmentPreviousValuesPromise
  extends Promise<EstablishmentPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  lat: () => Promise<Float>;
  long: () => Promise<Float>;
  restaurantId: () => Promise<String>;
  valueInCashRegister: () => Promise<Float>;
  maximumInCashRegister: () => Promise<Float>;
  incomeMaxReference: () => Promise<Int>;
  isOpen: () => Promise<Boolean>;
  discountReasons: () => Promise<String[]>;
  totalInvoices: () => Promise<Int>;
}

export interface EstablishmentPreviousValuesSubscription
  extends Promise<AsyncIterator<EstablishmentPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  lat: () => Promise<AsyncIterator<Float>>;
  long: () => Promise<AsyncIterator<Float>>;
  restaurantId: () => Promise<AsyncIterator<String>>;
  valueInCashRegister: () => Promise<AsyncIterator<Float>>;
  maximumInCashRegister: () => Promise<AsyncIterator<Float>>;
  incomeMaxReference: () => Promise<AsyncIterator<Int>>;
  isOpen: () => Promise<AsyncIterator<Boolean>>;
  discountReasons: () => Promise<AsyncIterator<String[]>>;
  totalInvoices: () => Promise<AsyncIterator<Int>>;
}

export interface ExpenseSubscriptionPayload {
  mutation: MutationType;
  node: Expense;
  updatedFields: String[];
  previousValues: ExpensePreviousValues;
}

export interface ExpenseSubscriptionPayloadPromise
  extends Promise<ExpenseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpensePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpensePreviousValuesPromise>() => T;
}

export interface ExpenseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpenseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpenseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpensePreviousValuesSubscription>() => T;
}

export interface ExpensePreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  NFE: Boolean;
  NFEReference?: String;
  date: DateTimeOutput;
  executionDate: DateTimeOutput;
}

export interface ExpensePreviousValuesPromise
  extends Promise<ExpensePreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  NFE: () => Promise<Boolean>;
  NFEReference: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  executionDate: () => Promise<DateTimeOutput>;
}

export interface ExpensePreviousValuesSubscription
  extends Promise<AsyncIterator<ExpensePreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  NFE: () => Promise<AsyncIterator<Boolean>>;
  NFEReference: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  executionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExpenseItemSubscriptionPayload {
  mutation: MutationType;
  node: ExpenseItem;
  updatedFields: String[];
  previousValues: ExpenseItemPreviousValues;
}

export interface ExpenseItemSubscriptionPayloadPromise
  extends Promise<ExpenseItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpenseItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpenseItemPreviousValuesPromise>() => T;
}

export interface ExpenseItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpenseItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpenseItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpenseItemPreviousValuesSubscription>() => T;
}

export interface ExpenseItemPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  quantity: Float;
  value: Float;
  details?: String;
}

export interface ExpenseItemPreviousValuesPromise
  extends Promise<ExpenseItemPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Float>;
  value: () => Promise<Float>;
  details: () => Promise<String>;
}

export interface ExpenseItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ExpenseItemPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Float>>;
  value: () => Promise<AsyncIterator<Float>>;
  details: () => Promise<AsyncIterator<String>>;
}

export interface IncomeSubscriptionPayload {
  mutation: MutationType;
  node: Income;
  updatedFields: String[];
  previousValues: IncomePreviousValues;
}

export interface IncomeSubscriptionPayloadPromise
  extends Promise<IncomeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IncomePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IncomePreviousValuesPromise>() => T;
}

export interface IncomeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IncomeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IncomeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IncomePreviousValuesSubscription>() => T;
}

export interface IncomePreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  reference: String;
  value: Float;
  type?: String;
}

export interface IncomePreviousValuesPromise
  extends Promise<IncomePreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  reference: () => Promise<String>;
  value: () => Promise<Float>;
  type: () => Promise<String>;
}

export interface IncomePreviousValuesSubscription
  extends Promise<AsyncIterator<IncomePreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  reference: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<Float>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface ItemPreviousValues {
  id: ID_Output;
  itemId: String;
  name: String;
  price: Float;
  priceToGo?: Float;
  employeePrice?: Float;
  category: String;
  canTakeToGo?: Boolean;
  isActive: Boolean;
  hasTaxSubstitution?: Boolean;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  itemId: () => Promise<String>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  priceToGo: () => Promise<Float>;
  employeePrice: () => Promise<Float>;
  category: () => Promise<String>;
  canTakeToGo: () => Promise<Boolean>;
  isActive: () => Promise<Boolean>;
  hasTaxSubstitution: () => Promise<Boolean>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  itemId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  priceToGo: () => Promise<AsyncIterator<Float>>;
  employeePrice: () => Promise<AsyncIterator<Float>>;
  category: () => Promise<AsyncIterator<String>>;
  canTakeToGo: () => Promise<AsyncIterator<Boolean>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  hasTaxSubstitution: () => Promise<AsyncIterator<Boolean>>;
}

export interface NCMSubscriptionPayload {
  mutation: MutationType;
  node: NCM;
  updatedFields: String[];
  previousValues: NCMPreviousValues;
}

export interface NCMSubscriptionPayloadPromise
  extends Promise<NCMSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NCMPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NCMPreviousValuesPromise>() => T;
}

export interface NCMSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NCMSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NCMSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NCMPreviousValuesSubscription>() => T;
}

export interface NCMPreviousValues {
  id: ID_Output;
  identifier: String;
  description?: String;
}

export interface NCMPreviousValuesPromise
  extends Promise<NCMPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  identifier: () => Promise<String>;
  description: () => Promise<String>;
}

export interface NCMPreviousValuesSubscription
  extends Promise<AsyncIterator<NCMPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  identifier: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface OrderPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  block: Int;
  orderId: Int;
  cancelled?: Boolean;
  cancelationJustification?: String;
  wasModified?: Boolean;
  isEmployeeOrder?: Boolean;
  reuse?: Boolean;
  isToGo?: Boolean;
  toGoReference?: String;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  block: () => Promise<Int>;
  orderId: () => Promise<Int>;
  cancelled: () => Promise<Boolean>;
  cancelationJustification: () => Promise<String>;
  wasModified: () => Promise<Boolean>;
  isEmployeeOrder: () => Promise<Boolean>;
  reuse: () => Promise<Boolean>;
  isToGo: () => Promise<Boolean>;
  toGoReference: () => Promise<String>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  block: () => Promise<AsyncIterator<Int>>;
  orderId: () => Promise<AsyncIterator<Int>>;
  cancelled: () => Promise<AsyncIterator<Boolean>>;
  cancelationJustification: () => Promise<AsyncIterator<String>>;
  wasModified: () => Promise<AsyncIterator<Boolean>>;
  isEmployeeOrder: () => Promise<AsyncIterator<Boolean>>;
  reuse: () => Promise<AsyncIterator<Boolean>>;
  isToGo: () => Promise<AsyncIterator<Boolean>>;
  toGoReference: () => Promise<AsyncIterator<String>>;
}

export interface OrderItemSubscriptionPayload {
  mutation: MutationType;
  node: OrderItem;
  updatedFields: String[];
  previousValues: OrderItemPreviousValues;
}

export interface OrderItemSubscriptionPayloadPromise
  extends Promise<OrderItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderItemPreviousValuesPromise>() => T;
}

export interface OrderItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderItemPreviousValuesSubscription>() => T;
}

export interface OrderItemPreviousValues {
  id: ID_Output;
  quantity: Int;
}

export interface OrderItemPreviousValuesPromise
  extends Promise<OrderItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
}

export interface OrderItemPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Int>>;
}

export interface OrderPadSubscriptionPayload {
  mutation: MutationType;
  node: OrderPad;
  updatedFields: String[];
  previousValues: OrderPadPreviousValues;
}

export interface OrderPadSubscriptionPayloadPromise
  extends Promise<OrderPadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPadPreviousValuesPromise>() => T;
}

export interface OrderPadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderPadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderPadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPadPreviousValuesSubscription>() => T;
}

export interface OrderPadPreviousValues {
  id: ID_Output;
  block: Int;
  firstOrderId: Int;
  lastOrderId?: Int;
  used: Boolean;
}

export interface OrderPadPreviousValuesPromise
  extends Promise<OrderPadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  block: () => Promise<Int>;
  firstOrderId: () => Promise<Int>;
  lastOrderId: () => Promise<Int>;
  used: () => Promise<Boolean>;
}

export interface OrderPadPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  block: () => Promise<AsyncIterator<Int>>;
  firstOrderId: () => Promise<AsyncIterator<Int>>;
  lastOrderId: () => Promise<AsyncIterator<Int>>;
  used: () => Promise<AsyncIterator<Boolean>>;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface PaymentPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  value: Float;
  paymentType: String;
  paymentTypeOption?: String;
  isActive: Boolean;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  value: () => Promise<Float>;
  paymentType: () => Promise<String>;
  paymentTypeOption: () => Promise<String>;
  isActive: () => Promise<Boolean>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<Float>>;
  paymentType: () => Promise<AsyncIterator<String>>;
  paymentTypeOption: () => Promise<AsyncIterator<String>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
}

export interface PermissionSubscriptionPayload {
  mutation: MutationType;
  node: Permission;
  updatedFields: String[];
  previousValues: PermissionPreviousValues;
}

export interface PermissionSubscriptionPayloadPromise
  extends Promise<PermissionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PermissionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PermissionPreviousValuesPromise>() => T;
}

export interface PermissionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PermissionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PermissionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PermissionPreviousValuesSubscription>() => T;
}

export interface PermissionPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  role: UserRole;
}

export interface PermissionPreviousValuesPromise
  extends Promise<PermissionPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  role: () => Promise<UserRole>;
}

export interface PermissionPreviousValuesSubscription
  extends Promise<AsyncIterator<PermissionPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  role: () => Promise<AsyncIterator<UserRole>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  category: String;
  supplier: String;
  brand?: String;
  unit: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<String>;
  supplier: () => Promise<String>;
  brand: () => Promise<String>;
  unit: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  supplier: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
  unit: () => Promise<AsyncIterator<String>>;
}

export interface TableSubscriptionPayload {
  mutation: MutationType;
  node: Table;
  updatedFields: String[];
  previousValues: TablePreviousValues;
}

export interface TableSubscriptionPayloadPromise
  extends Promise<TableSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TablePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TablePreviousValuesPromise>() => T;
}

export interface TableSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TableSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TableSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TablePreviousValuesSubscription>() => T;
}

export interface TablePreviousValues {
  id: ID_Output;
  tableNumber: Int;
}

export interface TablePreviousValuesPromise
  extends Promise<TablePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  tableNumber: () => Promise<Int>;
}

export interface TablePreviousValuesSubscription
  extends Promise<AsyncIterator<TablePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  tableNumber: () => Promise<AsyncIterator<Int>>;
}

export interface TableDataSubscriptionPayload {
  mutation: MutationType;
  node: TableData;
  updatedFields: String[];
  previousValues: TableDataPreviousValues;
}

export interface TableDataSubscriptionPayloadPromise
  extends Promise<TableDataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TableDataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TableDataPreviousValuesPromise>() => T;
}

export interface TableDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TableDataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TableDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TableDataPreviousValuesSubscription>() => T;
}

export interface TableDataPreviousValues {
  id: ID_Output;
  totalOccupations: Int;
}

export interface TableDataPreviousValuesPromise
  extends Promise<TableDataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  totalOccupations: () => Promise<Int>;
}

export interface TableDataPreviousValuesSubscription
  extends Promise<AsyncIterator<TableDataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  totalOccupations: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  email?: String;
  password?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface WorkDaySubscriptionPayload {
  mutation: MutationType;
  node: WorkDay;
  updatedFields: String[];
  previousValues: WorkDayPreviousValues;
}

export interface WorkDaySubscriptionPayloadPromise
  extends Promise<WorkDaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkDayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkDayPreviousValuesPromise>() => T;
}

export interface WorkDaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkDaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkDaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkDayPreviousValuesSubscription>() => T;
}

export interface WorkDayPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  isCurrent: Boolean;
  openDate: DateTimeOutput;
  closeDate?: DateTimeOutput;
}

export interface WorkDayPreviousValuesPromise
  extends Promise<WorkDayPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  isCurrent: () => Promise<Boolean>;
  openDate: () => Promise<DateTimeOutput>;
  closeDate: () => Promise<DateTimeOutput>;
}

export interface WorkDayPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkDayPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  isCurrent: () => Promise<AsyncIterator<Boolean>>;
  openDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  closeDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WorkHourSubscriptionPayload {
  mutation: MutationType;
  node: WorkHour;
  updatedFields: String[];
  previousValues: WorkHourPreviousValues;
}

export interface WorkHourSubscriptionPayloadPromise
  extends Promise<WorkHourSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkHourPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkHourPreviousValuesPromise>() => T;
}

export interface WorkHourSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkHourSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkHourSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkHourPreviousValuesSubscription>() => T;
}

export interface WorkHourPreviousValues {
  id: ID_Output;
  weekday: WeekDay;
  startTime?: String;
  endTime?: String;
  isDayOff?: Boolean;
}

export interface WorkHourPreviousValuesPromise
  extends Promise<WorkHourPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  weekday: () => Promise<WeekDay>;
  startTime: () => Promise<String>;
  endTime: () => Promise<String>;
  isDayOff: () => Promise<Boolean>;
}

export interface WorkHourPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkHourPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  weekday: () => Promise<AsyncIterator<WeekDay>>;
  startTime: () => Promise<AsyncIterator<String>>;
  endTime: () => Promise<AsyncIterator<String>>;
  isDayOff: () => Promise<AsyncIterator<Boolean>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "WorkDay",
    embedded: false
  },
  {
    name: "Establishment",
    embedded: false
  },
  {
    name: "Employee",
    embedded: false
  },
  {
    name: "WorkHour",
    embedded: false
  },
  {
    name: "OrderPad",
    embedded: false
  },
  {
    name: "Expense",
    embedded: false
  },
  {
    name: "ExpenseItem",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Income",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "CheckData",
    embedded: false
  },
  {
    name: "Bill",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "Table",
    embedded: false
  },
  {
    name: "TableData",
    embedded: false
  },
  {
    name: "OrderItem",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "NCM",
    embedded: false
  },
  {
    name: "Client",
    embedded: false
  },
  {
    name: "BillStatus",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "WeekDay",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
